;*****************************************************************************
;
; File:        EmployeeIO.dbl
;
; Description: Various functions that performs SDMS I/O for EMPLOYEE
;
;*****************************************************************************
; WARNING: THIS CODE WAS CODE GENERATED AND WILL BE OVERWRITTEN IF CODE
;          GENERATION IS RE-EXECUTED FOR THIS PROJECT.
;*****************************************************************************

import ReplicationLibrary
import Synergex.SynergyDE.Select
.ifdef DBLNET
import System.IO
.endc
import System.Text

.ifndef strEmployee
.include "EMPLOYEE" repository, structure="strEmployee", end
.endc

.define writelog(x) if Settings.LogFileChannel && %chopen(Settings.LogFileChannel) writes(Settings.LogFileChannel,%string(^d(now(1:14)),"XXXX-XX-XX XX:XX:XX") + " " + x)
.define writett(x)  if Settings.TerminalChannel writes(Settings.TerminalChannel,"   - " + %string(^d(now(9:8)),"XX:XX:XX.XX") + " " + x)

;*****************************************************************************
; <summary>
; Determines if REPLICATOR_DATA:EMPLOYEE.ISM exists in the replicated data set.
; </summary>
; <param name="errorMessage">Returned error message.</param>
; <returns>Returns 1 if the file exists, otherwise a number indicating the type of error.</returns>

function Employee$Exists, ^val
    required out errorMessage, a
    endparams

    .align
    stack record localData
        status,  int    ;Returned status
    endrecord

proc
    init localData
    errorMessage = ""

    if (ReplicationLibrary.File.Exists("REPLICATOR_DATA:EMPLOYEE.ISM")) then
        status = 1
    else
    begin
        status = 0
        errorMessage = "File REPLICATOR_DATA:EMPLOYEE.ISM does not exist!"
    end

    freturn status

endfunction

;*****************************************************************************
; <summary>
; Creates REPLICATOR_DATA:EMPLOYEE.ISM in the replicated data set.
; </summary>
; <param name="errorMessage">Returned error message.</param>
; <returns>Returns true on success, otherwise false.</returns>

function EmployeeCreate_, ^val
    required out errorMessage, a

    .align
    stack record localData
        ok,     boolean    ;Return status
    endrecord

proc
    init localData
    ok = true
    errorMessage = ""

    try
    begin
        xcall isamc("REPLICATOR_DATA:EMPLOYEE.ISM,FIXED,COMPRESS,DENSITY=50,PAGE=1024",300,5,
        & "START=1,LENGTH=8,NAME=EMP_ID,TYPE=ALPHA,ASCEND,DENSITY=50,DUPS,NOATEND,NOMODIFY",
        & "START=49,LENGTH=15,NAME=EMP_DEPT,ASCEND,DENSITY=50,NODUPS,MODIFY",
        & "START=29,LENGTH=20,NAME=EMP_LAST_NAME,TYPE=NOCASE,ORDER=A,DENSITY=50,NODUPS,MODIFY",
        & "START=218,LENGTH=2,NAME=STATE_CODE,TYPE=ALPHA,ORDER=A,DENSITY=50,NODUPS,MODIFY",
        & "START=220,LENGTH=5,NAME=ZIP_CODE,TYPE=ALPHA,ORDER=A,DENSITY=50,NODUPS,MODIFY"
        & )
    end
    catch (ex, @Exception)
    begin
        ok = false
        errorMessage = "Failed to create REPLICATOR_DATA:EMPLOYEE.ISM. Error was " + ex.Message
    end
    endtry

    freturn ok

endfunction

;*****************************************************************************
; <summary>
; Not used in the SDMS replication use case.
; </summary>
; <param name="errorMessage">Returned error message.</param>
; <returns>Returns true on success, otherwise false.</returns>

function Employee$Index, ^val
    required out errorMessage, a
proc
    errorMessage = ""
    freturn true
endfunction

;*****************************************************************************
; <summary>
; Not used in the SDMS replication use case.
; </summary>
; <param name="errorMessage">Returned error message.</param>
; <returns>Returns true on success, otherwise false.</returns>

function Employee$UnIndex, ^val
    required out errorMessage, a
proc
    errorMessage = ""
    freturn true
endfunction

;*****************************************************************************
; <summary>
; Insert a record into REPLICATOR_DATA:EMPLOYEE.ISM.
; </summary>
; <param name="recordData">Record to be inserted.</param>
; <param name="errorMessage">Returned error message.</param>
; <returns>Returns 1 if the row was inserted, 2 to indicate the row already exists, or 0 if an error occurred.</returns>

function Employee$Insert, ^val
    required in  recordData,   a
    required out errorMessage, a

    .align
    stack record localData
        status, int
    endrecord

    external common
        chEmployee, int
    endcommon

proc
    ;Make sure the channel is open
    if (!chEmployee && !Open$Employee(errorMessage))
    begin
        freturn 0
    end

    init localData
    status = 1
    errorMessage = ""

    try
    begin
        store(chEmployee,recordData)
    end
    catch (ex, @DuplicateException)
    begin
        status = 2
        errorMessage = "Record already exists!"
    end
    catch (ex, @Exception)
    begin
        status = 0
        errorMessage = "Failed to insert record. Error was " + ex.Message
    end
    endtry

    freturn status

endfunction

;*****************************************************************************
; <summary>
; Inserts multiple records into REPLICATOR_DATA:EMPLOYEE.ISM.
; </summary>
; <param name="recordsHandle">Memory handle containing one or more rows to insert.</param>
; <param name="errorMessage">Returned error text.</param>
; <param name="exceptionRecordsHandle">Memory handle to load exception data records into.</param>
; <returns>Returns true on success, otherwise false.</returns>

function Employee$InsertRows, ^val
    required in  recordsHandle, D_HANDLE
    required out errorMessage, a
    required out exceptionRecordsHandle, D_HANDLE

    .define EXCEPTION_BUFSZ 100

    stack record localData
        ok          ,boolean    ;Return status
        rows        ,int        ;Number of rows to insert
        ex_ms       ,int        ;Size of exception array
        ex_mc       ,int        ;Items in exception array
    endrecord

    .include "EMPLOYEE" repository, structure="inpbuf", nofields, end
    .include "EMPLOYEE" repository, static record="employee", end

    external common
        chEmployee, int
    endcommon

proc
    ;Make sure the channel is open
    if (!chEmployee && !Open$Employee(errorMessage))
    begin
        freturn false
    end

    init localData
    ok = true

    ;Figure out how many records to insert

    rows = (%mem_proc(DM_GETSIZE,recordsHandle)/^size(inpbuf))

    ;Insert the records into the database

    if (ok)
    begin
        data cnt, int
        for cnt from 1 thru rows
        begin
            ;Load data into bound record

            employee = ^m(inpbuf[cnt],recordsHandle)

            ;Insert the record into the file
            try
            begin
                store(chEmployee,employee)
            end
            catch (ex, @Exception)
            begin
                ;If the insert failed, record the exception in the exceptions buffer
                ex_mc += 1
                if (ex_mc == 0) then
                begin
                    exceptionRecordsHandle = %mem_proc(DM_ALLOC,^size(inpbuf)*EXCEPTION_BUFSZ)
                end
                else if (ex_mc >= ex_ms)
                begin
                    exceptionRecordsHandle = %mem_proc(DM_RESIZ,^size(inpbuf)*(ex_ms+=EXCEPTION_BUFSZ),exceptionRecordsHandle)
                end
                ^m(inpbuf[ex_mc],exceptionRecordsHandle) = employee
            end
            endtry
        end
    end

    ;Resize the returned exceptions buffer to the correct size

    if (ex_mc)
    begin
        exceptionRecordsHandle = %mem_proc(DM_RESIZ,^size(inpbuf)*ex_mc,exceptionRecordsHandle)
        errorMessage = "Failed to insert " + %string(ex_mc) + " records"
    end

    freturn ok

endfunction

;*****************************************************************************
; <summary>
; Updates a record in REPLICATOR_DATA:EMPLOYEE.ISM.
; </summary>
; <param name="dataRecord">Record containing data to update.</param>
; <param name="recordsUpdated">Returned number of rows affected.</param>
; <param name="errorMessage">Returned error message.</param>
; <returns>Returns true on success, otherwise false.</returns>

function Employee$Update, ^val
    required in  dataRecord, a
    required out recordsUpdated, i
    required out errorMessage, a

    stack record localData
        ok, boolean
        keyValue, a255
        keyLength, i4
    endrecord

    static record
        employee, strEmployee
    endrecord

    external function
        EmployeeKeyVal, ^val
        EmployeeKeyNum, ^val
    endexternal

    external common
        chEmployee, int
    endcommon

proc
    ;Make sure the channel is open
    if (!chEmployee && !Open$Employee(errorMessage))
    begin
        freturn false
    end

    init localData
    recordsUpdated = 0
    ok = false

    ;Extract the key value from the RECORD

    xcall EmployeeKeyVal(dataRecord,keyValue,keyLength)

    ;Read the record to lock it

    try
    begin
        read(chEmployee,employee,keyValue(1:keyLength),KEYNUM:%EmployeeKeyNum)
    end
    catch (ex, @Exception)
    begin
        errorMessage = "Failed to update record. Error was " + ex.Message
    end
    endtry

    ;Update the record in the file

    if (ok)
    begin
        employee = dataRecord
        try
        begin
            write(chEmployee,employee)
            recordsUpdated = 1
            ok = true
        end
        catch (ex, @Exception)
        begin
            unlock chEmployee
            errorMessage = "Failed to update record. Error was " + ex.Message
        end
        endtry
    end

    freturn ok

endfunction

;*****************************************************************************
; <summary>
; Deletes a record from REPLICATOR_DATA:EMPLOYEE.ISM
; </summary>
; <param name="keyValue">Unique key of record to be deleted.</param>
; <param name="errorMessage">Returned error message.</param>
; <returns>Returns true on success, otherwise false.</returns>

function Employee$Delete, ^val
    required in  keyValue, a
    required out errorMessage, a
    .include "EMPLOYEE" repository, stack record="employee", nofields
    external function
        EmployeeKeyNum, ^val
    endexternal
    external common
        chEmployee, int
    endcommon
proc
    ;Make sure the channel is open
    if (!chEmployee && !Open$Employee(errorMessage))
    begin
        freturn false
    end

    ;TODO: Needs to support relative files on OpenVMS
    try
    begin
        read(chEmployee,employee,keyValue,KEYNUM:%EmployeeKeyNum)
        try
        begin
            delete(chEmployee)
            errorMessage = ""
            freturn true
        end
        catch (ex, @Exception)
        begin
            unlock chEmployee
            errorMessage = "Failed to delete record. Error was " + ex.Message
        end
        endtry
    end
    catch (ex, @Exception)
    begin
        errorMessage = "Failed to read and lock record for delete. Error was " + ex.Message
    end
    endtry

    freturn false

endfunction

;*****************************************************************************
; <summary>
; Deletes all rows from the Employee table.
; </summary>
; <param name="errorMessage">Returned error text.</param>
; <returns>Returns true on success, otherwise false.</returns>

function Employee$Clear, ^val
    required out errorMessage, a
    external common
        chEmployee, int
    endcommon
proc
    errorMessage = ""

    ;If the file is open, close it

    if (chEmployee)
    begin
        close chEmployee
        chEmployee = 0
    end

    ;Clear the file

    try
    begin
        data ignored, i4
        xcall isclr("FILE_NAME",ignored)
        freturn true
    end
    catch (ex, @Exception)
    begin
        errorMessage = "Failed to clear file REPLICATOR_DATA:EMPLOYEE.ISM. Error was " + ex.Message
    end
    endtry

    freturn false

endfunction

;*****************************************************************************
; <summary>
; Deletes the Employee table from the database.
; </summary>
; <param name="errorMessage">Returned error message.</param>
; <returns>Returns true on success, otherwise false.</returns>

function Employee$Drop, ^val
    required out errorMessage, a
    external common
        chEmployee, int
    endcommon
proc
    errorMessage = ""

    ;If the file is open, close it

    if (chEmployee)
    begin
        close chEmployee
        chEmployee = 0
    end

    try
    begin
        xcall delet("REPLICATOR_DATA:EMPLOYEE.ISM")
        freturn true
    end
    catch (ex, @Exception)
    begin
        errorMessage = "Failed to delete REPLICATOR_DATA:EMPLOYEE.ISM. Error was " + ex.Message
    end
    endtry

    freturn false

endfunction

;*****************************************************************************
; <summary>
; Load all data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table.
; </summary>
; <param name="a_maxrows">Maximum number of rows to load.</param>
; <param name="a_added">Total number of successful inserts.</param>
; <param name="a_failed">Total number of failed inserts.</param>
; <param name="errorMessage">Returned error message (if return value is false).</param>
; <returns>Returns true on success, otherwise false.</returns>

function Employee$Load, ^val
    required in  a_maxrows,       n
    required out a_added,         n
    required out a_failed,        n
    required out errorMessage,    a

    .include "CONNECTDIR:ssql.def"
    .include "EMPLOYEE" repository, structure="inpbuf", end
    .include "EMPLOYEE" repository, stack record="tmprec", end

    .define BUFFER_ROWS     1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;Return status
        firstRecord ,boolean    ;Is this the first record?
        filechn     ,int        ;Data file channel
        mh          ,D_HANDLE   ;Memory handle containing data to insert
        ms          ,int        ;Size of memory buffer in rows
        mc          ,int        ;Memory buffer rows currently used
        ex_mh       ,D_HANDLE   ;Memory buffer for exception records
        ex_mc       ,int        ;Number of records in returned exception array
        ex_ch       ,int        ;Exception log file channel
        attempted   ,int        ;Rows being attempted
        done_records,int        ;Records loaded
        max_records ,int        ;Maximum records to load
        ttl_added   ,int        ;Total rows added
        ttl_failed  ,int        ;Total failed inserts
        errnum      ,int        ;Error number
        now         ,a20        ;Current date and time
        timer       ,@Timer
    endrecord

    external common
        chEmployee, int
    endcommon
proc
    ;Make sure the channel is open
    if (!chEmployee && !Open$Employee(errorMessage))
    begin
        freturn false
    end

    init local_data
    ok = true
    errorMessage = ""

    timer = new Timer()
    timer.Start()

    ;If we are logging exceptions, delete any existing exceptions file.
    if (Settings.LogBulkLoadExceptions)
    begin
        xcall delet("REPLICATOR_LOGDIR:employee_data_exceptions.log")
    end

    ;Open the data file associated with the structure

    if (!(filechn = %EmployeeOpenInput(errorMessage)))
    begin
        errorMessage = "Failed to open data file! Error was " + %atrim(errorMessage)
        ok = false
    end

    ;Were we passed a max # records to load

    max_records = a_maxrows > 0 ? a_maxrows : 0
    done_records = 0

    if (ok)
    begin
        ;Allocate memory buffer for the database rows

        mh = %mem_proc(DM_ALLOC,^size(inpbuf)*(ms=BUFFER_ROWS))

        ;Read records from the input file

        firstRecord = true
        repeat
        begin
            ;Get the next record from the input file
            try
            begin
                if (firstRecord) then
                begin
                    read(filechn,tmprec,^FIRST)
                    firstRecord = false
                end
                else
                begin
                    reads(filechn,tmprec)
                end
            end
            catch (ex, @EndOfFileException)
            begin
                exitloop
            end
            catch (ex, @Exception)
            begin
                ok = false
                errorMessage = "Unexpected error while reading data file: " + ex.Message
                exitloop
            end
            endtry

            ;Got one, load it into or buffer
            ^m(inpbuf[mc+=1],mh) = tmprec

            incr done_records

            ;If the buffer is full, write it to the database
            if (mc==ms)
            begin
                call insert_data
            end

            if (max_records && (done_records == max_records))
            begin
                exitloop
            end
        end

        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(inpbuf)*mc,mh)
            call insert_data
        end

        ;Deallocate memory buffer

        mh = %mem_proc(DM_FREE,mh)

    end

    ;Close the file
    if (filechn && %chopen(filechn))
        close filechn

    ;Close the exceptions log file
    if (ex_ch && %chopen(ex_ch))
        close ex_ch

    ;Return totals
    a_added = ttl_added
    a_failed = ttl_failed

    timer.Stop()
    now = %datetime

    if (ok) then
    begin
        writelog("Load COMPLETE after " + timer.ElapsedTimeString)
        writett("Load COMPLETE after " + timer.ElapsedTimeString)
    end
    else
    begin
        writelog("Load FAILED after " + timer.ElapsedTimeString)
        writett("Load FAILED after " + timer.ElapsedTimeString)
    end

    freturn ok

insert_data,

    attempted = (%mem_proc(DM_GETSIZE,mh)/^size(inpbuf))

    if (%EmployeeInsertRows(mh,errorMessage,ex_mh))
    begin
        ;Any exceptions?
        if (ex_mh) then
        begin
            ;How many exceptions to log?
            ex_mc = (%mem_proc(DM_GETSIZE,ex_mh)/^size(inpbuf))
            ;Update totals
            ttl_failed+=ex_mc
            ttl_added+=(attempted-ex_mc)
            ;Are we logging exceptions?
            if (Settings.LogBulkLoadExceptions) then
            begin
                data cnt, int
                ;Open the log file
                if (!ex_ch)
                    open(ex_ch=0,o:s,"REPLICATOR_LOGDIR:employee_data_exceptions.log")
                ;Log the exceptions
                for cnt from 1 thru ex_mc
                    writes(ex_ch,^m(inpbuf[cnt],ex_mh))
                if (Settings.RunningOnTerminal)
                    writes(Settings.TerminalChannel,"Exceptions were logged to REPLICATOR_LOGDIR:employee_data_exceptions.log")
            end
            else
            begin
                ;No, report and error
                ok = false
            end
            ;Release the exception buffer
            ex_mh=%mem_proc(DM_FREE,ex_mh)
        end
        else
        begin
            ;No exceptions
            ttl_added += attempted
            if (Settings.RunningOnTerminal && Settings.LogLoadProgress)
            begin
                writes(Settings.TerminalChannel," - " + %string(ttl_added) + " rows inserted")
            end
        end
    end

    clear mc

    return

endfunction

;*****************************************************************************
; <summary>
; Bulk load data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table via a CSV file.
; </summary>
; <param name="recordsToLoad">Number of records to load (0=all)</param>
; <param name="a_records">Records loaded</param>
; <param name="a_exceptions">Records failes</param>
; <param name="errorMessage">Error message (if return value is false)</param>
; <returns>Returns true on success, otherwise false.</returns>

function Employee$BulkLoad, ^val
    required in recordsToLoad, n
    required out a_records,    n
    required out a_exceptions, n
    required out errorMessage, a

    .include "CONNECTDIR:ssql.def"

     stack record local_data
        ok,                     boolean    ;Return status
        transaction,            boolean
        cursorOpen,             boolean
        remoteBulkLoad,         boolean
        sql,                    string
        localCsvFile,           string
        localExceptionsFile,    string
        localExceptionsLog,     string
        remoteCsvFile,          string
        remoteExceptionsFile,   string
        remoteExceptionsLog,    string
        copyTarget,             string
        fileToLoad,             string
        cursor,                 int
        length,                 int
        dberror,                int
        recordCount,            int	        ;# records to load / loaded
        exceptionCount,         int
        fsc,                    @FileServiceClient
        now,                    a20
        timer,                  @Timer
    endrecord

    external common
        chEmployee, int
    endcommon
proc
    ;Make sure the channel is open
    if (!chEmployee && !Open$Employee(errorMessage))
    begin
        freturn false
    end

    init local_data
    ok = true

    timer = new Timer()
    timer.Start()

    ;If we're doing a remote bulk load, create an instance of the FileService client and verify that we can access the FileService server

    remoteBulkLoad = Settings.CanBulkLoad() && Settings.DatabaseIsRemote()

    if (remoteBulkLoad)
    begin
        fsc = new FileServiceClient(Settings.FileServiceHost,Settings.FileServicePort)

        now = %datetime
        writelog("Verifying FileService connection")
        writett("Verifying FileService connection")

        if (!fsc.Ping(errorMessage))
        begin
            errorMessage = "No response from FileService, bulk upload cancelled"
            now = %datetime
            writelog(errorMessage)
            writett(errorMessage)
            ok = false
        end
    end

    if (ok)
    begin
        ;Determine temporary file names

        .ifdef OS_WINDOWS7
        localCsvFile = Settings.LocalExportPath + "\Employee.csv"
        .endc
        .ifdef OS_UNIX
        localCsvFile = Settings.LocalExportPath + "/Employee.csv"
        .endc
        .ifdef OS_VMS
        localCsvFile = Settings.LocalExportPath + "Employee.csv"
        .endc
        localExceptionsFile  = localCsvFile + "_err"
        localExceptionsLog   = localExceptionsFile + ".Error.Txt"

        if (remoteBulkLoad)
        begin
            remoteCsvFile = "Employee.csv"
            remoteExceptionsFile = remoteCsvFile + "_err"
            remoteExceptionsLog  = remoteExceptionsFile + ".Error.Txt"
        end

        ;Make sure there are no files left over from previous operations

        ;Delete local files

        now = %datetime
        writelog("Deleting local files")
        writett("Deleting local files")

        xcall delet(localCsvFile)
        xcall delet(localExceptionsFile)
        xcall delet(localExceptionsLog)

        ;Delete remote files

        if (remoteBulkLoad)
        begin
            now = %datetime
            writelog("Deleting remote files")
            writett("Deleting remote files")

            fsc.Delete(remoteCsvFile)
            fsc.Delete(remoteExceptionsFile)
            fsc.Delete(remoteExceptionsLog)
        end

        ;And export the data

        now = %datetime
        writelog("Exporting delimited file")
        writett("Exporting delimited file")

        ok = %EmployeeCsv(localCsvFile,recordsToLoad,recordCount,errorMessage)
    end

    if (ok)
    begin
        ;If necessary, upload the exported file to the database server

        if (remoteBulkLoad) then
        begin
            now = %datetime
            writelog("Uploading delimited file to database host")
            writett("Uploading delimited file to database host")
            ok = fsc.UploadChunked(localCsvFile,remoteCsvFile,320,fileToLoad,errorMessage)
        end
        else
        begin
            fileToLoad  = localCsvFile
        end
    end

    if (ok)
    begin
        ;Bulk load the database table

        ;If we're in manual commit mode, start a transaction

        if (Settings.DatabaseCommitMode==DatabaseCommitMode.Manual)
        begin
            now = %datetime
            writelog("Starting transaction")
            ok = %StartTransactionSqlConnection(transaction,errorMessage)
        end

        ;Open a cursor for the statement

        if (ok)
        begin
            sql = "BULK INSERT Employee FROM '" + fileToLoad + "' WITH (FIRSTROW=2,FIELDTERMINATOR='|',ROWTERMINATOR='\n',MAXERRORS=100000000,ERRORFILE='" + fileToLoad + "_err'"

            if (Settings.BulkLoadBatchSize > 0)
            begin
                sql = sql + ",BATCHSIZE=" + %string(Settings.BulkLoadBatchSize)
            end

           sql = sql + ")"

            if (%ssc_open(Settings.DatabaseChannel,cursor,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_NORMAL) then
                cursorOpen = true
            else
            begin
                ok = false
                if (%ssc_getemsg(Settings.DatabaseChannel,errorMessage,length,,dberror)==SSQL_FAILURE)
                    errorMessage = "Failed to open cursor"
            end
        end

        ;Set the SQL statement execution timeout to the bulk load value

        if (ok)
        begin
            now = %datetime
            writelog("Setting database timeout to " + %string(Settings.BulkLoadTimeout) + " seconds")
            writett("Setting database timeout to " + %string(Settings.BulkLoadTimeout) + " seconds")
            if (%ssc_cmd(Settings.DatabaseChannel,,SSQL_TIMEOUT,%string(Settings.BulkLoadTimeout))==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(Settings.DatabaseChannel,errorMessage,length,,dberror)==SSQL_FAILURE)
                    errorMessage = "Failed to set database timeout"
            end
        end

        ;Execute the statement

        if (ok)
        begin
            now = %datetime
            writelog("Executing BULK INSERT")
            writett("Executing BULK INSERT")

            if (%ssc_execute(Settings.DatabaseChannel,cursor,SSQL_STANDARD)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(Settings.DatabaseChannel,errorMessage,length,,dberror)==SSQL_NORMAL) then
                begin
                    xcall ThrowOnCommunicationError(dberror,errorMessage)
                    errorMessage = "Bulk insert error: " + %atrim(errorMessage)
                    now = %datetime
                    writelog(errorMessage)
                    writett(errorMessage)

                    using dberror select
                    (-4864),
                    begin
                        ;Bulk load data conversion error
                        now = %datetime
                        writelog("Data conversion errors reported")
                        writett("Data conversion errors reported")
                        clear dberror, errorMessage
                        call GetExceptionDetails
                    end
                    (),
                    begin
                        errorMessage = %string(dberror) + " " + errorMessage
                        ok = false
                    end
                    endusing
                end
                else
                begin
                    errorMessage = "Failed to execute SQL statement"
                    ok = false
                end
            end

            ;Delete local temp files

            now = %datetime
            writelog("Deleting local temp files")
            writett("Deleting local temp files")

            xcall delet(localCsvFile)
            xcall delet(localExceptionsFile)
            xcall delet(localExceptionsLog)

            ;Delete remote temp files

            if (remoteBulkLoad)
            begin
                now = %datetime
                writelog("Deleting remote temp files")
                writett("Deleting remote temp files")

                fsc.Delete(remoteCsvFile)
                fsc.Delete(remoteExceptionsFile)
                fsc.Delete(remoteExceptionsLog)
            end
        end

        ;If we're in manual commit mode, commit or rollback the transaction

        if ((Settings.DatabaseCommitMode==DatabaseCommitMode.Manual) && transaction)
        begin
            now = %datetime
            if (ok) then
            begin
                writelog("COMMIT")
                writett("COMMIT")
                ok = %CommitTransactionSqlConnection(Settings.DatabaseChannel,errorMessage)
            end
            else
            begin
                ;There was an error, rollback the transaction
                writelog("ROLLBACK")
                writett("ROLLBACK")
                ok = %RollbackSqlConnection(Settings.DatabaseChannel,errorMessage)
            end
        end

        ;Set the database timeout back to the regular value

        now = %datetime
        writelog("Resetting database timeout to " + %string(Settings.DatabaseTimeout) + " seconds")
        writett("Resetting database timeout to " + %string(Settings.DatabaseTimeout) + " seconds")

        if (%ssc_cmd(Settings.DatabaseChannel,,SSQL_TIMEOUT,%string(Settings.DatabaseTimeout))==SSQL_FAILURE)
            nop

        ;Close the cursor

        if (cursorOpen)
        begin
            if (%ssc_close(Settings.DatabaseChannel,cursor)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(Settings.DatabaseChannel,errorMessage,length,,dberror)==SSQL_FAILURE)
                    errorMessage = "Failed to close cursor"
            end
        end
    end

    ; Return the record and exception count
    a_records = recordCount
    a_exceptions = exceptionCount

    timer.Stop()
    now = %datetime

    if (ok) then
    begin
        writelog("Bulk load finished in " + timer.ElapsedTimeString)
        writett("Bulk load finished in " + timer.ElapsedTimeString)
    end
    else
    begin
        writelog("Bulk load failed after " + timer.ElapsedTimeString)
        writett("Bulk load failed after " + timer.ElapsedTimeString)
    end

    freturn ok

GetExceptionDetails,

    ;If we get here then the bulk load reported one or more "data conversion error" issues
    ;There should be two files on the server

    now = %datetime
    writelog("Data conversion errors, processing exceptions")
    writett("Data conversion errors, processing exceptions")

    if (remoteBulkLoad) then
    begin
        data fileExists, boolean
        data tmpmsg, string

        if (fsc.Exists(remoteExceptionsFile,fileExists,tmpmsg)) then
        begin
            if (fileExists) then
            begin
                ;Download the error file
                data exceptionRecords, [#]string
                data errorMessage, string

                now = %datetime
                writelog("Downloading remote exceptions data file")
                writett("Downloading remote exceptions data file")

                if (fsc.DownloadText(remoteExceptionsFile,exceptionRecords,errorMessage))
                begin
                    data ex_ch, int
                    data exceptionRecord, string

                    open(ex_ch=0,o:s,localExceptionsFile)

                    foreach exceptionRecord in exceptionRecords
                        writes(ex_ch,exceptionRecord)

                    close ex_ch

                    exceptionCount = exceptionRecords.Length

                    now = %datetime
                    writelog(%string(exceptionCount) + " items saved to " + localExceptionsFile)
                    writett(%string(exceptionCount) + " items saved to " + localExceptionsFile)
                end
            end
            else
            begin
                ;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
                now = %datetime
                writelog("Remote exceptions data file not found!")
                writett("Remote exceptions data file not found!")
            end
        end
        else
        begin
            ;Failed to determine if file exists
            now = %datetime
            writelog("Failed to determine if remote exceptions data file exists. Error was " + tmpmsg)
            writett("Failed to determine if remote exceptions data file exists. Error was " + tmpmsg)
        end

        ;Now check for and retrieve the associated exceptions log

        if (fsc.Exists(remoteExceptionsLog,fileExists,tmpmsg)) then
        begin
            if (fileExists) then
            begin
                ;Download the error file
                data exceptionRecords, [#]string
                data errorMessage, string

                now = %datetime
                writelog("Downloading remote exceptions log file")
                writett("Downloading remote exceptions log file")

                if (fsc.DownloadText(remoteExceptionsLog,exceptionRecords,errorMessage))
                begin
                    data ex_ch, int
                    data exceptionRecord, string

                    open(ex_ch=0,o:s,localExceptionsLog)

                    foreach exceptionRecord in exceptionRecords
                        writes(ex_ch,exceptionRecord)

                    close ex_ch

                    now = %datetime
                    writelog(%string(exceptionRecords.Length) + " items saved to " + localExceptionsLog)
                    writelog(" - " + %string(exceptionRecords.Length) + " items saved to " + localExceptionsLog)
                end
            end
            else
            begin
                ;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
                now = %datetime
                writelog("Remote exceptions file not found!")
                writett("Remote exceptions file not found!")
            end
        end
        else
        begin
            ;Failed to determine if file exists
            now = %datetime
            writelog("Failed to determine if remote exceptions log file exists. Error was " + tmpmsg)
        end
    end
    else
    begin
        ;Local bulk load

        if (File.Exists(localExceptionsFile)) then
        begin
            data ex_ch, int
            data tmprec, a65535
            open(ex_ch=0,i:s,localExceptionsFile)
            repeat
            begin
                reads(ex_ch,tmprec,eof)
                exceptionCount += 1
            end
eof,        close ex_ch
            now = %datetime
            writelog(%string(exceptionCount) + " exception items found in " + localExceptionsFile)
        end
        else
        begin
            ;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
            now = %datetime
            writelog("Exceptions data file not found!")
        end
    end

    return

endfunction

;*****************************************************************************
; <summary>
; Close cursors associated with the Employee table.
; </summary>

subroutine Employee$Close
    external common
        chEmployee, int
    endcommon
proc
    ;If the file is open, close it

    if (chEmployee)
    begin
        close chEmployee
        chEmployee = 0
    end

    xreturn

endsubroutine

;*****************************************************************************
; <summary>
; Exports REPLICATOR_DATA:EMPLOYEE.ISM to a CSV file.
; </summary>
; <param name="fileSpec">File to create</param>
; <param name="maxRecords">Mumber of records to export.</param>
; <param name="recordCount">Returned number of records exported.</param>
; <param name="errorMessage">Returned error text.</param>
; <returns>Returns true on success, otherwise false.</returns>

function Employee$Csv, boolean
    required in  fileSpec, a
    required in  maxRecords, n
    required out recordCount, n
    required out errorMessage, a

    .include "EMPLOYEE" repository, record="employee", end

    .define EXCEPTION_BUFSZ 100

    external function
        IsDecimalNo, boolean
        MakeDecimalForCsvNegatives, a
        MakeDecimalForCsvNoNegatives, a
        MakeTimeForCsv, a
    endexternal

    .align
    stack record local_data
        ok,         boolean ;Return status
        filechn,    int     ;Data file channel
        outchn,     int     ;CSV file channel
        outrec,     @StringBuilder  ;A CSV file record
        records,    int     ;Number of records exported
        pos,        int     ;Position in a string
        recordsMax, int     ;Max # or records to export
        errtxt,     a512    ;Error message text
        now,        a20     ;The time now
        timer,      @Timer  ;A timer
    endrecord

    external common
        chEmployee, int
    endcommon
proc
    ;Make sure the channel is open
    if (!chEmployee && !Open$Employee(errorMessage))
    begin
        freturn false
    end

    clear records, errtxt
    ok = true
    errorMessage = ""

    timer = new Timer()
    timer.Start()

    ;Were we given a max # or records to export?

    recordsMax = maxRecords > 0 ? maxRecords : 0

    ;Open the data file associated with the structure

    if (!(filechn=%EmployeeOpenInput(errtxt)))
    begin
        errtxt = "Failed to open data file! Error was " + errtxt
        ok = false
    end

    ;Create the local CSV file

    if (ok)
    begin
.ifdef OS_WINDOWS7
        open(outchn=0,o:s,fileSpec)
.endc
.ifdef OS_UNIX
        open(outchn=0,o,fileSpec)
.endc
.ifdef OS_VMS
        open(outchn=0,o,fileSpec,OPTIONS:"/stream")
.endc

        ;Add a row of column headers
.ifdef OS_WINDOWS7
        writes(outchn,"EmpId|EmpFirstName|EmpLastName|EmpDept|EmpHireDate|EmpPhoneWork|EmpPhoneCell|EmpPaid|EmpDateOfBirth|EmpHireTime|EmpEmail|EmpAddressStreet|EmpAddressCity|EmpAddressState|EmpAddressZip")
.else
        puts(outchn,"EmpId|EmpFirstName|EmpLastName|EmpDept|EmpHireDate|EmpPhoneWork|EmpPhoneCell|EmpPaid|EmpDateOfBirth|EmpHireTime|EmpEmail|EmpAddressStreet|EmpAddressCity|EmpAddressState|EmpAddressZip" + %char(13) + %char(10))
.endc

        ;Read and add data file records
        foreach employee in new Select(new From(filechn,Q_NO_GRFA,0,employee))
        begin
            ;Make sure there are no | characters in the data
            while (pos = %instr(1,employee,"|"))
            begin
                clear employee(pos:1)
            end

            incr records

            if (recordsmax && (records > recordsMax))
            begin
                decr records
                exitloop
            end

            outrec = new StringBuilder()
            outrec.Append(employee.emp_id ? %MakeDecimalForCsvNoNegatives(employee.emp_id) + "|" : "0|")
            outrec.Append(employee.emp_first_name ? %atrim(employee.emp_first_name) + "|" : "|")
            outrec.Append(employee.emp_last_name ? %atrim(employee.emp_last_name) + "|" : "|")
            outrec.Append(employee.emp_dept ? %atrim(employee.emp_dept) + "|" : "|")
            outrec.Append(employee.emp_hire_date ? %string(employee.emp_hire_date,"XXXX-XX-XX") + "|" : "|")
            outrec.Append(employee.emp_phone_work ? %atrim(employee.emp_phone_work) + "|" : "|")
            outrec.Append(employee.emp_phone_cell ? %atrim(employee.emp_phone_cell) + "|" : "|")
            outrec.Append(employee.emp_paid ? %MakeDecimalForCsvNoNegatives(employee.emp_paid) + "|" : "0|")
            outrec.Append(employee.emp_date_of_birth ? %string(employee.emp_date_of_birth,"XXXX-XX-XX") + "|" : "|")
            outrec.Append(employee.emp_hire_time ? %MakeTimeForCsv(employee.emp_hire_time) + "|" : "|")
            outrec.Append(employee.emp_email ? %atrim(employee.emp_email) + "|" : "|")
            outrec.Append(employee.emp_address_street ? %atrim(employee.emp_address_street) + "|" : "|")
            outrec.Append(employee.emp_address_city ? %atrim(employee.emp_address_city) + "|" : "|")
            outrec.Append(employee.emp_address_state ? %atrim(employee.emp_address_state) + "|" : "|")
            outrec.Append(employee.emp_address_zip ? %MakeDecimalForCsvNoNegatives(employee.emp_address_zip) : "")

            .ifdef OS_WINDOWS7
            writes(outchn,outrec.ToString())
            .else
            puts(outchn,outrec.ToString() + %char(13) + %char(10))
            .endc
        end
    end

eof,

    ;Close the file
    if (filechn && %chopen(filechn))
    begin
        close filechn
    end

    ;Close the CSV file
    if (outchn && %chopen(outchn))
    begin
        close outchn
    end

    ;Return the record count
    recordCount = records

    ;Return any error text
    errorMessage = errtxt

    timer.Stop()
    now = %datetime

    if (ok)
    begin
        writelog("Export took " + timer.ElapsedTimeString)
        writett("Export took " + timer.ElapsedTimeString)
    end

    freturn ok

endfunction

;*****************************************************************************
; <summary>
; Opens the REPLICATOR_DATA:EMPLOYEE.ISM for update.
; </summary>
; <param name="errorMessage">Returned error message.</param>
; <returns>Returns the channel number, or 0 if an error occured.</returns>

function Open$Employee, ^val
    required out errorMessage, a  ;Returned error text
    global common
        chEmployee, int
    endcommon
proc
    errorMessage = ""

    if (chEmployee) then
        freturn true
    else
    begin
        try
        begin
            open(chEmployee=0,u:i,"REPLICATOR_DATA:EMPLOYEE.ISM")
        end
        catch (ex, @Exception)
        begin
            errorMessage = ex.Message
            clear chEmployee
            freturn false
        end
        endtry
    end
    freturn true
endfunction

;*****************************************************************************
; <summary>
; Loads a unique key value into the respective fields in a record.
; </summary>
; <param name="aKeyValue">Unique key value.</param>
; <returns>Returns a record containig only the unique key segment data.</returns>

function Employee$KeyToRecord, a
    required in aKeyValue, a

    .include "EMPLOYEE" repository, stack record="employee", end

    stack record
        segPos, int
    endrecord

proc

    clear employee
    segPos = 1

    employee.emp_id = ^d(aKeyValue(segPos:8))
    segPos += 8

    freturn employee

endfunction

;*****************************************************************************
;The following functions are identical to and therefor use the code from the
;SQL Connection replication code in EmployeeSqlIO.dbl
;
;   %EmployeeKeyVal
;   %EmployeeKeyNum
;   %EmployeeLength
;   %EmployeeType
;   %EmployeeCols
;   %EmployeeRecs
