;*****************************************************************************
;
; File:        Employee_SqlIO.dbl
;
; Description: Various functions that performs SQL I/O for EMPLOYEE
;
;*****************************************************************************
; WARNING: THIS CODE WAS CODE GENERATED AND WILL BE OVERWRITTEN IF CODE
;          GENERATION IS RE-EXECUTED FOR THIS PROJECT.
;*****************************************************************************

.ifndef DBLNET
 ;This code was generated from the SqlClientIO template and can only be used
 ;in .NET. For traditional DBL environments use the SqlIO template
.else

import ReplicationLibrary
import Synergex.SynergyDE.Select
import System.Data.SqlClient
import System.IO

.ifndef strEmployee
.include "EMPLOYEE" repository, structure="strEmployee", end
.endc

.define writelog(x) if (Settings.LogFileChannel && %chopen(Settings.LogFileChannel)) writes(Settings.LogFileChannel,%string(^d(now(1:14)),"XXXX-XX-XX XX:XX:XX") + " " + x)
.define writett(x)  if (Settings.TerminalChannel) writes(Settings.TerminalChannel,"   - " + %string(^d(now(9:8)),"XX:XX:XX.XX") + " " + x)

;*****************************************************************************
;;; <summary>
;;; Determines if the Employee table exists in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns 1 if the table exists, otherwise a number indicating the type of error.</returns>

function Employee_Exists, ^val
    required out aErrorMessage, a

    stack record
        error, int
        errorMessage, string
    endrecord
proc
    error = 0
    errorMessage = String.Empty

    try
    begin
        disposable data command = new SqlCommand("SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='Employee'",Settings.DatabaseConnection) { 
        &   CommandTimeout = Settings.DatabaseTimeout
        & }
        disposable data reader = command.ExecuteReader()
        if (reader.Read()) then
        begin
            ;Table exists
            error = 1
        end
        else
        begin
            errorMessage = "Table not found"
            error = 0
        end
    end
    catch (ex, @SqlException)
    begin
        errorMessage = ex.Message
        error = -1
        xcall ThrowOnSqlClientError(errorMessage,ex)
    end
    endtry

    ;Return any error message to the calling routine
    aErrorMessage = error == 1 ? String.Empty : errorMessage

    freturn error

endfunction

;*****************************************************************************
;;; <summary>
;;; Creates the Employee table in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Create, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
    endrecord
    static record
        createTableCommand, string
    endrecord
proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Define the CREATE TABLE statement

    if (ok && createTableCommand == ^null)
    begin
        createTableCommand = 'CREATE TABLE "Employee" ('
        & + '"EmpId" DECIMAL(8) NOT NULL,'
        & + '"EmpFirstName" VARCHAR(20) NOT NULL,'
        & + '"EmpLastName" VARCHAR(20) NOT NULL,'
        & + '"EmpDept" VARCHAR(15) NOT NULL,'
        & + '"EmpHireDate" DATE,'
        & + '"EmpPhoneWork" VARCHAR(14),'
        & + '"EmpPhoneCell" VARCHAR(14),'
        & + '"EmpPaid" DECIMAL(1),'
        & + '"EmpDateOfBirth" DATE,'
        & + '"EmpHireTime" TIME(0),'
        & + '"EmpEmail" VARCHAR(40),'
        & + '"EmpAddressStreet" VARCHAR(30),'
        & + '"EmpAddressCity" VARCHAR(20),'
        & + '"EmpAddressState" VARCHAR(2),'
        & + '"EmpAddressZip" DECIMAL(5),'
        & + 'CONSTRAINT PK_Employee PRIMARY KEY CLUSTERED("EmpId" ASC)'
        & + ')'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            createTableCommand = createTableCommand + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            createTableCommand = createTableCommand + " WITH(DATA_COMPRESSION=ROW)"
        endusing
    end

    ;Create the database table and primary key constraint

    try
    begin
        disposable data command = new SqlCommand(createTableCommand,Settings.DatabaseConnection) { 
        &   CommandTimeout = Settings.DatabaseTimeout
        & }
        command.ExecuteNonQuery()
    end
    catch (ex, @SqlException)
    begin
        ok = false
        errorMessage = "Failed to create table. Error was: " + ex.Message
    end
    endtry 

    ;Grant access permissions

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('GRANT ALL ON "Employee" TO PUBLIC',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to grant table permissions. Error was: " + ex.Message
        end
        endtry
    end

    ;Commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Add alternate key indexes to the Employee table if they do not exist.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Index, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
        now, a20
    endrecord

proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Create index 1 (Department ID)

    if (ok && !%Index_Exists("IX_Employee_EmpDept"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_EmpDept ON "Employee"("EmpDept" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.BulkLoadTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_EmpDept. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_EmpDept")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;Create index 2 (Last name)

    if (ok && !%Index_Exists("IX_Employee_EmpLastName"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_EmpLastName ON "Employee"("EmpLastName" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.BulkLoadTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_EmpLastName. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_EmpLastName")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;Create index 3 (State)

    if (ok && !%Index_Exists("IX_Employee_StateCode"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_StateCode ON "Employee"("EmpAddressState" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.BulkLoadTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_StateCode. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_StateCode")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;Create index 4 (Zip code)

    if (ok && !%Index_Exists("IX_Employee_ZipCode"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_ZipCode ON "Employee"("EmpAddressZip" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.BulkLoadTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_ZipCode. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_ZipCode")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Removes alternate key indexes from the Employee table in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_UnIndex, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
    endrecord

proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Drop index 1 (Department ID)

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('DROP INDEX IF EXISTS IX_Employee_EmpDept ON "Employee"',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_EmpDept. Error was: " + ex.Message
        end
        endtry
    end

    ;Drop index 2 (Last name)

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('DROP INDEX IF EXISTS IX_Employee_EmpLastName ON "Employee"',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_EmpLastName. Error was: " + ex.Message
        end
        endtry
    end

    ;Drop index 3 (State)

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('DROP INDEX IF EXISTS IX_Employee_StateCode ON "Employee"',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_StateCode. Error was: " + ex.Message
        end
        endtry
    end

    ;Drop index 4 (Zip code)

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('DROP INDEX IF EXISTS IX_Employee_ZipCode ON "Employee"',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_ZipCode. Error was: " + ex.Message
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Insert a row into the Employee table.
;;; </summary>
;;; <param name="a_data">Record to be inserted.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns 1 if the row was inserted, 2 to indicate the row already exists, or 0 if an error occurred.</returns>

function Employee_Insert, ^val
    required in  a_data,   a
    required out aErrorMessage, a

    .align
    stack record local_data
        ok          ,boolean    ;OK to continue
        sts         ,int        ;Return status
        transaction ,boolean    ;Transaction in progress
        errorMessage,string     ;Error message text
    endrecord

    literal
        sql, string, "INSERT INTO Employee ("
        & + '"EmpId",'
        & + '"EmpFirstName",'
        & + '"EmpLastName",'
        & + '"EmpDept",'
        & + '"EmpHireDate",'
        & + '"EmpPhoneWork",'
        & + '"EmpPhoneCell",'
        & + '"EmpPaid",'
        & + '"EmpDateOfBirth",'
        & + '"EmpHireTime",'
        & + '"EmpEmail",'
        & + '"EmpAddressStreet",'
        & + '"EmpAddressCity",'
        & + '"EmpAddressState",'
        & + '"EmpAddressZip"'
        & + ") VALUES(@1,@2,@3,@4,@5,@6,@7,@8,@9,@10,@11,@12,@13,@14,@15)"
    endliteral

    static record
        employee, strEmployee
        tmpEmpHireTime, a5      ;Storage for HH:MM time field
    endrecord

proc
    init local_data
    ok = true
    sts = 1

    if (ok)
    begin
        ;Load the data into the bound record

        employee = a_data

        ;Clean up any alpha fields

        employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
        employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
        employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
        employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
        employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
        employee.emp_email = %atrim(employee.emp_email)+%char(0)
        employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
        employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
        employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

        ;Clean up any decimal fields

        if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
            clear employee.emp_id
        if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
            clear employee.emp_paid
        if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
            clear employee.emp_address_zip

        ;Clean up any date fields

        if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
            ^a(employee.emp_hire_date(1:1)) = %char(0)
        if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
            ^a(employee.emp_date_of_birth(1:1)) = %char(0)

        ;Clean up any time fields

        if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
            ^a(employee.emp_hire_time(1:1))=%char(0)

        ;Assign data to any temporary time or user-defined timestamp fields

        tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

        ;Assign values to temp fields for any fields with custom data types

    end

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }

            command.Parameters.AddWithValue("@1",employee.emp_id)
            command.Parameters.AddWithValue("@2",employee.emp_first_name)
            command.Parameters.AddWithValue("@3",employee.emp_last_name)
            command.Parameters.AddWithValue("@4",employee.emp_dept)
            command.Parameters.AddWithValue("@5",^a(employee.emp_hire_date))
            command.Parameters.AddWithValue("@6",employee.emp_phone_work)
            command.Parameters.AddWithValue("@7",employee.emp_phone_cell)
            command.Parameters.AddWithValue("@8",employee.emp_paid)
            command.Parameters.AddWithValue("@9",^a(employee.emp_date_of_birth))
            command.Parameters.AddWithValue("@10",tmpEmpHireTime)
            command.Parameters.AddWithValue("@11",employee.emp_email)
            command.Parameters.AddWithValue("@12",employee.emp_address_street)
            command.Parameters.AddWithValue("@13",employee.emp_address_city)
            command.Parameters.AddWithValue("@14",employee.emp_address_state)
            command.Parameters.AddWithValue("@15",employee.emp_address_zip)

            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            sts = 0
            using ex.Number Select
            (-2627),    ;TODO: * * * MAY NOT BE THE CORRECT ERROR NUMBER FOR DUPLICATE KEY
            begin
                ;Duplicate key
                errorMessage = "Duplicate key detected in database!"
                sts = 2
            end
            (),
            begin
                errorMessage = "Failed to insert row into Employee. Error was: " + ex.Message
            end
            endusing
            xcall ThrowOnSqlClientError(errorMessage,ex)
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn sts

endfunction

;*****************************************************************************
;;; <summary>
;;; Inserts multiple rows into the Employee table.
;;; </summary>
;;; <param name="a_data">Memory handle containing one or more rows to insert.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <param name="a_exception">Memory handle to load exception data records into.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_InsertRows, ^val
    required in  a_data, i
    required out aErrorMessage, a
    optional out a_exception, i

    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok,             boolean     ;Return status
        rows,           int         ;Number of rows to insert
        transaction,    boolean     ;Transaction in progress
        length,         int         ;Length of a string
        ex_ms,          int         ;Size of exception array
        ex_mc,          int         ;Items in exception array
        continue,       int         ;Continue after an error
        errorMessage,   string      ;Error message text
    endrecord

    literal
        sql, string, "INSERT INTO Employee ("
        & + '"EmpId",'
        & + '"EmpFirstName",'
        & + '"EmpLastName",'
        & + '"EmpDept",'
        & + '"EmpHireDate",'
        & + '"EmpPhoneWork",'
        & + '"EmpPhoneCell",'
        & + '"EmpPaid",'
        & + '"EmpDateOfBirth",'
        & + '"EmpHireTime",'
        & + '"EmpEmail",'
        & + '"EmpAddressStreet",'
        & + '"EmpAddressCity",'
        & + '"EmpAddressState",'
        & + '"EmpAddressZip"'
        & + ") VALUES(@1,@2,@3,@4,@5,@6,@7,@8,@9,@10,@11,@12,@13,@14,@15)"
    endliteral

    .include "EMPLOYEE" repository, structure="inpbuf", nofields, end
    .include "EMPLOYEE" repository, static record="employee", end

    static record
        tmpEmpHireTime, a5       ;Storage for HH:MM time field
        , a1                        ;In case there are no user timestamp, date or JJJJJJ date fields
    endrecord
proc
    init local_data
    ok = true
    errorMessage = String.Empty

    if (^passed(a_exception) && a_exception)
        clear a_exception

    ;Figure out how many rows to insert

    rows = (%mem_proc(DM_GETSIZE,a_data) / ^size(inpbuf))

    ;Start a database transaction

    if (ok)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Insert the rows into the database

    if (ok)
    begin
        data cnt, int
        for cnt from 1 thru rows
        begin
            ;Load data into bound record

            employee = ^m(inpbuf[cnt],a_data)

            ;Clean up any alpha variables

            employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
            employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
            employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
            employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
            employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
            employee.emp_email = %atrim(employee.emp_email)+%char(0)
            employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
            employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
            employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

            ;Clean up any decimal variables

            if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
                clear employee.emp_id
            if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
                clear employee.emp_paid
            if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
                clear employee.emp_address_zip

            ;Clean up any date variables

            if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
                ^a(employee.emp_hire_date(1:1))=%char(0)
            if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
                ^a(employee.emp_date_of_birth(1:1))=%char(0)

            ;Clean up any time variables

            if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
                ^a(employee.emp_hire_time(1:1))=%char(0)

            ;Assign any time or user-defined timestamp fields

            tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

            ;Assign values to temp fields for any fields with custom data types


            try
            begin
                disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
                &    CommandTimeout = Settings.DatabaseTimeout
                &    }

                ;Bind the host variables for data to be inserted

                command.Parameters.AddWithValue("@1",employee.emp_id)
                command.Parameters.AddWithValue("@2",employee.emp_first_name)
                command.Parameters.AddWithValue("@3",employee.emp_last_name)
                command.Parameters.AddWithValue("@4",employee.emp_dept)
                command.Parameters.AddWithValue("@5",^a(employee.emp_hire_date))
                command.Parameters.AddWithValue("@6",employee.emp_phone_work)
                command.Parameters.AddWithValue("@7",employee.emp_phone_cell)
                command.Parameters.AddWithValue("@8",employee.emp_paid)
                command.Parameters.AddWithValue("@9",^a(employee.emp_date_of_birth))
                command.Parameters.AddWithValue("@10",tmpEmpHireTime)
                command.Parameters.AddWithValue("@11",employee.emp_email)
                command.Parameters.AddWithValue("@12",employee.emp_address_street)
                command.Parameters.AddWithValue("@13",employee.emp_address_city)
                command.Parameters.AddWithValue("@14",employee.emp_address_state)
                command.Parameters.AddWithValue("@15",employee.emp_address_zip)

                command.ExecuteNonQuery()
                errorMessage = ""
            end
            catch (ex, @SqlException)
            begin
                errorMessage = "Failed to insert row. Error was: " + ex.Message
                xcall ThrowOnSqlClientError(errorMessage,ex)

                clear continue

                ;Are we logging errors?
                if (Settings.TerminalChannel)
                begin
                    writes(Settings.TerminalChannel,errorMessage)
                    continue=1
                end

                ;Are we processing exceptions?
                if (^passed(a_exception))
                begin
                    if (ex_mc==ex_ms)
                    begin
                        if (!a_exception) then
                            a_exception = %mem_proc(DM_ALLOC|DM_STATIC,^size(inpbuf)*(ex_ms=EXCEPTION_BUFSZ))
                        else
                            a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*(ex_ms+=EXCEPTION_BUFSZ),a_exception)
                    end
                    ^m(inpbuf[ex_mc+=1],a_exception)=employee
                    continue=1
                end

                if (continue) then
                    nextloop
                else
                begin
                    ok = false
                    exitloop
                end
            end
            endtry
        end
    end

    ;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            data rollbackError, string
            ok = %RollbackSqlClient(rollbackError)
        end
    end

    ;If we're returning exceptions then resize the buffer to the correct size

    if (^passed(a_exception) && a_exception)
        a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*ex_mc,a_exception)

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Updates a row in the Employee table.
;;; </summary>
;;; <param name="a_data">Record containing data to update.</param>
;;; <param name="a_rows">Returned number of rows affected.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Update, ^val
    required in  a_data,   a
    optional out a_rows,   i
    required out aErrorMessage, a

    stack record local_data
        ok,             boolean     ;OK to continue
        transaction,    boolean     ;Transaction in progress
        length,         int         ;Length of a string
        rows,           int         ;Number of rows updated
        errorMessage,   string      ;Error message text
    endrecord

    literal
        sql, string, 'UPDATE Employee SET '
        & + '"EmpId"=@1,'
        & + '"EmpFirstName"=@2,'
        & + '"EmpLastName"=@3,'
        & + '"EmpDept"=@4,'
        & + '"EmpHireDate"=@5,'
        & + '"EmpPhoneWork"=@6,'
        & + '"EmpPhoneCell"=@7,'
        & + '"EmpPaid"=@8,'
        & + '"EmpDateOfBirth"=@9,'
        & + '"EmpHireTime"=@10,'
        & + '"EmpEmail"=@11,'
        & + '"EmpAddressStreet"=@12,'
        & + '"EmpAddressCity"=@13,'
        & + '"EmpAddressState"=@14,'
        & + '"EmpAddressZip"=@15'
        & + ' WHERE "EmpId"=:16  '
    endliteral

    static record
        employee, strEmployee
        tmpEmpHireTime, a5      ;Storage for HH:MM time field
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    if (^passed(a_rows))
        clear a_rows

    ;Load the data into the bound record
    employee = a_data

    ;Clean up alpha fields
    employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
    employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
    employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
    employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
    employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
    employee.emp_email = %atrim(employee.emp_email)+%char(0)
    employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
    employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
    employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

    ;Clean up decimal fields
    if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
        clear employee.emp_id
    if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
        clear employee.emp_paid
    if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
        clear employee.emp_address_zip

    ;Clean up date fields
    if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
        ^a(employee.emp_hire_date(1:1)) = %char(0)
    if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
        ^a(employee.emp_date_of_birth(1:1)) = %char(0)

    ;Clean up time fields
    if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
        ^a(employee.emp_hire_time(1:1)) = %char(0)

    ;Assign time and user-defined timestamp fields
    tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

    ;Assign values to temp fields for any fields with custom data types

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand("ROLLBACK TRANSACTION",Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }

            ;Bind the host variables for data to be updated
            command.Parameters.AddWithValue("@1",employee.emp_id)
            command.Parameters.AddWithValue("@2",employee.emp_first_name)
            command.Parameters.AddWithValue("@3",employee.emp_last_name)
            command.Parameters.AddWithValue("@4",employee.emp_dept)
            command.Parameters.AddWithValue("@5",^a(employee.emp_hire_date))
            command.Parameters.AddWithValue("@6",employee.emp_phone_work)
            command.Parameters.AddWithValue("@7",employee.emp_phone_cell)
            command.Parameters.AddWithValue("@8",employee.emp_paid)
            command.Parameters.AddWithValue("@9",^a(employee.emp_date_of_birth))
            command.Parameters.AddWithValue("@10",tmpEmpHireTime)
            command.Parameters.AddWithValue("@11",employee.emp_email)
            command.Parameters.AddWithValue("@12",employee.emp_address_street)
            command.Parameters.AddWithValue("@13",employee.emp_address_city)
            command.Parameters.AddWithValue("@14",employee.emp_address_state)
            command.Parameters.AddWithValue("@15",employee.emp_address_zip)

            ;Bind the host variables for the key segments / WHERE clause
            command.Parameters.AddWithValue("@16",employee.emp_id)

            rows = command.ExecuteNonQuery()

            if (^passed(a_rows))
                a_rows = rows
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to update row. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes a row from the Employee table.
;;; </summary>
;;; <param name="a_key">Unique key of row to be deleted.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Delete, ^val
    required in  a_key,    a
    required out aErrorMessage, a

    .include "EMPLOYEE" repository, stack record="employee"

    external function
        EmployeeKeyToRecord, a
    endexternal

    .align
    stack record local_data
        ok,             boolean     ;Return status
        cursor,         int         ;Database cursor
        transaction,    boolean     ;Transaction in progress
        errorMessage,   string      ;Error message
        sql,            string      ;SQL statement
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    ;Put the unique key value into the record
    employee = %EmployeeKeyToRecord(a_key)

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;;Delete the row
    if (ok)
    begin
        sql = 'DELETE FROM "Employee" WHERE'
        &    + ' "EmpId"=' + "'" + %string(employee.emp_id) + "' "

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to delete row. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes all rows from the Employee table.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Clear, ^val
    required out aErrorMessage, a

    .align
    stack record local_data
        ok,             boolean ;Return status
        transaction,    boolean ;Transaction in process
        errorMessage,   string  ;Returned error message text
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;;Truncate the table
    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('TRUNCATE TABLE "Employee"',Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to truncate table. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes the Employee table from the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Drop, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
    endrecord

proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Drop the database table and primary key constraint
    try
    begin
        disposable data command = new SqlCommand("DROP TABLE Employee",Settings.DatabaseConnection) { 
        &   CommandTimeout = Settings.DatabaseTimeout
        & }
        command.ExecuteNonQuery()
    end
    catch (ex, @SqlException)
    begin
        using ex.Number select
        (3701), ;Cannot drop the table 'Employee', because it does not exist or you do not have permission.
            nop
        (),
        begin
            errorMessage = "Failed to drop table. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endusing
    end
    endtry 

    ;Commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Load all data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <param name="a_added">Total number of successful inserts.</param>
;;; <param name="a_failed">Total number of failed inserts.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Load, ^val
    required in  a_maxrows, n
    required out a_added, n
    required out a_failed, n
    required out aErrorMessage, a

    .include "EMPLOYEE" repository, structure="inpbuf", end
    .include "EMPLOYEE" repository, stack record="tmprec", end

    .define BUFFER_ROWS     1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok,             boolean     ;Return status
        firstRecord,    boolean     ;Is this the first record?
        filechn,        int         ;Data file channel
        mh,             D_HANDLE    ;Memory handle containing data to insert
        ms,             int         ;Size of memory buffer in rows
        mc,             int         ;Memory buffer rows currently used
        ex_mh,          D_HANDLE    ;Memory buffer for exception records
        ex_mc,          int         ;Number of records in returned exception array
        ex_ch,          int         ;Exception log file channel
        attempted,      int         ;Rows being attempted
        done_records,   int         ;Records loaded
        max_records,    int         ;Maximum records to load
        ttl_added,      int         ;Total rows added
        ttl_failed,     int         ;Total failed inserts
        errnum,         int         ;Error number
        tmperrmsg,      a512        ;Temporary error message
        errorMessage,   string      ;Error message text
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    ;If we are logging exceptions, delete any existing exceptions file.
    if (Settings.LogBulkLoadExceptions)
    begin
        xcall delet("REPLICATOR_LOGDIR:employee_data_exceptions.log")
    end

    ;Open the data file associated with the structure
    if (!(filechn = %EmployeeOpenInput(tmperrmsg)))
    begin
        errorMessage = "Failed to open data file! Error was " + %atrimtostring(tmperrmsg)
        ok = false
    end

    if (ok)
    begin
        ;Were we passed a max # records to load
        max_records = a_maxrows > 0 ? a_maxrows : 0
        done_records = 0

        ;Allocate memory buffer for the database rows
        mh = %mem_proc(DM_ALLOC,^size(inpbuf)*(ms=BUFFER_ROWS))

        ;Read records from the input file
        firstRecord = true
        repeat
        begin
            ;Get the next record from the input file
            try
            begin
                if (firstRecord) then
                begin
                    read(filechn,tmprec,^FIRST)
                    firstRecord = false
                end
                else
                begin
                    reads(filechn,tmprec)
                end
            end
            catch (ex, @EndOfFileException)
            begin
                exitloop
            end
            catch (ex, @Exception)
            begin
                ok = false
                errorMessage = "Unexpected error while reading data file: " + ex.Message
                exitloop
            end
            endtry

            ;Got one, load it into or buffer
            ^m(inpbuf[mc+=1],mh) = tmprec

            incr done_records

            ;If the buffer is full, write it to the database
            if (mc==ms)
            begin
                call insert_data
            end

            if (max_records && (done_records == max_records))
            begin
                exitloop
            end
        end

        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(inpbuf)*mc,mh)
            call insert_data
        end

        ;;Deallocate memory buffer
        mh = %mem_proc(DM_FREE,mh)
    end

    ;Close the file
    if (filechn && %chopen(filechn))
        close filechn

    ;Close the exceptions log file
    if (ex_ch && %chopen(ex_ch))
        close ex_ch

    ;Return totals
    a_added = ttl_added
    a_failed = ttl_failed

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

insert_data,

    attempted = (%mem_proc(DM_GETSIZE,mh)/^size(inpbuf))

    if (!%Employee_InsertRows(mh,tmperrmsg,ex_mh)) then
    begin
        errorMessage = %atrimtostring(tmperrmsg)
    end
    else
    begin
        ;;Any exceptions?
        if (ex_mh) then
        begin
            ;How many exceptions to log?
            ex_mc = %mem_proc(DM_GETSIZE,ex_mh) / ^size(inpbuf)

            ;Update totals
            ttl_failed += ex_mc
            ttl_added += (attempted-ex_mc)

            ;Are we logging exceptions?
            if (Settings.LogBulkLoadExceptions) then
            begin
                data cnt, int

                ;Open the log file
                if (!ex_ch)
                begin
                    open(ex_ch=0,o:s,"REPLICATOR_LOGDIR:employee_data_exceptions.log")
                end

                ;Log the exceptions
                for cnt from 1 thru ex_mc
                begin
                    writes(ex_ch,^m(inpbuf[cnt],ex_mh))
                end

                ;And maybe show them on the terminal
                if (Settings.TerminalChannel)
                begin
                    writes(Settings.TerminalChannel,"Exceptions were logged to REPLICATOR_LOGDIR:employee_data_exceptions.log")
                end
            end
            else
            begin
                ;No, report and error
                ok = false
            end

            ;Release the exception buffer
            ex_mh = %mem_proc(DM_FREE,ex_mh)
        end
        else
        begin
            ;No exceptions
            ttl_added += attempted
            if (Settings.TerminalChannel && Settings.LogLoadProgress)
            begin
                writes(Settings.TerminalChannel," - " + %string(ttl_added) + " rows inserted")
            end
        end
    end

    clear mc

    return

endfunction

;*****************************************************************************
;;; <summary>
;;; Bulk load data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table via a CSV file.
;;; </summary>
;;; <param name="recordsToLoad">The number of records to load, or 0 for all records.</param>
;;; <param name="a_records">Total number of records processed</param>
;;; <param name="a_exceptions">Total number of exception records detected</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_BulkLoad, ^val
    required in recordsToLoad,  n
    required out a_records,     n
    required out a_exceptions,  n
    required out aErrorMessage, a

     stack record local_data
        ok,                     boolean    ;;Return status
        transaction,            boolean
        remoteBulkLoad,         boolean
        localCsvFile,           string
        localExceptionsFile,    string
        localExceptionsLog,     string
        remoteCsvFile,          string
        remoteExceptionsFile,   string
        remoteExceptionsLog,    string
        copyTarget,             string
        fileToLoad,             string
        cursor,                 int
        length,                 int
        dberror,                int
        recordCount,            int	        ;# records loaded
        exceptionCount,         int         ;# records failed
        errtxt,                 a512        ;Temp error message
        errorMessage,           string      ;Error message
        fsc,                    @FileServiceClient
        now,                    a20
    endrecord

proc
    init local_data
    ok = true

    ;If we're doing a remote bulk load, create an instance of the FileService client and verify that we can access the FileService server

    if (remoteBulkLoad = Settings.CanBulkLoad())
    begin
        fsc = new FileServiceClient(Settings.FileServiceHost,Settings.FileServicePort)

        now = %datetime
        writelog("Verifying FileService connection")
        writett("Verifying FileService connection")

        if (!fsc.Ping(errtxt))
        begin
            errorMessage = "No response from FileService, bulk load cancelled"
            now = %datetime
            writelog(errorMessage)
            writett(errorMessage)
            ok = false
        end
    end

    ;Define temp file names and make sure there are no local temp files left over from a previous operation

    if (ok)
    begin
        .ifdef OS_VMS
        localCsvFile = String.Format("{0}Employee.csv",Settings.LocalExportPath)
        .else
        localCsvFile = Path.Combine(Settings.LocalExportPath,"Employee.csv")
        .endc
        localExceptionsFile = String.Format("{0}_err",localCsvFile)
        localExceptionsLog = String.Format("{0}.Error.Txt",localExceptionsFile)

        if (remoteBulkLoad)
        begin
            remoteCsvFile = "Employee.csv"
            remoteExceptionsFile = String.Format("{0}_err",remoteCsvFile)
            remoteExceptionsLog = String.Format("{0}.Error.Txt",remoteExceptionsFile)
        end

        now = %datetime
        writelog("Deleting local temp files")
        writett("Deleting local temp files")

        if (File.Exists(localCsvFile))
        begin
            try
            begin
                File.Delete(localCsvFile)
            end
            catch (ex)
            begin
                nop
            end
            endtry
        end

        if (File.Exists(localExceptionsFile))
        begin
            try
            begin
                File.Delete(localExceptionsFile)
            end
            catch (ex)
            begin
                nop
            end
            endtry
        end

        if (File.Exists(localExceptionsLog))
        begin
            try
            begin
                File.Delete(localExceptionsLog)
            end
            catch (ex)
            begin
                nop
            end
            endtry
        end

        ;Delete remote files

        if (remoteBulkLoad)
        begin
            now = %datetime
            writelog("Deleting remote temp files")
            writett("Deleting remote temp files")

            fsc.Delete(remoteCsvFile)
            fsc.Delete(remoteExceptionsFile)
            fsc.Delete(remoteExceptionsLog)
        end

        ;Were we asked to load a specific number of records?

        recordCount =  recordCount > 0 ? recordCount : 0

        ;And export the data

        now = %datetime
        writelog("Exporting data to delimited file")
        writett("Exporting data to delimited file")

        ok = %EmployeeCsv(localCsvFile,0,recordCount,errtxt)

        errorMessage = ok ? String.Empty : %atrimtostring(errtxt)
    end

    ;If necessary, upload the exported file to the database server

    if (ok)
    begin
        if (remoteBulkLoad) then
        begin
            now = %datetime
            writelog("Uploading delimited file to database server")
            writett("Uploading delimited file to database server")
            ok = fsc.UploadChunked(localCsvFile,remoteCsvFile,320,fileToLoad,errtxt)
            errorMessage = ok ? String.Empty : %atrimtostring(errtxt)
        end
        else
        begin
            fileToLoad  = localCsvFile
        end
    end

    ;If we're in manual commit mode, start a transaction

    if (ok && Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Execute the BULK INSERT statement

    if (ok)
    begin
        data sql = String.Format("BULK INSERT Employee FROM '{0}' WITH (FIRSTROW=2,FIELDTERMINATOR='|',ROWTERMINATOR='\n',MAXERRORS=100000000,ERRORFILE='{0}_err'",fileToLoad)

        if (Settings.BulkLoadBatchSize > 0)
        begin
            sql = String.Format("{0},BATCHSIZE={1}",sql,Settings.BulkLoadBatchSize)
        end

        sql = String.Format("{0})",sql)

        now = %datetime
        writelog("Executing BULK INSERT")
        writett("Executing BULK INSERT")

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.BulkLoadTimeout
            &    }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "BULK INSERT failed. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)

            now = %datetime
            writelog("Bulk insert failed. " + ex.Message)
            writett("Bulk insert failed. " + ex.Message)

            using ex.Number select
            (-4864),
            begin
                ;Bulk load data conversion error
                now = %datetime
                writelog("Data conversion errors were reported")
                writett("Data conversion errors were reported")
                errorMessage = String.Empty

                ;------------------------------------------------------------------------------------------------------------
                ;This used to be an internal subroutine GetExceptionDetails but in .NET we can't call it from here! Sucks!

                ;If we get here the bulk load reported one or more "data conversion error" issues and there should be two log files on the server

                now = %datetime
                writelog("Data conversion errors, processing exceptions")
                writett("Data conversion errors, processing exceptions")

                if (remoteBulkLoad) then
                begin
                    data fileExists, boolean
                    data tmpmsg, string

                    if (fsc.Exists(remoteExceptionsFile,fileExists,tmpmsg)) then
                    begin
                        if (fileExists) then
                        begin
                            ;Download the error file
                            data exceptionRecords, [#]string
                            data errorMessage, string

                            now = %datetime
                            writelog("Downloading remote exceptions data file")
                            writett("Downloading remote exceptions data file")

                            if (fsc.DownloadText(remoteExceptionsFile,exceptionRecords,errorMessage))
                            begin
                                data ex_ch, int
                                data exceptionRecord, string

                                open(ex_ch=0,o:s,localExceptionsFile)

                                foreach exceptionRecord in exceptionRecords
                                    writes(ex_ch,exceptionRecord)

                                close ex_ch

                                exceptionCount = exceptionRecords.Length

                                now = %datetime
                                writelog(%string(exceptionCount) + " items saved to " + localExceptionsFile)
                                writett(%string(exceptionCount) + " items saved to " + localExceptionsFile)
                            end
                        end
                        else
                        begin
                            ;Error file does not exist. This should not happen because we got here due to data conversion errors being reported
                            now = %datetime
                            writelog("Remote exceptions data file not found!")
                            writett("Remote exceptions data file not found!")
                        end
                    end
                    else
                    begin
                        ;Failed to determine if file exists
                        now = %datetime
                        writelog("Failed to determine if remote exceptions data file exists. Error was " + tmpmsg)
                        writett("Failed to determine if remote exceptions data file exists. Error was " + tmpmsg)
                    end

                    ;Now check for and retrieve the associated exceptions log

                    if (fsc.Exists(remoteExceptionsLog,fileExists,tmpmsg)) then
                    begin
                        if (fileExists) then
                        begin
                            ;Download the error file
                            data exceptionRecords, [#]string
                            data errorMessage, string

                            now = %datetime
                            writelog("Downloading remote exceptions log file")
                            writett("Downloading remote exceptions log file")

                            if (fsc.DownloadText(remoteExceptionsLog,exceptionRecords,errorMessage))
                            begin
                                data ex_ch, int
                                data exceptionRecord, string

                                open(ex_ch=0,o:s,localExceptionsLog)

                                foreach exceptionRecord in exceptionRecords
                                    writes(ex_ch,exceptionRecord)

                                close ex_ch

                                now = %datetime
                                writelog(%string(exceptionRecords.Length) + " items saved to " + localExceptionsLog)
                                writelog(" - " + %string(exceptionRecords.Length) + " items saved to " + localExceptionsLog)
                            end
                        end
                        else
                        begin
                            ;Error file does not exist. This should not happen because we got here due to data conversion errors being reported
                            now = %datetime
                            writelog("Remote exceptions file not found!")
                            writett("Remote exceptions file not found!")
                        end
                    end
                    else
                    begin
                        ;Failed to determine if file exists
                        now = %datetime
                        writelog("Failed to determine if remote exceptions log file exists. Error was " + tmpmsg)
                    end
                end
                else
                begin
                    ;Local bulk load

                    if (File.Exists(localExceptionsFile)) then
                    begin
                        data ex_ch, int
                        data tmprec, a65535
                        open(ex_ch=0,i:s,localExceptionsFile)
                        repeat
                        begin
                            reads(ex_ch,tmprec,eof)
                            exceptionCount += 1
                        end
            eof,        close ex_ch
                        now = %datetime
                        writelog(%string(exceptionCount) + " exception items found in " + localExceptionsFile)
                    end
                    else
                    begin
                        ;Error file does not exist. This should not happen because we got here due to data conversion errors being reported
                        now = %datetime
                        writelog("Exceptions data file not found!")
                    end
                end

                ;------------------------------------------------------------------------------------------------------------
            end
            (),
            begin
                errorMessage = String.Format("{0} {1}",ex.Number,errorMessage)
                ok = false
            end
            endusing
        end
        endtry
    end

    ;Delete local temp files

    now = %datetime
    writelog("Deleting local temp files")
    writett("Deleting local temp files")

    if (File.Exists(localCsvFile))
    begin
        try
        begin
            File.Delete(localCsvFile)
        end
        catch (ex)
        begin
            nop
        end
        endtry
    end

    if (File.Exists(localExceptionsFile))
    begin
        try
        begin
            File.Delete(localExceptionsFile)
        end
        catch (ex)
        begin
            nop
        end
        endtry
    end

    if (File.Exists(localExceptionsLog))
    begin
        try
        begin
            File.Delete(localExceptionsLog)
        end
        catch (ex)
        begin
            nop
        end
        endtry
    end

    ;Delete remote temp files

    if (remoteBulkLoad)
    begin
        now = %datetime
        writelog("Deleting remote temp files")
        writett("Deleting remote temp files")

        fsc.Delete(remoteCsvFile)
        fsc.Delete(remoteExceptionsFile)
        fsc.Delete(remoteExceptionsLog)
    end

    ;If we're in manual commit mode, commit or rollback the transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            now = %datetime
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            data rollbackOk, boolean, false
            data rollbackErrorMessage, string
            now = %datetime
            rollbackOk = %RollbackSqlClient(rollbackErrorMessage)
            if (!rollbackOk)
            begin
                errorMessage = String.Format("{0}. Also: {1}",errorMessage,rollbackErrorMessage)
            end
        end
    end

    ;Return the record and exceptions count

    now = %datetime
    if (ok) then
    begin
        a_records = recordCount
        a_exceptions = exceptionCount
        writelog("BULK LOAD COMPLETE")
    end
    else
    begin
        aErrorMessage = errorMessage
        writelog("BULK LOAD FAILED!")
    end

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Exports REPLICATOR_DATA:EMPLOYEE.ISM to a CSV file.
;;; </summary>
;;; <param name="fileSpec">File to create</param>
;;; <param name="maxRecords">Mumber of records to export.</param>
;;; <param name="recordCount">Returned number of records exported.</param>
;;; <param name="errorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Csv, boolean
    required in  fileSpec, a
    required in  maxRecords, n
    required out recordCount, n
    required out errorMessage, a

    .include "EMPLOYEE" repository, record="employee", end

    .define EXCEPTION_BUFSZ 100

    external function
        IsDecimalNo, boolean
        MakeDecimalForCsvNegatives, a
        MakeDecimalForCsvNoNegatives, a
        MakeTimeForCsv, a
    endexternal

    .align
    stack record local_data
        ok,         boolean ;Return status
        filechn,    int     ;Data file channel
        outchn,     int     ;CSV file channel
        outrec,     string  ;A CSV file record
        records,    int     ;Number of records exported
        errtxt,     a512    ;Error message text
    endrecord

proc
    ok = true
    init local_data

    ;;Open the data file associated with the structure

    if (!(filechn=%EmployeeOpenInput(errtxt)))
    begin
        errtxt = "Failed to open data file! Error was: " + errtxt
        ok = false
    end

    ;;Create the local CSV file

    if (ok)
    begin
.ifdef OS_WINDOWS7
        open(outchn=0,o:s,fileSpec)
.endc
.ifdef OS_UNIX
        open(outchn=0,o,fileSpec)
.endc
.ifdef OS_VMS
        open(outchn=0,o,fileSpec,OPTIONS:"/stream")
.endc

        ;;Add a row of column headers
.ifdef OS_WINDOWS7
        writes(outchn,"EmpId|EmpFirstName|EmpLastName|EmpDept|EmpHireDate|EmpPhoneWork|EmpPhoneCell|EmpPaid|EmpDateOfBirth|EmpHireTime|EmpEmail|EmpAddressStreet|EmpAddressCity|EmpAddressState|EmpAddressZip")
.else
        puts(outchn,"EmpId|EmpFirstName|EmpLastName|EmpDept|EmpHireDate|EmpPhoneWork|EmpPhoneCell|EmpPaid|EmpDateOfBirth|EmpHireTime|EmpEmail|EmpAddressStreet|EmpAddressCity|EmpAddressState|EmpAddressZip" + %char(13) + %char(10))
.endc

        ;;Read and add data file records
        foreach employee in new Select(new From(filechn,Q_NO_GRFA,0,employee))
        begin
            ;;Make sure there are no | characters in the data
            data pos, int
            while (pos = %instr(1,employee,"|"))
            begin
                clear employee(pos:1)
            end

            incr records

            if (maxRecords && (records > maxRecords))
            begin
                decr records
                exitloop
            end

            outrec = ""
            & + (employee.emp_id ? %MakeDecimalForCsvNoNegatives(employee.emp_id) + "|" : "0|")
            & + (employee.emp_first_name ? %atrim(employee.emp_first_name) + "|" : "|")
            & + (employee.emp_last_name ? %atrim(employee.emp_last_name) + "|" : "|")
            & + (employee.emp_dept ? %atrim(employee.emp_dept) + "|" : "|")
            & + (employee.emp_hire_date ? %string(employee.emp_hire_date,"XXXX-XX-XX") + "|" : "|")
            & + (employee.emp_phone_work ? %atrim(employee.emp_phone_work) + "|" : "|")
            & + (employee.emp_phone_cell ? %atrim(employee.emp_phone_cell) + "|" : "|")
            & + (employee.emp_paid ? %MakeDecimalForCsvNoNegatives(employee.emp_paid) + "|" : "0|")
            & + (employee.emp_date_of_birth ? %string(employee.emp_date_of_birth,"XXXX-XX-XX") + "|" : "|")
            & + (employee.emp_hire_time ? %MakeTimeForCsv(employee.emp_hire_time) + "|" : "|")
            & + (employee.emp_email ? %atrim(employee.emp_email) + "|" : "|")
            & + (employee.emp_address_street ? %atrim(employee.emp_address_street) + "|" : "|")
            & + (employee.emp_address_city ? %atrim(employee.emp_address_city) + "|" : "|")
            & + (employee.emp_address_state ? %atrim(employee.emp_address_state) + "|" : "|")
            & + (employee.emp_address_zip ? %MakeDecimalForCsvNoNegatives(employee.emp_address_zip) : "")

            .ifdef OS_WINDOWS7
            writes(outchn,outrec)
            .else
            puts(outchn,outrec + %char(13) + %char(10))
            .endc
        end
    end

eof,

    ;Close the file
    if (filechn && %chopen(filechn))
    begin
        close filechn
    end

    ;Close the CSV file
    if (outchn && %chopen(outchn))
    begin
        close outchn
    end

    ;Return the record count
    recordCount = records

    ;Return any error message to the calling routine
    errorMessage = %atrim(errtxt)

    freturn ok

endfunction

.endc
