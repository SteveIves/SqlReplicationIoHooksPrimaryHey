;*****************************************************************************
;
; File:        Employee_SqlIO.dbl
;
; Description: Various functions that performs SQL I/O for EMPLOYEE
;
;*****************************************************************************
; WARNING: THIS CODE WAS CODE GENERATED AND WILL BE OVERWRITTEN IF CODE
;          GENERATION IS RE-EXECUTED FOR THIS PROJECT.
;*****************************************************************************

.ifndef DBLNET
 ;This code was generated from the SqlClientIO template and can only be used
 ;in .NET. For traditional DBL environments use the SqlIO template
.else

import ReplicationLibrary
import Synergex.SynergyDE.Select
import System.Data.SqlClient
import System.IO
import System.Text

.ifndef strEmployee
.include "EMPLOYEE" repository, structure="strEmployee", end
.endc

.define writelog(x) if (Settings.LogFileChannel && %chopen(Settings.LogFileChannel)) writes(Settings.LogFileChannel,%string(^d(now(1:14)),"XXXX-XX-XX XX:XX:XX") + " " + x)
.define writett(x)  if (Settings.TerminalChannel) writes(Settings.TerminalChannel,"   - " + %string(^d(now(9:8)),"XX:XX:XX.XX") + " " + x)

;*****************************************************************************
;;; <summary>
;;; Determines if the Employee table exists in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns 1 if the table exists, otherwise a number indicating the type of error.</returns>

function Employee_Exists, ^val
    required out aErrorMessage, a

    stack record
        error, int
        errorMessage, string
    endrecord
proc
    error = 0
    errorMessage = String.Empty

    try
    begin
        data sql = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='Employee'"
        disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
        if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
        begin
            command.Transaction = Settings.CurrentTransaction
        end
        disposable data reader = command.ExecuteReader()
        if (reader.Read()) then
        begin
            ;Table exists
            error = 1
        end
        else
        begin
            errorMessage = "Table not found"
            error = 0
        end
    end
    catch (ex, @SqlException)
    begin
        errorMessage = ex.Message
        error = -1
        xcall ThrowOnSqlClientError(errorMessage,ex)
    end
    endtry

    ;Return any error message to the calling routine
    aErrorMessage = error == 1 ? String.Empty : errorMessage

    freturn error

endfunction

;*****************************************************************************
;;; <summary>
;;; Creates the Employee table in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Create, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        errorMessage, string
    endrecord
    static record
        createTableCommand, string
    endrecord
proc
    ok = true
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        Settings.CurrentTransaction = Settings.DatabaseConnection.BeginTransaction()
    end

    ;Define the CREATE TABLE statement

    if (ok && createTableCommand == ^null)
    begin
        createTableCommand = 'CREATE TABLE "Employee" ('
        & + '"EmpId" DECIMAL(8) NOT NULL,'
        & + '"EmpFirstName" VARCHAR(20) NOT NULL,'
        & + '"EmpLastName" VARCHAR(20) NOT NULL,'
        & + '"EmpDept" VARCHAR(15) NOT NULL,'
        & + '"EmpHireDate" DATE,'
        & + '"EmpPhoneWork" VARCHAR(14),'
        & + '"EmpPhoneCell" VARCHAR(14),'
        & + '"EmpPaid" DECIMAL(1),'
        & + '"EmpDateOfBirth" DATE,'
        & + '"EmpHireTime" TIME(0),'
        & + '"EmpEmail" VARCHAR(40),'
        & + '"EmpAddressStreet" VARCHAR(30),'
        & + '"EmpAddressCity" VARCHAR(20),'
        & + '"EmpAddressState" VARCHAR(2),'
        & + '"EmpAddressZip" DECIMAL(5),'
        & + 'CONSTRAINT PK_Employee PRIMARY KEY CLUSTERED("EmpId" ASC)'
        & + ')'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            createTableCommand = createTableCommand + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            createTableCommand = createTableCommand + " WITH(DATA_COMPRESSION=ROW)"
        endusing
    end

    ;Create the database table and primary key constraint

    try
    begin
        disposable data command = new SqlCommand(createTableCommand,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
        if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
        begin
            command.Transaction = Settings.CurrentTransaction
        end
        command.ExecuteNonQuery()
    end
    catch (ex, @SqlException)
    begin
        ok = false
        errorMessage = "Failed to create table. Error was: " + ex.Message
    end
    endtry 

    ;Grant access permissions

    if (ok)
    begin
        try
        begin
            data sql = 'GRANT ALL ON "Employee" TO PUBLIC'
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to grant table permissions. Error was: " + ex.Message
        end
        endtry
    end

    ;Commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            Settings.CurrentTransaction.Commit()
        end
        else
        begin
            ;There was an error, rollback the transaction
            Settings.CurrentTransaction.Rollback()
        end
        Settings.CurrentTransaction.Dispose()
        Settings.CurrentTransaction = ^null
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Add alternate key indexes to the Employee table if they do not exist.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Index, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        errorMessage, string
        now, a20
    endrecord

proc
    ok = true
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        Settings.CurrentTransaction = Settings.DatabaseConnection.BeginTransaction()
    end

    ;Create index 1 (Department ID)

    if (ok && !%Index_Exists("IX_Employee_EmpDept"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_EmpDept ON "Employee"("EmpDept" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.BulkLoadTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_EmpDept. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_EmpDept")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;Create index 2 (Last name)

    if (ok && !%Index_Exists("IX_Employee_EmpLastName"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_EmpLastName ON "Employee"("EmpLastName" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.BulkLoadTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_EmpLastName. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_EmpLastName")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;Create index 3 (State)

    if (ok && !%Index_Exists("IX_Employee_StateCode"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_StateCode ON "Employee"("EmpAddressState" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.BulkLoadTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_StateCode. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_StateCode")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;Create index 4 (Zip code)

    if (ok && !%Index_Exists("IX_Employee_ZipCode"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_ZipCode ON "Employee"("EmpAddressZip" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.BulkLoadTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_ZipCode. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_ZipCode")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            Settings.CurrentTransaction.Commit()
        end
        else
        begin
            ;There was an error, rollback the transaction
            Settings.CurrentTransaction.Rollback()
        end
        Settings.CurrentTransaction.Dispose()
        Settings.CurrentTransaction = ^null
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Removes alternate key indexes from the Employee table in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_UnIndex, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        errorMessage, string
    endrecord

proc
    ok = true
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        Settings.CurrentTransaction = Settings.DatabaseConnection.BeginTransaction()
    end

    ;Drop index 1 (Department ID)

    if (ok)
    begin
        try
        begin
            data sql = 'DROP INDEX IF EXISTS IX_Employee_EmpDept ON "Employee"'
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_EmpDept. Error was: " + ex.Message
        end
        endtry
    end

    ;Drop index 2 (Last name)

    if (ok)
    begin
        try
        begin
            data sql = 'DROP INDEX IF EXISTS IX_Employee_EmpLastName ON "Employee"'
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_EmpLastName. Error was: " + ex.Message
        end
        endtry
    end

    ;Drop index 3 (State)

    if (ok)
    begin
        try
        begin
            data sql = 'DROP INDEX IF EXISTS IX_Employee_StateCode ON "Employee"'
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_StateCode. Error was: " + ex.Message
        end
        endtry
    end

    ;Drop index 4 (Zip code)

    if (ok)
    begin
        try
        begin
            data sql = 'DROP INDEX IF EXISTS IX_Employee_ZipCode ON "Employee"'
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_ZipCode. Error was: " + ex.Message
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            Settings.CurrentTransaction.Commit()
        end
        else
        begin
            ;There was an error, rollback the transaction
            Settings.CurrentTransaction.Rollback()
        end
        Settings.CurrentTransaction.Dispose()
        Settings.CurrentTransaction = ^null
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Insert a row into the Employee table.
;;; </summary>
;;; <param name="a_data">Record to be inserted.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns 1 if the row was inserted, 2 to indicate the row already exists, or 0 if an error occurred.</returns>

function Employee_Insert, ^val
    required in  a_data,   a
    required out aErrorMessage, a

    .align
    stack record local_data
        ok          ,boolean    ;OK to continue
        sts         ,int        ;Return status
        errorMessage,string     ;Error message text
    endrecord

    literal
        sql, string, "INSERT INTO Employee ("
        & + '"EmpId",'
        & + '"EmpFirstName",'
        & + '"EmpLastName",'
        & + '"EmpDept",'
        & + '"EmpHireDate",'
        & + '"EmpPhoneWork",'
        & + '"EmpPhoneCell",'
        & + '"EmpPaid",'
        & + '"EmpDateOfBirth",'
        & + '"EmpHireTime",'
        & + '"EmpEmail",'
        & + '"EmpAddressStreet",'
        & + '"EmpAddressCity",'
        & + '"EmpAddressState",'
        & + '"EmpAddressZip"'
        & + ") VALUES(@EmpId,@EmpFirstName,@EmpLastName,@EmpDept,@EmpHireDate,@EmpPhoneWork,@EmpPhoneCell,@EmpPaid,@EmpDateOfBirth,@EmpHireTime,@EmpEmail,@EmpAddressStreet,@EmpAddressCity,@EmpAddressState,@EmpAddressZip)"
    endliteral

    static record
        employee, strEmployee
        tmpEmpHireTime, a5      ;Storage for HH:MM time field
    endrecord

proc
    init local_data
    ok = true
    sts = 1

    if (ok)
    begin
        ;Load the data into the bound record

        employee = a_data

        ;Clean up any alpha fields

        employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
        employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
        employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
        employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
        employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
        employee.emp_email = %atrim(employee.emp_email)+%char(0)
        employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
        employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
        employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

        ;Clean up any decimal fields

        if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
            clear employee.emp_id
        if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
            clear employee.emp_paid
        if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
            clear employee.emp_address_zip

        ;Clean up any date fields

        if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
            ^a(employee.emp_hire_date(1:1)) = %char(0)
        if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
            ^a(employee.emp_date_of_birth(1:1)) = %char(0)

        ;Clean up any time fields

        if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
            ^a(employee.emp_hire_time(1:1))=%char(0)

        ;Assign data to any temporary time or user-defined timestamp fields

        tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

        ;Assign values to temp fields for any fields with custom data types

    end

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        Settings.CurrentTransaction = Settings.DatabaseConnection.BeginTransaction()
    end

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end

            command.Parameters.AddWithValue("@EmpId",DblToNetConverter.SmallDecimalToInt(employee.emp_id))
            command.Parameters.AddWithValue("@EmpFirstName",DblToNetConverter.AlphaToString(employee.emp_first_name))
            command.Parameters.AddWithValue("@EmpLastName",DblToNetConverter.AlphaToString(employee.emp_last_name))
            command.Parameters.AddWithValue("@EmpDept",DblToNetConverter.AlphaToString(employee.emp_dept))
            command.Parameters.AddWithValue("@EmpHireDate",DblToNetConverter.DateToNullableDateTime(employee.emp_hire_date))
            command.Parameters.AddWithValue("@EmpPhoneWork",DblToNetConverter.AlphaToString(employee.emp_phone_work))
            command.Parameters.AddWithValue("@EmpPhoneCell",DblToNetConverter.AlphaToString(employee.emp_phone_cell))
            command.Parameters.AddWithValue("@EmpPaid",DblToNetConverter.SmallDecimalToInt(employee.emp_paid))
            command.Parameters.AddWithValue("@EmpDateOfBirth",DblToNetConverter.DateToNullableDateTime(employee.emp_date_of_birth))
            command.Parameters.AddWithValue("@EmpHireTime",DblToNetConverter.HHMMToTimeSpan(employee.emp_hire_time))
            command.Parameters.AddWithValue("@EmpEmail",DblToNetConverter.AlphaToString(employee.emp_email))
            command.Parameters.AddWithValue("@EmpAddressStreet",DblToNetConverter.AlphaToString(employee.emp_address_street))
            command.Parameters.AddWithValue("@EmpAddressCity",DblToNetConverter.AlphaToString(employee.emp_address_city))
            command.Parameters.AddWithValue("@EmpAddressState",DblToNetConverter.AlphaToString(employee.emp_address_state))
            command.Parameters.AddWithValue("@EmpAddressZip",DblToNetConverter.SmallDecimalToInt(employee.emp_address_zip))

            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            sts = 0
            using ex.Number Select
            (-2627),    ;TODO: * * * MAY NOT BE THE CORRECT ERROR NUMBER FOR DUPLICATE KEY
            begin
                ;Duplicate key
                errorMessage = "Duplicate key detected in database!"
                sts = 2
            end
            (),
            begin
                errorMessage = "Failed to insert row into Employee. Error was: " + ex.Message
            end
            endusing
            xcall ThrowOnSqlClientError(errorMessage,ex)
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            Settings.CurrentTransaction.Commit()
        end
        else
        begin
            ;There was an error, rollback the transaction
            Settings.CurrentTransaction.Rollback()
        end
        Settings.CurrentTransaction.Dispose()
        Settings.CurrentTransaction = ^null
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn sts

endfunction

;*****************************************************************************
;;; <summary>
;;; Inserts multiple rows into the Employee table.
;;; </summary>
;;; <param name="a_data">Memory handle containing one or more rows to insert.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <param name="a_exception">Memory handle to load exception data records into.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_InsertRows, ^val
    required in  a_data, i
    required out aErrorMessage, a
    optional out a_exception, i

    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok,             boolean     ;Return status
        rows,           int         ;Number of rows to insert
        command,        @SqlCommand ;Represtens the SQL command to execute
        length,         int         ;Length of a string
        ex_ms,          int         ;Size of exception array
        ex_mc,          int         ;Items in exception array
        continue,       int         ;Continue after an error
        errorMessage,   string      ;Error message text
    endrecord

    literal
        sql, string, "INSERT INTO Employee ("
        & + '"EmpId",'
        & + '"EmpFirstName",'
        & + '"EmpLastName",'
        & + '"EmpDept",'
        & + '"EmpHireDate",'
        & + '"EmpPhoneWork",'
        & + '"EmpPhoneCell",'
        & + '"EmpPaid",'
        & + '"EmpDateOfBirth",'
        & + '"EmpHireTime",'
        & + '"EmpEmail",'
        & + '"EmpAddressStreet",'
        & + '"EmpAddressCity",'
        & + '"EmpAddressState",'
        & + '"EmpAddressZip"'
        & + ") VALUES("
        & + "@EmpId,"
        & + "@EmpFirstName,"
        & + "@EmpLastName,"
        & + "@EmpDept,"
        & + "@EmpHireDate,"
        & + "@EmpPhoneWork,"
        & + "@EmpPhoneCell,"
        & + "@EmpPaid,"
        & + "@EmpDateOfBirth,"
        & + "@EmpHireTime,"
        & + "@EmpEmail,"
        & + "@EmpAddressStreet,"
        & + "@EmpAddressCity,"
        & + "@EmpAddressState,"
        & + "@EmpAddressZip"
        & + ")"
    endliteral

    .include "EMPLOYEE" repository, structure="inpbuf", nofields, end
    .include "EMPLOYEE" repository, static record="employee", end

    static record
        tmpEmpHireTime, a5       ;Storage for HH:MM time field
        , a1                        ;In case there are no user timestamp, date or JJJJJJ date fields
    endrecord
proc
    init local_data
    ok = true
    errorMessage = String.Empty

    if (^passed(a_exception) && a_exception)
        clear a_exception

    ;Figure out how many rows to insert

    rows = (%mem_proc(DM_GETSIZE,a_data) / ^size(inpbuf))

   ;If enabled, disable auto-commit

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Automatic)
    begin
        try
        begin
            data sql = "SET IMPLICIT_TRANSACTIONS ON"
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to disable auto-commit. Error was: " + ex.Message
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        Settings.CurrentTransaction = Settings.DatabaseConnection.BeginTransaction()
    end

    ; If we're binding once, create the SqlCommand object and define parameters

    if (ok && Settings.SqlCommandReuse)
    begin
        command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
        if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
        begin
            command.Transaction = Settings.CurrentTransaction
        end
        command.Parameters.Add(new SqlParameter("@EmpId",DblToNetConverter.SmallDecimalToInt(employee.emp_id)))
        command.Parameters.Add(new SqlParameter("@EmpFirstName",DblToNetConverter.AlphaToString(employee.emp_first_name)))
        command.Parameters.Add(new SqlParameter("@EmpLastName",DblToNetConverter.AlphaToString(employee.emp_last_name)))
        command.Parameters.Add(new SqlParameter("@EmpDept",DblToNetConverter.AlphaToString(employee.emp_dept)))
        command.Parameters.Add(new SqlParameter("@EmpHireDate",DblToNetConverter.DateToNullableDateTime(employee.emp_hire_date)))
        command.Parameters.Add(new SqlParameter("@EmpPhoneWork",DblToNetConverter.AlphaToString(employee.emp_phone_work)))
        command.Parameters.Add(new SqlParameter("@EmpPhoneCell",DblToNetConverter.AlphaToString(employee.emp_phone_cell)))
        command.Parameters.Add(new SqlParameter("@EmpPaid",DblToNetConverter.SmallDecimalToInt(employee.emp_paid)))
        command.Parameters.Add(new SqlParameter("@EmpDateOfBirth",DblToNetConverter.DateToNullableDateTime(employee.emp_date_of_birth)))
        command.Parameters.Add(new SqlParameter("@EmpHireTime",DblToNetConverter.HHMMToTimeSpan(employee.emp_hire_time)))
        command.Parameters.Add(new SqlParameter("@EmpEmail",DblToNetConverter.AlphaToString(employee.emp_email)))
        command.Parameters.Add(new SqlParameter("@EmpAddressStreet",DblToNetConverter.AlphaToString(employee.emp_address_street)))
        command.Parameters.Add(new SqlParameter("@EmpAddressCity",DblToNetConverter.AlphaToString(employee.emp_address_city)))
        command.Parameters.Add(new SqlParameter("@EmpAddressState",DblToNetConverter.AlphaToString(employee.emp_address_state)))
        command.Parameters.Add(new SqlParameter("@EmpAddressZip",DblToNetConverter.SmallDecimalToInt(employee.emp_address_zip)))
    end

    ;Insert the rows into the database

    if (ok)
    begin
        data cnt, int
        for cnt from 1 thru rows
        begin
            ;Load data into bound record
            employee = ^m(inpbuf[cnt],a_data)

            ;Clean up alpha variables
            employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
            employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
            employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
            employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
            employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
            employee.emp_email = %atrim(employee.emp_email)+%char(0)
            employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
            employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
            employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

            ;Clean up decimal variables
            if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
                clear employee.emp_id
            if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
                clear employee.emp_paid
            if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
                clear employee.emp_address_zip

            ;Clean up date variables
            if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
                ^a(employee.emp_hire_date(1:1))=%char(0)
            if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
                ^a(employee.emp_date_of_birth(1:1))=%char(0)

            ;Clean up time variables
            if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
                ^a(employee.emp_hire_time(1:1))=%char(0)

            ;Assign any time or user-defined timestamp fields
            tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

            ;Assign values to temp fields for any fields with custom data types

            if (Settings.SqlCommandReuse) then
            begin
                ;Bind data for the current record to the existing command parameters
                command.Parameters["@EmpId"].Value = DblToNetConverter.SmallDecimalToInt(employee.emp_id)
                command.Parameters["@EmpFirstName"].Value = DblToNetConverter.AlphaToString(employee.emp_first_name)
                command.Parameters["@EmpLastName"].Value = DblToNetConverter.AlphaToString(employee.emp_last_name)
                command.Parameters["@EmpDept"].Value = DblToNetConverter.AlphaToString(employee.emp_dept)
                command.Parameters["@EmpHireDate"].Value = DblToNetConverter.DateToNullableDateTime(employee.emp_hire_date)
                command.Parameters["@EmpPhoneWork"].Value = DblToNetConverter.AlphaToString(employee.emp_phone_work)
                command.Parameters["@EmpPhoneCell"].Value = DblToNetConverter.AlphaToString(employee.emp_phone_cell)
                command.Parameters["@EmpPaid"].Value = DblToNetConverter.SmallDecimalToInt(employee.emp_paid)
                command.Parameters["@EmpDateOfBirth"].Value = DblToNetConverter.DateToNullableDateTime(employee.emp_date_of_birth)
                command.Parameters["@EmpHireTime"].Value = DblToNetConverter.HHMMToTimeSpan(employee.emp_hire_time)
                command.Parameters["@EmpEmail"].Value = DblToNetConverter.AlphaToString(employee.emp_email)
                command.Parameters["@EmpAddressStreet"].Value = DblToNetConverter.AlphaToString(employee.emp_address_street)
                command.Parameters["@EmpAddressCity"].Value = DblToNetConverter.AlphaToString(employee.emp_address_city)
                command.Parameters["@EmpAddressState"].Value = DblToNetConverter.AlphaToString(employee.emp_address_state)
                command.Parameters["@EmpAddressZip"].Value = DblToNetConverter.SmallDecimalToInt(employee.emp_address_zip)
            end
            else
            begin
                ;Create the SqlCommand, add parameters and bind the data for the current record
                if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
                begin
                    command.Transaction = Settings.CurrentTransaction
                end
                command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
                if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
                begin
                    command.Transaction = Settings.CurrentTransaction
                end
                command.Parameters.AddWithValue("@EmpId",DblToNetConverter.SmallDecimalToInt(employee.emp_id))
                command.Parameters.AddWithValue("@EmpFirstName",DblToNetConverter.AlphaToString(employee.emp_first_name))
                command.Parameters.AddWithValue("@EmpLastName",DblToNetConverter.AlphaToString(employee.emp_last_name))
                command.Parameters.AddWithValue("@EmpDept",DblToNetConverter.AlphaToString(employee.emp_dept))
                command.Parameters.AddWithValue("@EmpHireDate",DblToNetConverter.DateToNullableDateTime(employee.emp_hire_date))
                command.Parameters.AddWithValue("@EmpPhoneWork",DblToNetConverter.AlphaToString(employee.emp_phone_work))
                command.Parameters.AddWithValue("@EmpPhoneCell",DblToNetConverter.AlphaToString(employee.emp_phone_cell))
                command.Parameters.AddWithValue("@EmpPaid",DblToNetConverter.SmallDecimalToInt(employee.emp_paid))
                command.Parameters.AddWithValue("@EmpDateOfBirth",DblToNetConverter.DateToNullableDateTime(employee.emp_date_of_birth))
                command.Parameters.AddWithValue("@EmpHireTime",DblToNetConverter.HHMMToTimeSpan(employee.emp_hire_time))
                command.Parameters.AddWithValue("@EmpEmail",DblToNetConverter.AlphaToString(employee.emp_email))
                command.Parameters.AddWithValue("@EmpAddressStreet",DblToNetConverter.AlphaToString(employee.emp_address_street))
                command.Parameters.AddWithValue("@EmpAddressCity",DblToNetConverter.AlphaToString(employee.emp_address_city))
                command.Parameters.AddWithValue("@EmpAddressState",DblToNetConverter.AlphaToString(employee.emp_address_state))
                command.Parameters.AddWithValue("@EmpAddressZip",DblToNetConverter.SmallDecimalToInt(employee.emp_address_zip))
            end

            ; Execute the SQL statement

            try
            begin
                command.ExecuteNonQuery()
                errorMessage = ""
            end
            catch (ex, @SqlException)
            begin
                errorMessage = "Failed to insert row. Error was: " + ex.Message
                xcall ThrowOnSqlClientError(errorMessage,ex)

                clear continue

                ;Are we logging errors?
                if (Settings.TerminalChannel)
                begin
                    writes(Settings.TerminalChannel,errorMessage)
                    continue=1
                end

                ;Are we processing exceptions?
                if (^passed(a_exception))
                begin
                    if (ex_mc==ex_ms)
                    begin
                        if (!a_exception) then
                            a_exception = %mem_proc(DM_ALLOC|DM_STATIC,^size(inpbuf)*(ex_ms=EXCEPTION_BUFSZ))
                        else
                            a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*(ex_ms+=EXCEPTION_BUFSZ),a_exception)
                    end
                    ^m(inpbuf[ex_mc+=1],a_exception)=employee
                    continue=1
                end

                if (continue) then
                    nextloop
                else
                begin
                    ok = false
                    exitloop
                end
            end
            finally
            begin
                if (!Settings.SqlCommandReuse)
                begin
                    command.Dispose()
                    command = ^null
                end
            end
            endtry
        end
    end

    ;If we're binding once, dispose the SqlCommand

    if (Settings.SqlCommandReuse && (command != ^null))
    begin
        command.Dispose()
        command = ^null
    end

    ;Commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            Settings.CurrentTransaction.Commit()
        end
        else
        begin
            ;There was an error, rollback the transaction
            Settings.CurrentTransaction.Rollback()
        end
        Settings.CurrentTransaction.Dispose()
        Settings.CurrentTransaction = ^null
    end

    ;If necessary, re-enable auto-commit

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Automatic)
    begin
        try
        begin
            data sql = "SET IMPLICIT_TRANSACTIONS OFF"
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to re-enable auto-commit. Error was: " + ex.Message
            ok = false
        end
        endtry
    end

    ;If we're returning exceptions then resize the buffer to the correct size

    if (^passed(a_exception) && a_exception)
        a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*ex_mc,a_exception)

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Updates a row in the Employee table.
;;; </summary>
;;; <param name="a_data">Record containing data to update.</param>
;;; <param name="a_rows">Returned number of rows affected.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Update, ^val
    required in  a_data,   a
    optional out a_rows,   i
    required out aErrorMessage, a

    stack record local_data
        ok,             boolean     ;OK to continue
        length,         int         ;Length of a string
        rows,           int         ;Number of rows updated
        errorMessage,   string      ;Error message text
    endrecord

    literal
        sql, string, 'UPDATE Employee SET '
        & + '"EmpId"=@EmpId,'
        & + '"EmpFirstName"=@EmpFirstName,'
        & + '"EmpLastName"=@EmpLastName,'
        & + '"EmpDept"=@EmpDept,'
        & + '"EmpHireDate"=@EmpHireDate,'
        & + '"EmpPhoneWork"=@EmpPhoneWork,'
        & + '"EmpPhoneCell"=@EmpPhoneCell,'
        & + '"EmpPaid"=@EmpPaid,'
        & + '"EmpDateOfBirth"=@EmpDateOfBirth,'
        & + '"EmpHireTime"=@EmpHireTime,'
        & + '"EmpEmail"=@EmpEmail,'
        & + '"EmpAddressStreet"=@EmpAddressStreet,'
        & + '"EmpAddressCity"=@EmpAddressCity,'
        & + '"EmpAddressState"=@EmpAddressState,'
        & + '"EmpAddressZip"=@EmpAddressZip'
        & + ' WHERE "EmpId"=@EmpId  '
    endliteral

    static record
        employee, strEmployee
        tmpEmpHireTime, a5      ;Storage for HH:MM time field
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    if (^passed(a_rows))
        clear a_rows

    ;Load the data into the bound record
    employee = a_data

    ;Clean up alpha fields
    employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
    employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
    employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
    employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
    employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
    employee.emp_email = %atrim(employee.emp_email)+%char(0)
    employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
    employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
    employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

    ;Clean up decimal fields
    if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
        clear employee.emp_id
    if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
        clear employee.emp_paid
    if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
        clear employee.emp_address_zip

    ;Clean up date fields
    if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
        ^a(employee.emp_hire_date(1:1)) = %char(0)
    if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
        ^a(employee.emp_date_of_birth(1:1)) = %char(0)

    ;Clean up time fields
    if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
        ^a(employee.emp_hire_time(1:1)) = %char(0)

    ;Assign time and user-defined timestamp fields
    tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

    ;Assign values to temp fields for any fields with custom data types

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        Settings.CurrentTransaction = Settings.DatabaseConnection.BeginTransaction()
    end

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end

            ;Bind the host variables for data to be updated
            command.Parameters.AddWithValue("@EmpId",DblToNetConverter.SmallDecimalToInt(employee.emp_id))
            command.Parameters.AddWithValue("@EmpFirstName",DblToNetConverter.AlphaToString(employee.emp_first_name))
            command.Parameters.AddWithValue("@EmpLastName",DblToNetConverter.AlphaToString(employee.emp_last_name))
            command.Parameters.AddWithValue("@EmpDept",DblToNetConverter.AlphaToString(employee.emp_dept))
            command.Parameters.AddWithValue("@EmpHireDate",DblToNetConverter.DateToNullableDateTime(employee.emp_hire_date))
            command.Parameters.AddWithValue("@EmpPhoneWork",DblToNetConverter.AlphaToString(employee.emp_phone_work))
            command.Parameters.AddWithValue("@EmpPhoneCell",DblToNetConverter.AlphaToString(employee.emp_phone_cell))
            command.Parameters.AddWithValue("@EmpPaid",DblToNetConverter.SmallDecimalToInt(employee.emp_paid))
            command.Parameters.AddWithValue("@EmpDateOfBirth",DblToNetConverter.DateToNullableDateTime(employee.emp_date_of_birth))
            command.Parameters.AddWithValue("@EmpHireTime",DblToNetConverter.HHMMToTimeSpan(employee.emp_hire_time))
            command.Parameters.AddWithValue("@EmpEmail",DblToNetConverter.AlphaToString(employee.emp_email))
            command.Parameters.AddWithValue("@EmpAddressStreet",DblToNetConverter.AlphaToString(employee.emp_address_street))
            command.Parameters.AddWithValue("@EmpAddressCity",DblToNetConverter.AlphaToString(employee.emp_address_city))
            command.Parameters.AddWithValue("@EmpAddressState",DblToNetConverter.AlphaToString(employee.emp_address_state))
            command.Parameters.AddWithValue("@EmpAddressZip",DblToNetConverter.SmallDecimalToInt(employee.emp_address_zip))

            ;Bind the host variables for the key segments / WHERE clause
            command.Parameters.AddWithValue("@EmpId",employee.emp_id)

            rows = command.ExecuteNonQuery()

            if (^passed(a_rows))
                a_rows = rows
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to update row. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            Settings.CurrentTransaction.Commit()
        end
        else
        begin
            ;There was an error, rollback the transaction
            Settings.CurrentTransaction.Rollback()
        end
        Settings.CurrentTransaction.Dispose()
        Settings.CurrentTransaction = ^null
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes a row from the Employee table.
;;; </summary>
;;; <param name="a_key">Unique key of row to be deleted.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Delete, ^val
    required in  a_key,    a
    required out aErrorMessage, a

    .include "EMPLOYEE" repository, stack record="employee"

    external function
        EmployeeKeyToRecord, a
    endexternal

    .align
    stack record local_data
        ok,             boolean     ;Return status
        cursor,         int         ;Database cursor
        errorMessage,   string      ;Error message
        sql,            string      ;SQL statement
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    ;Put the unique key value into the record
    employee = %EmployeeKeyToRecord(a_key)

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        Settings.CurrentTransaction = Settings.DatabaseConnection.BeginTransaction()
    end

    ;;Delete the row
    if (ok)
    begin
        sql = 'DELETE FROM "Employee" WHERE'
        &    + ' "EmpId"=' + "'" + %string(employee.emp_id) + "' "

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to delete row. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            Settings.CurrentTransaction.Commit()
        end
        else
        begin
            ;There was an error, rollback the transaction
            Settings.CurrentTransaction.Rollback()
        end
        Settings.CurrentTransaction.Dispose()
        Settings.CurrentTransaction = ^null
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes all rows from the Employee table.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Clear, ^val
    required out aErrorMessage, a

    .align
    stack record local_data
        ok,             boolean ;Return status
        errorMessage,   string  ;Returned error message text
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        Settings.CurrentTransaction = Settings.DatabaseConnection.BeginTransaction()
    end

    ;;Truncate the table
    if (ok)
    begin
        try
        begin
            data sql = 'TRUNCATE TABLE "Employee"'
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to truncate table. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            Settings.CurrentTransaction.Commit()
        end
        else
        begin
            ;There was an error, rollback the transaction
            Settings.CurrentTransaction.Rollback()
        end
        Settings.CurrentTransaction.Dispose()
        Settings.CurrentTransaction = ^null
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes the Employee table from the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Drop, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        errorMessage, string
    endrecord

proc
    ok = true
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        Settings.CurrentTransaction = Settings.DatabaseConnection.BeginTransaction()
    end

    ;Drop the database table and primary key constraint
    try
    begin
        data sql = "DROP TABLE Employee"
        disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.DatabaseTimeout }
        if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
        begin
            command.Transaction = Settings.CurrentTransaction
        end
        command.ExecuteNonQuery()
    end
    catch (ex, @SqlException)
    begin
        using ex.Number select
        (3701), ;Cannot drop the table 'Employee', because it does not exist or you do not have permission.
            nop
        (),
        begin
            errorMessage = "Failed to drop table. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endusing
    end
    endtry 

    ;Commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            Settings.CurrentTransaction.Commit()
        end
        else
        begin
            ;There was an error, rollback the transaction
            Settings.CurrentTransaction.Rollback()
        end
        Settings.CurrentTransaction.Dispose()
        Settings.CurrentTransaction = ^null
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Load all data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <param name="a_added">Total number of successful inserts.</param>
;;; <param name="a_failed">Total number of failed inserts.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Load, ^val
    required in  a_maxrows, n
    required out a_added, n
    required out a_failed, n
    required out aErrorMessage, a

    .include "EMPLOYEE" repository, structure="inpbuf", end
    .include "EMPLOYEE" repository, stack record="tmprec", end

    .define BUFFER_ROWS     1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok,             boolean     ;Return status
        firstRecord,    boolean     ;Is this the first record?
        filechn,        int         ;Data file channel
        mh,             D_HANDLE    ;Memory handle containing data to insert
        ms,             int         ;Size of memory buffer in rows
        mc,             int         ;Memory buffer rows currently used
        ex_mh,          D_HANDLE    ;Memory buffer for exception records
        ex_mc,          int         ;Number of records in returned exception array
        ex_ch,          int         ;Exception log file channel
        attempted,      int         ;Rows being attempted
        done_records,   int         ;Records loaded
        max_records,    int         ;Maximum records to load
        ttl_added,      int         ;Total rows added
        ttl_failed,     int         ;Total failed inserts
        errnum,         int         ;Error number
        tmperrmsg,      a512        ;Temporary error message
        errorMessage,   string      ;Error message text
        now,            a20        ;;Current date and time
        timer,          @Timer
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    timer = new Timer()
    timer.Start()

    ;If we are logging exceptions, delete any existing exceptions file.
    if (Settings.LogBulkLoadExceptions)
    begin
        xcall delet("REPLICATOR_LOGDIR:employee_data_exceptions.log")
    end

    ;Open the data file associated with the structure
    if (!(filechn = %EmployeeOpenInput(tmperrmsg)))
    begin
        errorMessage = "Failed to open data file! Error was " + %atrimtostring(tmperrmsg)
        ok = false
    end

    if (ok)
    begin
        ;Were we passed a max # records to load
        max_records = a_maxrows > 0 ? a_maxrows : 0
        done_records = 0

        ;Allocate memory buffer for the database rows
        mh = %mem_proc(DM_ALLOC,^size(inpbuf)*(ms=BUFFER_ROWS))

        ;Read records from the input file
        firstRecord = true
        repeat
        begin
            ;Get the next record from the input file
            try
            begin
                if (firstRecord) then
                begin
                    read(filechn,tmprec,^FIRST)
                    firstRecord = false
                end
                else
                begin
                    reads(filechn,tmprec)
                end
            end
            catch (ex, @EndOfFileException)
            begin
                exitloop
            end
            catch (ex, @Exception)
            begin
                ok = false
                errorMessage = "Unexpected error while reading data file: " + ex.Message
                exitloop
            end
            endtry

            ;Got one, load it into or buffer
            ^m(inpbuf[mc+=1],mh) = tmprec

            incr done_records

            ;If the buffer is full, write it to the database
            if (mc==ms)
            begin
                call insert_data
            end

            if (max_records && (done_records == max_records))
            begin
                exitloop
            end
        end

        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(inpbuf)*mc,mh)
            call insert_data
        end

        ;;Deallocate memory buffer
        mh = %mem_proc(DM_FREE,mh)
    end

    ;Close the file
    if (filechn && %chopen(filechn))
        close filechn

    ;Close the exceptions log file
    if (ex_ch && %chopen(ex_ch))
        close ex_ch

    ;Return totals
    a_added = ttl_added
    a_failed = ttl_failed

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    timer.Stop()
    now = %datetime

    if (ok) then
    begin
        writelog("Load COMPLETE after " + timer.ElapsedTimeString)
        writett("Load COMPLETE after " + timer.ElapsedTimeString)
    end
    else
    begin
        writelog("Load FAILED after " + timer.ElapsedTimeString)
        writett("Load FAILED after " + timer.ElapsedTimeString)
    end

    freturn ok

insert_data,

    attempted = (%mem_proc(DM_GETSIZE,mh)/^size(inpbuf))

    if (!%Employee_InsertRows(mh,tmperrmsg,ex_mh)) then
    begin
        errorMessage = %atrimtostring(tmperrmsg)
    end
    else
    begin
        ;;Any exceptions?
        if (ex_mh) then
        begin
            ;How many exceptions to log?
            ex_mc = %mem_proc(DM_GETSIZE,ex_mh) / ^size(inpbuf)

            ;Update totals
            ttl_failed += ex_mc
            ttl_added += (attempted-ex_mc)

            ;Are we logging exceptions?
            if (Settings.LogBulkLoadExceptions) then
            begin
                data cnt, int

                ;Open the log file
                if (!ex_ch)
                begin
                    open(ex_ch=0,o:s,"REPLICATOR_LOGDIR:employee_data_exceptions.log")
                end

                ;Log the exceptions
                for cnt from 1 thru ex_mc
                begin
                    writes(ex_ch,^m(inpbuf[cnt],ex_mh))
                end

                ;And maybe show them on the terminal
                if (Settings.TerminalChannel)
                begin
                    writes(Settings.TerminalChannel,"Exceptions were logged to REPLICATOR_LOGDIR:employee_data_exceptions.log")
                end
            end
            else
            begin
                ;No, report and error
                ok = false
            end

            ;Release the exception buffer
            ex_mh = %mem_proc(DM_FREE,ex_mh)
        end
        else
        begin
            ;No exceptions
            ttl_added += attempted
            if (Settings.TerminalChannel && Settings.LogLoadProgress)
            begin
                writes(Settings.TerminalChannel," - " + %string(ttl_added) + " rows inserted")
            end
        end
    end

    clear mc

    return

endfunction

;*****************************************************************************
;;; <summary>
;;; Bulk load data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table via a CSV file.
;;; </summary>
;;; <param name="recordsToLoad">Number of records to load (0=all)</param>
;;; <param name="a_records">Records loaded</param>
;;; <param name="a_exceptions">Records failes</param>
;;; <param name="aErrorMessage">Error message (if return value is false)</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_BulkLoad, ^val
    required in recordsToLoad,  n
    required out a_records,     n
    required out a_exceptions,  n
    required out aErrorMessage, a

     stack record local_data
        ok,                     boolean    ;;Return status
        remoteBulkLoad,         boolean
        localCsvFile,           string
        localExceptionsFile,    string
        localExceptionsLog,     string
        remoteCsvFile,          string
        remoteExceptionsFile,   string
        remoteExceptionsLog,    string
        copyTarget,             string
        fileToLoad,             string
        cursor,                 int
        length,                 int
        dberror,                int
        recordCount,            int	        ;# records loaded
        exceptionCount,         int         ;# records failed
        errtxt,                 a512        ;Temp error message
        errorMessage,           string      ;Error message
        fsc,                    @FileServiceClient
        now,                    a20
        timer,                  @Timer
    endrecord

proc
    init local_data
    ok = true

    timer = new Timer()
    timer.Start()

    ;If we're doing a remote bulk load, create an instance of the FileService client and verify that we can access the FileService server

    remoteBulkLoad = Settings.CanBulkLoad() && Settings.DatabaseIsRemote()

    if (remoteBulkLoad)
    begin
        fsc = new FileServiceClient(Settings.FileServiceHost,Settings.FileServicePort)

        now = %datetime
        writelog("Verifying FileService connection")
        writett("Verifying FileService connection")

        if (!fsc.Ping(errtxt))
        begin
            errorMessage = "No response from FileService, bulk load cancelled"
            now = %datetime
            writelog(errorMessage)
            writett(errorMessage)
            ok = false
        end
    end

    ;Define temp file names and make sure there are no local temp files left over from a previous operation

    if (ok)
    begin
        .ifdef OS_VMS
        localCsvFile = String.Format("{0}Employee.csv",Settings.LocalExportPath)
        .else
        localCsvFile = Path.Combine(Settings.LocalExportPath,"Employee.csv")
        .endc
        localExceptionsFile = String.Format("{0}_err",localCsvFile)
        localExceptionsLog = String.Format("{0}.Error.Txt",localExceptionsFile)

        if (remoteBulkLoad)
        begin
            remoteCsvFile = "Employee.csv"
            remoteExceptionsFile = String.Format("{0}_err",remoteCsvFile)
            remoteExceptionsLog = String.Format("{0}.Error.Txt",remoteExceptionsFile)
        end

        now = %datetime
        writelog("Deleting local temp files")
        writett("Deleting local temp files")

        if (File.Exists(localCsvFile))
        begin
            try
            begin
                File.Delete(localCsvFile)
            end
            catch (ex)
            begin
                nop
            end
            endtry
        end

        if (File.Exists(localExceptionsFile))
        begin
            try
            begin
                File.Delete(localExceptionsFile)
            end
            catch (ex)
            begin
                nop
            end
            endtry
        end

        if (File.Exists(localExceptionsLog))
        begin
            try
            begin
                File.Delete(localExceptionsLog)
            end
            catch (ex)
            begin
                nop
            end
            endtry
        end

        ;Delete remote files

        if (remoteBulkLoad)
        begin
            now = %datetime
            writelog("Deleting remote temp files")
            writett("Deleting remote temp files")

            fsc.Delete(remoteCsvFile)
            fsc.Delete(remoteExceptionsFile)
            fsc.Delete(remoteExceptionsLog)
        end

        ;Were we asked to load a specific number of records?

        recordCount =  recordCount > 0 ? recordCount : 0

        ;And export the data

        now = %datetime
        writelog("Exporting data")
        writett("Exporting data")

        ok = %Employee_Csv(localCsvFile,0,recordCount,errtxt)

        errorMessage = ok ? String.Empty : %atrimtostring(errtxt)
    end

    ;If necessary, upload the exported file to the database server

    if (ok)
    begin
        if (remoteBulkLoad) then
        begin
            now = %datetime
            writelog("Uploading data to database server")
            writett("Uploading data to database server")
            ok = fsc.UploadChunked(localCsvFile,remoteCsvFile,320,fileToLoad,errtxt)
            errorMessage = ok ? String.Empty : %atrimtostring(errtxt)
        end
        else
        begin
            fileToLoad  = localCsvFile
        end
    end

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        Settings.CurrentTransaction = Settings.DatabaseConnection.BeginTransaction()
    end

    ;Execute the BULK INSERT statement

    if (ok)
    begin
        data sql = String.Format("BULK INSERT Employee FROM '{0}' WITH (FIRSTROW=2,FIELDTERMINATOR='|',ROWTERMINATOR='\n',MAXERRORS=100000000,ERRORFILE='{0}_err'",fileToLoad)

        if (Settings.BulkLoadBatchSize > 0)
        begin
            sql = String.Format("{0},BATCHSIZE={1}",sql,Settings.BulkLoadBatchSize)
        end

        sql = String.Format("{0})",sql)

        now = %datetime
        writelog("Executing BULK INSERT")
        writett("Executing BULK INSERT")

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { CommandTimeout = Settings.BulkLoadTimeout }
            if (Settings.DatabaseCommitMode != DatabaseCommitMode.Automatic)
            begin
                command.Transaction = Settings.CurrentTransaction
            end
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "BULK INSERT failed. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)

            now = %datetime
            writelog("Bulk insert failed. " + ex.Message)
            writett("Bulk insert failed. " + ex.Message)

            using ex.Number select
            (-4864),
            begin
                ;Bulk load data conversion error
                now = %datetime
                writelog("Data conversion errors were reported")
                writett("Data conversion errors were reported")
                errorMessage = String.Empty

                ;------------------------------------------------------------------------------------------------------------
                ;This used to be an internal subroutine GetExceptionDetails but in .NET we can't call it from here! Sucks!

                ;If we get here the bulk load reported one or more "data conversion error" issues and there should be two log files on the server

                now = %datetime
                writelog("Data conversion errors, processing exceptions")
                writett("Data conversion errors, processing exceptions")

                if (remoteBulkLoad) then
                begin
                    data fileExists, boolean
                    data tmpmsg, string

                    if (fsc.Exists(remoteExceptionsFile,fileExists,tmpmsg)) then
                    begin
                        if (fileExists) then
                        begin
                            ;Download the error file
                            data exceptionRecords, [#]string
                            data errorMessage, string

                            now = %datetime
                            writelog("Downloading remote exceptions data file")
                            writett("Downloading remote exceptions data file")

                            if (fsc.DownloadText(remoteExceptionsFile,exceptionRecords,errorMessage))
                            begin
                                data ex_ch, int
                                data exceptionRecord, string

                                open(ex_ch=0,o:s,localExceptionsFile)

                                foreach exceptionRecord in exceptionRecords
                                    writes(ex_ch,exceptionRecord)

                                close ex_ch

                                exceptionCount = exceptionRecords.Length

                                now = %datetime
                                writelog(%string(exceptionCount) + " items saved to " + localExceptionsFile)
                                writett(%string(exceptionCount) + " items saved to " + localExceptionsFile)
                            end
                        end
                        else
                        begin
                            ;Error file does not exist. This should not happen because we got here due to data conversion errors being reported
                            now = %datetime
                            writelog("Remote exceptions data file not found!")
                            writett("Remote exceptions data file not found!")
                        end
                    end
                    else
                    begin
                        ;Failed to determine if file exists
                        now = %datetime
                        writelog("Failed to determine if remote exceptions data file exists. Error was " + tmpmsg)
                        writett("Failed to determine if remote exceptions data file exists. Error was " + tmpmsg)
                    end

                    ;Now check for and retrieve the associated exceptions log

                    if (fsc.Exists(remoteExceptionsLog,fileExists,tmpmsg)) then
                    begin
                        if (fileExists) then
                        begin
                            ;Download the error file
                            data exceptionRecords, [#]string
                            data errorMessage, string

                            now = %datetime
                            writelog("Downloading remote exceptions log file")
                            writett("Downloading remote exceptions log file")

                            if (fsc.DownloadText(remoteExceptionsLog,exceptionRecords,errorMessage))
                            begin
                                data ex_ch, int
                                data exceptionRecord, string

                                open(ex_ch=0,o:s,localExceptionsLog)

                                foreach exceptionRecord in exceptionRecords
                                    writes(ex_ch,exceptionRecord)

                                close ex_ch

                                now = %datetime
                                writelog(%string(exceptionRecords.Length) + " items saved to " + localExceptionsLog)
                                writelog(" - " + %string(exceptionRecords.Length) + " items saved to " + localExceptionsLog)
                            end
                        end
                        else
                        begin
                            ;Error file does not exist. This should not happen because we got here due to data conversion errors being reported
                            now = %datetime
                            writelog("Remote exceptions file not found!")
                            writett("Remote exceptions file not found!")
                        end
                    end
                    else
                    begin
                        ;Failed to determine if file exists
                        now = %datetime
                        writelog("Failed to determine if remote exceptions log file exists. Error was " + tmpmsg)
                    end
                end
                else
                begin
                    ;Local bulk load

                    if (File.Exists(localExceptionsFile)) then
                    begin
                        data ex_ch, int
                        data tmprec, a65535
                        open(ex_ch=0,i:s,localExceptionsFile)
                        repeat
                        begin
                            reads(ex_ch,tmprec,eof)
                            exceptionCount += 1
                        end
            eof,        close ex_ch
                        now = %datetime
                        writelog(%string(exceptionCount) + " exception items found in " + localExceptionsFile)
                    end
                    else
                    begin
                        ;Error file does not exist. This should not happen because we got here due to data conversion errors being reported
                        now = %datetime
                        writelog("Exceptions data file not found!")
                    end
                end

                ;------------------------------------------------------------------------------------------------------------
            end
            (),
            begin
                errorMessage = String.Format("{0} {1}",ex.Number,errorMessage)
                ok = false
            end
            endusing
        end
        endtry
    end

    ;Delete local temp files

    now = %datetime
    writelog("Deleting local temp files")
    writett("Deleting local temp files")

    if (File.Exists(localCsvFile))
    begin
        try
        begin
            File.Delete(localCsvFile)
        end
        catch (ex)
        begin
            nop
        end
        endtry
    end

    if (File.Exists(localExceptionsFile))
    begin
        try
        begin
            File.Delete(localExceptionsFile)
        end
        catch (ex)
        begin
            nop
        end
        endtry
    end

    if (File.Exists(localExceptionsLog))
    begin
        try
        begin
            File.Delete(localExceptionsLog)
        end
        catch (ex)
        begin
            nop
        end
        endtry
    end

    ;Delete remote temp files

    if (remoteBulkLoad)
    begin
        now = %datetime
        writelog("Deleting remote temp files")
        writett("Deleting remote temp files")

        fsc.Delete(remoteCsvFile)
        fsc.Delete(remoteExceptionsFile)
        fsc.Delete(remoteExceptionsLog)
    end

    ;If we're in manual commit mode, commit or rollback the transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            Settings.CurrentTransaction.Commit()
        end
        else
        begin
            ;There was an error, rollback the transaction
            Settings.CurrentTransaction.Rollback()
        end
        Settings.CurrentTransaction.Dispose()
        Settings.CurrentTransaction = ^null
    end

    ;Return the record and exceptions count
    a_records = recordCount
    a_exceptions = exceptionCount

    timer.Stop()
    now = %datetime

    if (ok) then
    begin
        writelog("Bulk load finished in " + timer.ElapsedTimeString)
        writett("Bulk load finished in " + timer.ElapsedTimeString)
    end
    else
    begin
        aErrorMessage = errorMessage
        writelog("Bulk load failed after " + timer.ElapsedTimeString)
        writett("Bulk load failed after " + timer.ElapsedTimeString)
    end

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Exports REPLICATOR_DATA:EMPLOYEE.ISM to a CSV file.
;;; </summary>
;;; <param name="fileSpec">File to create</param>
;;; <param name="maxRecords">Mumber of records to export.</param>
;;; <param name="recordCount">Returned number of records exported.</param>
;;; <param name="errorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Csv, boolean
    required in  fileSpec, a
    required in  maxRecords, n
    required out recordCount, n
    required out errorMessage, a

    .include "EMPLOYEE" repository, record="employee", end

    .define EXCEPTION_BUFSZ 100

    external function
        IsDecimalNo, boolean
        MakeDecimalForCsvNegatives, a
        MakeDecimalForCsvNoNegatives, a
        MakeTimeForCsv, a
    endexternal

    .align
    stack record local_data
        ok,         boolean ;Return status
        filechn,    int     ;Data file channel
        outchn,     int     ;CSV file channel
        outrec,     @StringBuilder  ;A CSV file record
        records,    int     ;Number of records exported
        errtxt,     a512    ;Error message text
        now,        a20     ;The time now
        timer,      @Timer  ;A timer
    endrecord

proc
    init local_data
    ok = true
    recordCount = 0
    errorMessage = ""

    timer = new Timer()
    timer.Start()

    ;;Open the data file associated with the structure

    if (!(filechn=%EmployeeOpenInput(errtxt)))
    begin
        errtxt = "Failed to open data file! Error was: " + errtxt
        ok = false
    end

    ;;Create the local CSV file

    if (ok)
    begin
.ifdef OS_WINDOWS7
        open(outchn=0,o:s,fileSpec)
.endc
.ifdef OS_UNIX
        open(outchn=0,o,fileSpec)
.endc
.ifdef OS_VMS
        open(outchn=0,o,fileSpec,OPTIONS:"/stream")
.endc

        ;;Add a row of column headers
.ifdef OS_WINDOWS7
        writes(outchn,"EmpId|EmpFirstName|EmpLastName|EmpDept|EmpHireDate|EmpPhoneWork|EmpPhoneCell|EmpPaid|EmpDateOfBirth|EmpHireTime|EmpEmail|EmpAddressStreet|EmpAddressCity|EmpAddressState|EmpAddressZip")
.else
        puts(outchn,"EmpId|EmpFirstName|EmpLastName|EmpDept|EmpHireDate|EmpPhoneWork|EmpPhoneCell|EmpPaid|EmpDateOfBirth|EmpHireTime|EmpEmail|EmpAddressStreet|EmpAddressCity|EmpAddressState|EmpAddressZip" + %char(13) + %char(10))
.endc

        ;;Read and add data file records
        foreach employee in new Select(new From(filechn,Q_NO_GRFA,0,employee))
        begin
            ;;Make sure there are no | characters in the data
            data pos, int
            while (pos = %instr(1,employee,"|"))
            begin
                clear employee(pos:1)
            end

            incr records

            if (maxRecords && (records > maxRecords))
            begin
                decr records
                exitloop
            end

            outrec = new StringBuilder()
            outrec.Append(employee.emp_id ? %MakeDecimalForCsvNoNegatives(employee.emp_id) + "|" : "0|")
            outrec.Append(employee.emp_first_name ? %atrim(employee.emp_first_name) + "|" : "|")
            outrec.Append(employee.emp_last_name ? %atrim(employee.emp_last_name) + "|" : "|")
            outrec.Append(employee.emp_dept ? %atrim(employee.emp_dept) + "|" : "|")
            outrec.Append(employee.emp_hire_date ? %string(employee.emp_hire_date,"XXXX-XX-XX") + "|" : "|")
            outrec.Append(employee.emp_phone_work ? %atrim(employee.emp_phone_work) + "|" : "|")
            outrec.Append(employee.emp_phone_cell ? %atrim(employee.emp_phone_cell) + "|" : "|")
            outrec.Append(employee.emp_paid ? %MakeDecimalForCsvNoNegatives(employee.emp_paid) + "|" : "0|")
            outrec.Append(employee.emp_date_of_birth ? %string(employee.emp_date_of_birth,"XXXX-XX-XX") + "|" : "|")
            outrec.Append(employee.emp_hire_time ? %MakeTimeForCsv(employee.emp_hire_time) + "|" : "|")
            outrec.Append(employee.emp_email ? %atrim(employee.emp_email) + "|" : "|")
            outrec.Append(employee.emp_address_street ? %atrim(employee.emp_address_street) + "|" : "|")
            outrec.Append(employee.emp_address_city ? %atrim(employee.emp_address_city) + "|" : "|")
            outrec.Append(employee.emp_address_state ? %atrim(employee.emp_address_state) + "|" : "|")
            outrec.Append(employee.emp_address_zip ? %MakeDecimalForCsvNoNegatives(employee.emp_address_zip) : "")

            .ifdef OS_WINDOWS7
            writes(outchn,outrec.ToString())
            .else
            puts(outchn,outrec.ToString() + %char(13) + %char(10))
            .endc
        end
    end

eof,

    ;Close the file
    if (filechn && %chopen(filechn))
    begin
        close filechn
    end

    ;Close the CSV file
    if (outchn && %chopen(outchn))
    begin
        close outchn
    end

    ;Return the record count
    recordCount = records

    ;Return any error message to the calling routine
    errorMessage = %atrim(errtxt)

    timer.Stop()
    now = %datetime

    if (ok)
    begin
        writelog("Export took " + timer.ElapsedTimeString)
        writett("Export took " + timer.ElapsedTimeString)
    end

    freturn ok

endfunction

.endc
