;*****************************************************************************
;
; File:        Employee_SqlIO.dbl
;
; Description: Various functions that performs SQL I/O for EMPLOYEE
;
;*****************************************************************************
; WARNING: THIS CODE WAS CODE GENERATED AND WILL BE OVERWRITTEN IF CODE
;          GENERATION IS RE-EXECUTED FOR THIS PROJECT.
;*****************************************************************************

.ifndef DBLNET
 ;This code was generated from the SqlClientIO template and can only be used
 ;in .NET. For traditional DBL environments use the SqlIO template
.else

import ReplicationLibrary
import Synergex.SynergyDE.Select
import System.Data.SqlClient

.ifndef strEmployee
.include "EMPLOYEE" repository, structure="strEmployee", end
.endc

.define writelog(x) if Settings.LogFileChannel && %chopen(Settings.LogFileChannel) writes(Settings.LogFileChannel,%string(^d(now(1:14)),"XXXX-XX-XX XX:XX:XX ") + x)
.define writett(x)  if Settings.TerminalChannel writes(Settings.TerminalChannel,"   - " + %string(^d(now(9:8)),"XX:XX:XX.XX ") + x)

;*****************************************************************************
;;; <summary>
;;; Determines if the Employee table exists in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns 1 if the table exists, otherwise a number indicating the type of error.</returns>

function Employee_Exists, ^val
    required out aErrorMessage, a

    stack record
        error, int
        errorMessage, string
    endrecord
proc
    error = 0
    errorMessage = String.Empty

    try
    begin
        disposable data command = new SqlCommand("SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='Employee'",Settings.DatabaseConnection) { 
        &   CommandTimeout = Settings.DatabaseTimeout
        & }
        disposable data reader = command.ExecuteReader()
        if (reader.Read()) then
        begin
            ;Table exists
            error = 1
        end
        else
        begin
            errorMessage = "Table not found"
            error = 0
        end
    end
    catch (ex, @SqlException)
    begin
        errorMessage = ex.Message
        error = -1
        xcall ThrowOnSqlClientError(errorMessage,ex)
    end
    endtry

    ;Return any error message to the calling routine
    aErrorMessage = error == 1 ? String.Empty : errorMessage

    freturn error

endfunction

;*****************************************************************************
;;; <summary>
;;; Creates the Employee table in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Create, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
    endrecord
    static record
        createTableCommand, string
    endrecord
proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Define the CREATE TABLE statement

    if (ok && createTableCommand == ^null)
    begin
        createTableCommand = 'CREATE TABLE "Employee" ('
        & + '"EmpId" DECIMAL(6) NOT NULL,'
        & + '"EmpFirstName" VARCHAR(20) NOT NULL,'
        & + '"EmpLastName" VARCHAR(20) NOT NULL,'
        & + '"EmpDept" VARCHAR(15) NOT NULL,'
        & + '"EmpHireDate" DATE,'
        & + '"EmpPhoneWork" VARCHAR(14),'
        & + '"EmpPhoneCell" VARCHAR(14),'
        & + '"EmpPaid" DECIMAL(1),'
        & + '"EmpDateOfBirth" DATE,'
        & + '"EmpHireTime" TIME(0),'
        & + '"EmpEmail" VARCHAR(40),'
        & + '"EmpAddressStreet" VARCHAR(30),'
        & + '"EmpAddressCity" VARCHAR(20),'
        & + '"EmpAddressState" VARCHAR(2),'
        & + '"EmpAddressZip" DECIMAL(5),'
        & + 'CONSTRAINT PK_Employee PRIMARY KEY CLUSTERED("EmpId" ASC)'
        & + ')'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            createTableCommand = createTableCommand + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            createTableCommand = createTableCommand + " WITH(DATA_COMPRESSION=ROW)"
        endusing
    end

    ;Create the database table and primary key constraint

    try
    begin
        disposable data command = new SqlCommand(createTableCommand,Settings.DatabaseConnection) { 
        &   CommandTimeout = Settings.DatabaseTimeout
        & }
        command.ExecuteNonQuery()
    end
    catch (ex, @SqlException)
    begin
        ok = false
        errorMessage = "Failed to create table. Error was: " + ex.Message
    end
    endtry 

    ;Grant access permissions

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('GRANT ALL ON "Employee" TO PUBLIC',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to grant table permissions. Error was: " + ex.Message
        end
        endtry
    end

    ;Commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Add alternate key indexes to the Employee table if they do not exist.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Index, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
        now, a20
    endrecord

proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Create index 1 (Department ID)

    if (ok && !%Index_Exists("IX_Employee_EmpDept"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_EmpDept ON "Employee"("EmpDept" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.BulkLoadTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_EmpDept. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_EmpDept")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;Create index 2 (Last name)

    if (ok && !%Index_Exists("IX_Employee_EmpLastName"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_EmpLastName ON "Employee"("EmpLastName" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.BulkLoadTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_EmpLastName. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_EmpLastName")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;Create index 3 (State)

    if (ok && !%Index_Exists("IX_Employee_StateCode"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_StateCode ON "Employee"("EmpAddressState" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.BulkLoadTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_StateCode. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_StateCode")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;Create index 4 (Zip code)

    if (ok && !%Index_Exists("IX_Employee_ZipCode"))
    begin
        data sql = 'CREATE  INDEX IX_Employee_ZipCode ON "Employee"("EmpAddressZip" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.BulkLoadTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Employee_ZipCode. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Employee_ZipCode")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Removes alternate key indexes from the Employee table in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_UnIndex, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
    endrecord

proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Drop index 1 (Department ID)

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('DROP INDEX IF EXISTS IX_Employee_EmpDept ON "Employee"',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_EmpDept. Error was: " + ex.Message
        end
        endtry
    end

    ;Drop index 2 (Last name)

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('DROP INDEX IF EXISTS IX_Employee_EmpLastName ON "Employee"',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_EmpLastName. Error was: " + ex.Message
        end
        endtry
    end

    ;Drop index 3 (State)

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('DROP INDEX IF EXISTS IX_Employee_StateCode ON "Employee"',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_StateCode. Error was: " + ex.Message
        end
        endtry
    end

    ;Drop index 4 (Zip code)

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('DROP INDEX IF EXISTS IX_Employee_ZipCode ON "Employee"',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Employee_ZipCode. Error was: " + ex.Message
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Insert a row into the Employee table.
;;; </summary>
;;; <param name="a_data">Record to be inserted.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns 1 if the row was inserted, 2 to indicate the row already exists, or 0 if an error occurred.</returns>

function Employee_Insert, ^val
    required in  a_data,   a
    required out aErrorMessage, a

    .align
    stack record local_data
        ok          ,boolean    ;OK to continue
        sts         ,int        ;Return status
        transaction ,boolean    ;Transaction in progress
        errorMessage,string     ;Error message text
    endrecord

    literal
        sql, string, "INSERT INTO Employee ("
        & + '"EmpId",'
        & + '"EmpFirstName",'
        & + '"EmpLastName",'
        & + '"EmpDept",'
        & + '"EmpHireDate",'
        & + '"EmpPhoneWork",'
        & + '"EmpPhoneCell",'
        & + '"EmpPaid",'
        & + '"EmpDateOfBirth",'
        & + '"EmpHireTime",'
        & + '"EmpEmail",'
        & + '"EmpAddressStreet",'
        & + '"EmpAddressCity",'
        & + '"EmpAddressState",'
        & + '"EmpAddressZip"'
        & + ") VALUES(@1,@2,@3,@4,@5,@6,@7,@8,@9,@10,@11,@12,@13,@14,@15)"
    endliteral

    static record
        employee, strEmployee
        tmpEmpHireTime, a5      ;Storage for HH:MM time field
    endrecord

proc
    init local_data
    ok = true
    sts = 1

    if (ok)
    begin
        ;Load the data into the bound record

        employee = a_data

        ;Clean up any alpha fields

        employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
        employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
        employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
        employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
        employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
        employee.emp_email = %atrim(employee.emp_email)+%char(0)
        employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
        employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
        employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

        ;Clean up any decimal fields

        if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
            clear employee.emp_id
        if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
            clear employee.emp_paid
        if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
            clear employee.emp_address_zip

        ;Clean up any date fields

        if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
            ^a(employee.emp_hire_date(1:1)) = %char(0)
        if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
            ^a(employee.emp_date_of_birth(1:1)) = %char(0)

        ;Clean up any time fields

        if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
            ^a(employee.emp_hire_time(1:1))=%char(0)

        ;Assign data to any temporary time or user-defined timestamp fields

        tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

        ;Assign values to temp fields for any fields with custom data types

    end

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }

            command.Parameters.AddWithValue("@1",employee.emp_id)
            command.Parameters.AddWithValue("@2",employee.emp_first_name)
            command.Parameters.AddWithValue("@3",employee.emp_last_name)
            command.Parameters.AddWithValue("@4",employee.emp_dept)
            command.Parameters.AddWithValue("@5",^a(employee.emp_hire_date))
            command.Parameters.AddWithValue("@6",employee.emp_phone_work)
            command.Parameters.AddWithValue("@7",employee.emp_phone_cell)
            command.Parameters.AddWithValue("@8",employee.emp_paid)
            command.Parameters.AddWithValue("@9",^a(employee.emp_date_of_birth))
            command.Parameters.AddWithValue("@10",tmpEmpHireTime)
            command.Parameters.AddWithValue("@11",employee.emp_email)
            command.Parameters.AddWithValue("@12",employee.emp_address_street)
            command.Parameters.AddWithValue("@13",employee.emp_address_city)
            command.Parameters.AddWithValue("@14",employee.emp_address_state)
            command.Parameters.AddWithValue("@15",employee.emp_address_zip)

            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            sts = 0
            using ex.ErrorCode Select
            (-2627),    ;TODO: * * * MAY NOT BE THE CORRECT ERROR NUMBER FOR DUPLICATE KEY
            begin
                ;Duplicate key
                errorMessage = "Duplicate key detected in database!"
                sts = 2
            end
            (),
            begin
                errorMessage = "Failed to insert row into Employee. Error was: " + ex.Message
            end
            endusing
            xcall ThrowOnSqlClientError(errorMessage,ex)
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn sts

endfunction

;*****************************************************************************
;;; <summary>
;;; Inserts multiple rows into the Employee table.
;;; </summary>
;;; <param name="a_data">Memory handle containing one or more rows to insert.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <param name="a_exception">Memory handle to load exception data records into.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_InsertRows, ^val
    required in  a_data, i
    required out aErrorMessage, a
    optional out a_exception, i

    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok,             boolean     ;Return status
        rows,           int         ;Number of rows to insert
        transaction,    boolean     ;Transaction in progress
        length,         int         ;Length of a string
        ex_ms,          int         ;Size of exception array
        ex_mc,          int         ;Items in exception array
        continue,       int         ;Continue after an error
        errorMessage,   string      ;Error message text
    endrecord

    literal
        sql, string, "INSERT INTO Employee ("
        & + '"EmpId",'
        & + '"EmpFirstName",'
        & + '"EmpLastName",'
        & + '"EmpDept",'
        & + '"EmpHireDate",'
        & + '"EmpPhoneWork",'
        & + '"EmpPhoneCell",'
        & + '"EmpPaid",'
        & + '"EmpDateOfBirth",'
        & + '"EmpHireTime",'
        & + '"EmpEmail",'
        & + '"EmpAddressStreet",'
        & + '"EmpAddressCity",'
        & + '"EmpAddressState",'
        & + '"EmpAddressZip"'
        & + ") VALUES(@1,@2,@3,@4,@5,@6,@7,@8,@9,@10,@11,@12,@13,@14,@15)"
    endliteral

    .include "EMPLOYEE" repository, structure="inpbuf", nofields, end
    .include "EMPLOYEE" repository, static record="employee", end

    static record
        tmpEmpHireTime, a5       ;Storage for HH:MM time field
        , a1                        ;In case there are no user timestamp, date or JJJJJJ date fields
    endrecord
proc
    init local_data
    ok = true
    errorMessage = String.Empty

    if (^passed(a_exception) && a_exception)
        clear a_exception

    ;Figure out how many rows to insert

    rows = (%mem_proc(DM_GETSIZE,a_data) / ^size(inpbuf))

    ;If enabled, disable auto-commit

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Automatic)
    begin
        try
        begin
            disposable data command = new SqlCommand("SET IMPLICIT_TRANSACTIONS ON",Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to disable auto-commit. Error was: " + ex.Message
            ok = false
        end
        endtry
    end

    ;Start a database transaction

    if (ok)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Insert the rows into the database

    if (ok)
    begin
        data cnt, int
        for cnt from 1 thru rows
        begin
            ;Load data into bound record

            employee = ^m(inpbuf[cnt],a_data)

            ;Clean up any alpha variables

            employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
            employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
            employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
            employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
            employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
            employee.emp_email = %atrim(employee.emp_email)+%char(0)
            employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
            employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
            employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

            ;Clean up any decimal variables

            if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
                clear employee.emp_id
            if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
                clear employee.emp_paid
            if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
                clear employee.emp_address_zip

            ;Clean up any date variables

            if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
                ^a(employee.emp_hire_date(1:1))=%char(0)
            if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
                ^a(employee.emp_date_of_birth(1:1))=%char(0)

            ;Clean up any time variables

            if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
                ^a(employee.emp_hire_time(1:1))=%char(0)

            ;Assign any time or user-defined timestamp fields

            tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

            ;Assign values to temp fields for any fields with custom data types


            try
            begin
                disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
                &    CommandTimeout = Settings.DatabaseTimeout
                &    }

                ;Bind the host variables for data to be inserted

                command.Parameters.AddWithValue("@1",employee.emp_id)
                command.Parameters.AddWithValue("@2",employee.emp_first_name)
                command.Parameters.AddWithValue("@3",employee.emp_last_name)
                command.Parameters.AddWithValue("@4",employee.emp_dept)
                command.Parameters.AddWithValue("@5",^a(employee.emp_hire_date))
                command.Parameters.AddWithValue("@6",employee.emp_phone_work)
                command.Parameters.AddWithValue("@7",employee.emp_phone_cell)
                command.Parameters.AddWithValue("@8",employee.emp_paid)
                command.Parameters.AddWithValue("@9",^a(employee.emp_date_of_birth))
                command.Parameters.AddWithValue("@10",tmpEmpHireTime)
                command.Parameters.AddWithValue("@11",employee.emp_email)
                command.Parameters.AddWithValue("@12",employee.emp_address_street)
                command.Parameters.AddWithValue("@13",employee.emp_address_city)
                command.Parameters.AddWithValue("@14",employee.emp_address_state)
                command.Parameters.AddWithValue("@15",employee.emp_address_zip)

                command.ExecuteNonQuery()
                errorMessage = ""
            end
            catch (ex, @SqlException)
            begin
                errorMessage = "Failed to insert row. Error was: " + ex.Message
                xcall ThrowOnSqlClientError(errorMessage,ex)

                clear continue

                ;Are we logging errors?
                if (Settings.TerminalChannel)
                begin
                    writes(Settings.TerminalChannel,errorMessage)
                    continue=1
                end

                ;Are we processing exceptions?
                if (^passed(a_exception))
                begin
                    if (ex_mc==ex_ms)
                    begin
                        if (!a_exception) then
                            a_exception = %mem_proc(DM_ALLOC|DM_STATIC,^size(inpbuf)*(ex_ms=EXCEPTION_BUFSZ))
                        else
                            a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*(ex_ms+=EXCEPTION_BUFSZ),a_exception)
                    end
                    ^m(inpbuf[ex_mc+=1],a_exception)=employee
                    continue=1
                end

                if (continue) then
                    nextloop
                else
                begin
                    ok = false
                    exitloop
                end
            end
            endtry
        end
    end

    ;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;If necessary, re-enable auto-commit

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Automatic)
    begin
        try
        begin
            disposable data command = new SqlCommand("SET IMPLICIT_TRANSACTIONS OFF",Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to re-enable auto-commit. Error was: " + ex.Message
            ok = false
        end
        endtry
    end

    ;If we're returning exceptions then resize the buffer to the correct size

    if (^passed(a_exception) && a_exception)
        a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*ex_mc,a_exception)

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Updates a row in the Employee table.
;;; </summary>
;;; <param name="a_data">Record containing data to update.</param>
;;; <param name="a_rows">Returned number of rows affected.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Update, ^val
    required in  a_data,   a
    optional out a_rows,   i
    required out aErrorMessage, a

    stack record local_data
        ok,             boolean     ;OK to continue
        transaction,    boolean     ;Transaction in progress
        length,         int         ;Length of a string
        rows,           int         ;Number of rows updated
        errorMessage,   string      ;Error message text
    endrecord

    literal
        sql, string, 'UPDATE Employee SET '
        & + '"EmpId"=@1,'
        & + '"EmpFirstName"=@2,'
        & + '"EmpLastName"=@3,'
        & + '"EmpDept"=@4,'
        & + '"EmpHireDate"=@5,'
        & + '"EmpPhoneWork"=@6,'
        & + '"EmpPhoneCell"=@7,'
        & + '"EmpPaid"=@8,'
        & + '"EmpDateOfBirth"=@9,'
        & + '"EmpHireTime"=@10,'
        & + '"EmpEmail"=@11,'
        & + '"EmpAddressStreet"=@12,'
        & + '"EmpAddressCity"=@13,'
        & + '"EmpAddressState"=@14,'
        & + '"EmpAddressZip"=@15'
        & + ' WHERE "EmpId"=:16  '
    endliteral

    static record
        employee, strEmployee
        tmpEmpHireTime, a5      ;Storage for HH:MM time field
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    if (^passed(a_rows))
        clear a_rows

    ;Load the data into the bound record
    employee = a_data

    ;Clean up alpha fields
    employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
    employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
    employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
    employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
    employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
    employee.emp_email = %atrim(employee.emp_email)+%char(0)
    employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
    employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
    employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

    ;Clean up decimal fields
    if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
        clear employee.emp_id
    if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
        clear employee.emp_paid
    if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
        clear employee.emp_address_zip

    ;Clean up date fields
    if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
        ^a(employee.emp_hire_date(1:1)) = %char(0)
    if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
        ^a(employee.emp_date_of_birth(1:1)) = %char(0)

    ;Clean up time fields
    if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
        ^a(employee.emp_hire_time(1:1)) = %char(0)

    ;Assign time and user-defined timestamp fields
    tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

    ;Assign values to temp fields for any fields with custom data types

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand("ROLLBACK TRANSACTION",Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }

            ;Bind the host variables for data to be updated
            command.Parameters.AddWithValue("@1",employee.emp_id)
            command.Parameters.AddWithValue("@2",employee.emp_first_name)
            command.Parameters.AddWithValue("@3",employee.emp_last_name)
            command.Parameters.AddWithValue("@4",employee.emp_dept)
            command.Parameters.AddWithValue("@5",^a(employee.emp_hire_date))
            command.Parameters.AddWithValue("@6",employee.emp_phone_work)
            command.Parameters.AddWithValue("@7",employee.emp_phone_cell)
            command.Parameters.AddWithValue("@8",employee.emp_paid)
            command.Parameters.AddWithValue("@9",^a(employee.emp_date_of_birth))
            command.Parameters.AddWithValue("@10",tmpEmpHireTime)
            command.Parameters.AddWithValue("@11",employee.emp_email)
            command.Parameters.AddWithValue("@12",employee.emp_address_street)
            command.Parameters.AddWithValue("@13",employee.emp_address_city)
            command.Parameters.AddWithValue("@14",employee.emp_address_state)
            command.Parameters.AddWithValue("@15",employee.emp_address_zip)

            ;Bind the host variables for the key segments / WHERE clause
            command.Parameters.AddWithValue("@16",employee.emp_id)

            rows = command.ExecuteNonQuery()

            if (^passed(a_rows))
                a_rows = rows
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to update row. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes a row from the Employee table.
;;; </summary>
;;; <param name="a_key">Unique key of row to be deleted.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Delete, ^val
    required in  a_key,    a
    required out aErrorMessage, a

    .include "EMPLOYEE" repository, stack record="employee"

    external function
        EmployeeKeyToRecord, a
    endexternal

    .align
    stack record local_data
        ok,             boolean     ;Return status
        cursor,         int         ;Database cursor
        transaction,    boolean     ;Transaction in progress
        errorMessage,   string      ;Error message
        sql,            string      ;SQL statement
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    ;Put the unique key value into the record
    employee = %EmployeeKeyToRecord(a_key)

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;;Delete the row
    if (ok)
    begin
        sql = 'DELETE FROM "Employee" WHERE'
        &    + ' "EmpId"=' + "'" + %string(employee.emp_id) + "' "

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to delete row. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes all rows from the Employee table.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Clear, ^val
    required out aErrorMessage, a

    .align
    stack record local_data
        ok,             boolean ;Return status
        transaction,    boolean ;Transaction in process
        errorMessage,   string  ;Returned error message text
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;;Truncate the table
    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('TRUNCATE TABLE "Employee"',Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to truncate table. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes the Employee table from the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Drop, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
    endrecord

proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Drop the database table and primary key constraint
    try
    begin
        disposable data command = new SqlCommand("DROP TABLE Employee",Settings.DatabaseConnection) { 
        &   CommandTimeout = Settings.DatabaseTimeout
        & }
        command.ExecuteNonQuery()
    end
    catch (ex, @SqlException)
    begin
        using ex.Number select
        (3701), ;Cannot drop the table 'Employee', because it does not exist or you do not have permission.
            nop
        (),
        begin
            errorMessage = "Failed to drop table. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endusing
    end
    endtry 

    ;Commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Load all data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <param name="a_added">Total number of successful inserts.</param>
;;; <param name="a_failed">Total number of failed inserts.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Load, ^val
    required in  a_maxrows, n
    required out a_added, n
    required out a_failed, n
    required out aErrorMessage, a

    .include "EMPLOYEE" repository, structure="inpbuf", end
    .include "EMPLOYEE" repository, stack record="tmprec", end

    .define BUFFER_ROWS     1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok,             boolean     ;Return status
        firstRecord,    boolean     ;Is this the first record?
        filechn,        int         ;Data file channel
        mh,             D_HANDLE    ;Memory handle containing data to insert
        ms,             int         ;Size of memory buffer in rows
        mc,             int         ;Memory buffer rows currently used
        ex_mh,          D_HANDLE    ;Memory buffer for exception records
        ex_mc,          int         ;Number of records in returned exception array
        ex_ch,          int         ;Exception log file channel
        attempted,      int         ;Rows being attempted
        done_records,   int         ;Records loaded
        max_records,    int         ;Maximum records to load
        ttl_added,      int         ;Total rows added
        ttl_failed,     int         ;Total failed inserts
        errnum,         int         ;Error number
        tmperrmsg,      a512        ;Temporary error message
        errorMessage,   string      ;Error message text
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    ;If we are logging exceptions, delete any existing exceptions file.
    if (Settings.LogBulkLoadExceptions)
    begin
        xcall delet("REPLICATOR_LOGDIR:employee_data_exceptions.log")
    end

    ;Open the data file associated with the structure
    if (!(filechn = %EmployeeOpenInput))
    begin
        ok = false
        errorMessage = "Failed to open data file!"
    end

    if (ok)
    begin
        ;Were we passed a max # records to load
        max_records = a_maxrows > 0 ? a_maxrows : 0
        done_records = 0

        ;Allocate memory buffer for the database rows
        mh = %mem_proc(DM_ALLOC,^size(inpbuf)*(ms=BUFFER_ROWS))

        ;Read records from the input file
        firstRecord = true
        repeat
        begin
            ;Get the next record from the input file
            try
            begin
                if (firstRecord) then
                begin
                    read(filechn,tmprec,^FIRST)
                    firstRecord = false
                end
                else
                begin
                    reads(filechn,tmprec)
                end
            end
            catch (ex, @EndOfFileException)
            begin
                exitloop
            end
            catch (ex, @Exception)
            begin
                ok = false
                errorMessage = "Unexpected error while reading data file: " + ex.Message
                exitloop
            end
            endtry

            ;Got one, load it into or buffer
            ^m(inpbuf[mc+=1],mh) = tmprec

            incr done_records

            ;If the buffer is full, write it to the database
            if (mc==ms)
            begin
                call insert_data
            end

            if (max_records && (done_records == max_records))
            begin
                exitloop
            end
        end

        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(inpbuf)*mc,mh)
            call insert_data
        end

        ;;Deallocate memory buffer
        mh = %mem_proc(DM_FREE,mh)
    end

    ;Close the file
    if (filechn && %chopen(filechn))
        close filechn

    ;Close the exceptions log file
    if (ex_ch && %chopen(ex_ch))
        close ex_ch

    ;Return totals
    a_added = ttl_added
    a_failed = ttl_failed

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

insert_data,

    attempted = (%mem_proc(DM_GETSIZE,mh)/^size(inpbuf))

    if (!%Employee_InsertRows(mh,tmperrmsg,ex_mh)) then
    begin
        errorMessage = %atrimtostring(tmperrmsg)
    end
    else
    begin
        ;;Any exceptions?
        if (ex_mh) then
        begin
            ;How many exceptions to log?
            ex_mc = %mem_proc(DM_GETSIZE,ex_mh) / ^size(inpbuf)

            ;Update totals
            ttl_failed += ex_mc
            ttl_added += (attempted-ex_mc)

            ;Are we logging exceptions?
            if (Settings.LogBulkLoadExceptions) then
            begin
                data cnt, int

                ;Open the log file
                if (!ex_ch)
                begin
                    open(ex_ch=0,o:s,"REPLICATOR_LOGDIR:employee_data_exceptions.log")
                end

                ;Log the exceptions
                for cnt from 1 thru ex_mc
                begin
                    writes(ex_ch,^m(inpbuf[cnt],ex_mh))
                end

                ;And maybe show them on the terminal
                if (Settings.TerminalChannel)
                begin
                    writes(Settings.TerminalChannel,"Exceptions were logged to REPLICATOR_LOGDIR:employee_data_exceptions.log")
                end
            end
            else
            begin
                ;No, report and error
                ok = false
            end

            ;Release the exception buffer
            ex_mh = %mem_proc(DM_FREE,ex_mh)
        end
        else
        begin
            ;No exceptions
            ttl_added += attempted
            if (Settings.TerminalChannel && Settings.LogLoadProgress)
            begin
                writes(Settings.TerminalChannel," - " + %string(ttl_added) + " rows inserted")
            end
        end
    end

    clear mc

    return

endfunction

;*****************************************************************************
;;; <summary>
;;; Bulk load data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table via a CSV file.
;;; </summary>
;;; <param name="a_connection">Established database connection.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_localpath">Path to local export directory</param>
;;; <param name="a_remotepath">Remote export directory or URL</param>
;;; <param name="a_db_timeout">Database timeout in seconds.</param>
;;; <param name="a_bl_timeout">Bulk load timeout in seconds.</param>
;;; <param name="a_bl_batchsz">Bulk load batch size in rows.</param>
;;; <param name="a_logchannel">Log file channel to log messages on.</param>
;;; <param name="a_records">Total number of records processed</param>
;;; <param name="a_exceptions">Total number of exception records detected</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_BulkLoad, ^val
    required in  a_connection, @SqlConnection
    required in  a_commit_mode,i
    required in  a_localpath,  a
    required in  a_server,     a
    required in  a_port,       i
    required in  a_db_timeout, n
    required in  a_bl_timeout, n
    required in  a_bl_batchsz, n
    optional in  a_logchannel, n
    optional in  a_ttchannel,  n
    optional out a_records,    n
    optional out a_exceptions, n
    optional out a_errtxt,     a

    .align
    stack record local_data
        ok, boolean
    endrecord

proc
    init local_data
    ok = false

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Close cursors associated with the Employee table.
;;; </summary>
;;; <param name="a_connection">Established database connection.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>

subroutine Employee_Close
    required in a_connection, @SqlConnection
proc

    xreturn

endsubroutine

;*****************************************************************************
;;; <summary>
;;; Exports REPLICATOR_DATA:EMPLOYEE.ISM to a CSV file.
;;; </summary>
;;; <param name="fileSpec">File to create</param>
;;; <param name="recordCount">Passed number of records to export, returned number of records exported.</param>
;;; <param name="errorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Employee_Csv, boolean
    required in    fileSpec, a
    optional inout recordCount, n
    required out   aErrorMessage, a

    .include "EMPLOYEE" repository, record="employee", end

    .align
    stack record local_data
        ok,             boolean     ;Return status
        errorMessage,   string
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty




    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

.endc
