;*****************************************************************************
;
; File:         KafkaAPI.dbl
;
; Description:  DBL wrappers for the C API to Kafka for use on Windows and Linux
;               (On OpenVMS the C functions are called directly from IoHooksKAFKA)
;
; Author:       Jeff Greene, Synergex
;
;*****************************************************************************
;
; Copyright (c) 2024, Synergex International, Inc.
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;
; * Redistributions of source code must retain the above copyright notice,
;   this list of conditions and the following disclaimer.
;
; * Redistributions in binary form must reproduce the above copyright notice,
;   this list of conditions and the following disclaimer in the documentation
;   and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;
;******************************************************************************

import ReplicationLibrary
.ifdef DBLNET
import System.Runtime.InteropServices
.endc

namespace ReplicationLibrary

    public class HookDllState
        public static DLLHandle, D_ADDR, 0 
    endclass

endnamespace

.ifndef DBLNET ;Traditional DBL code
.ifndef OS_VMS ;But not VMS

;------------------------------------------------------------------------------
;;; <summary>
;;; Connect
;;; </summary>
;;; <param name="brokers">String containing list of broker URL's (for compatibility with VMS/ZMQ)</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_startup, i4
    in brokers, a
proc
    if(HookDllState.DLLHandle == 0)
    begin
        data systemType, i4
        xcall ENVRN(systemType)
        if(systemType == 8) then
            HookDllState.DLLHandle = %dll_open("libdbl_replicator_hooks.so")
        else
            HookDllState.DLLHandle = %dll_open("dbl_replicator_hooks.dll")
    end
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_startup")
endfunction

;------------------------------------------------------------------------------
;;; <summary>
;;; Disconnect
;;; </summary>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_shutdown, i4
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1

    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_shutdown")
endfunction

;------------------------------------------------------------------------------
;;; <summary>
;;; Get the error text associated wiht the most recent failure
;;; </summary>
;;; <param name="error">Status code returned by previous failing routine</param>
;;; <param name="text">Associated error message</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_get_error, i4
    in error, i4
    out text, a
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
     
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_get_error", error, %addr(text), (i4)%size(text))
endfunction

;------------------------------------------------------------------------------
;;; <summary>
;;; Indicates that a file is being opened
;;; </summary>
;;; <param name="filename">Name of table associated with the file being opened</param>
;;; <param name="handle">Returned file handle</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_start_file, i4
    in filename, a
    out handle, i4
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
     
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_start_file", %addr(filename), (i4)%size(filename), %addr(handle))
endfunction

;------------------------------------------------------------------------------
;;; <summary>
;;; Indicates that a file is being closed
;;; </summary>
;;; <param name="handle">File handle obtained from rep_start_file</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_stop_file, i4
    in handle, i4
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
     
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_stop_file", handle)
endfunction

;------------------------------------------------------------------------------
;;; <summary>
;;; Start a transaction
;;; </summary>
;;; <param name="handle">Returned transaction handle</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_start_txn, i4
    out handle, i4
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
    
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_start_txn", %addr(handle))
endfunction

;------------------------------------------------------------------------------
;;; <summary>
;;; End a transaction
;;; </summary>
;;; <param name="handle">Transaction handle obtained from rep_start_txn</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_stop_txn, i4
    in handle, i4
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
    
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_stop_txn", handle)
endfunction

;------------------------------------------------------------------------------
;;; <summary>
;;; Write a instruction
;;; </summary>
;;; <param name="fileHandle">File handle obtained from rep_start_file</param>
;;; <param name="opType"></param>
;;; <param name="keyData"></param>
;;; <param name="recordData"></param>
;;; <param name="originalData"></param>
;;; <param name="txn"></param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_write_op, i4
    in fileHandle, i4
    in opType, i4
    in keyData, a
    in recordData, a
    optional in originalData, a
    optional in txn, i4
    stack record
        originalDataPtr, D_ADDR
        originalDataLength, i4
        cleanTxn, i4
    endrecord
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
    
    if(^passed(originalData)) then
    begin
        originalDataPtr = %addr(originalData)
        originalDataLength = %size(originalData)
    end
    else
    begin
        originalDataPtr = 0
        originalDataLength = 0
    end

    if(^passed(txn)) then
        cleanTxn = txn
    else
        cleanTxn = 0

    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_write_op", fileHandle, opType, %addr(keyData), (i4)%size(keyData), 
    &   %addr(recordData), (i4)%size(recordData), originalDataPtr, originalDataLength, cleanTxn)
endfunction

.endc ;Not VMS
.else ;Now DBLNET code

namespace ReplicationLibrary

    public class HookPInvokeSigs

        {DllImport("dbl_replicator_hooks")}
        public static method rep_startup, int
        proc
        endmethod

        {DllImport("dbl_replicator_hooks")}
        public static method rep_shutdown, int
        proc
        endmethod

        {DllImport("dbl_replicator_hooks")}
        public static method rep_get_error, int
            errorCode, int
            errorPtr, IntPtr
            errorBufferSize, int
        proc
        endmethod

        {DllImport("dbl_replicator_hooks")}
        public static method rep_start_file, int
            fileNamePtr, IntPtr
            fileNameSize, int
            out fileHandle, int
        proc
        endmethod

        {DllImport("dbl_replicator_hooks")}
        public static method rep_stop_file, int
            fileHandle, int
        proc
        endmethod

        {DllImport("dbl_replicator_hooks")}
        public static method rep_start_txn, int
            out txnHandle, int
        proc
        endmethod

        {DllImport("dbl_replicator_hooks")}
        public static method rep_stop_txn, int
            txnHandle, int
        proc
        endmethod

        {DllImport("dbl_replicator_hooks")}
        public static method rep_write_op, int
            fileHandle, int
            opType, int
            keyPtr, IntPtr
            keySize, int
            recordPtr, IntPtr
            recordSize, int
            originalPtr, IntPtr
            originalSize, int
            txnHandle, int
        proc
        endmethod
    endclass

endnamespace

function rep_startup, i4
    in brokers, a
proc
    freturn HookPInvokeSigs.rep_startup()
endfunction

function rep_shutdown, i4
proc
    freturn HookPInvokeSigs.rep_shutdown()
endfunction

function rep_get_error, i4
    in error, i4
    out text, a
proc
    freturn HookPInvokeSigs.rep_get_error(error, %addr(text), (i4)%size(text))
endfunction

function rep_start_file, i4
    in filename, a
    out handle, int
proc
    freturn HookPInvokeSigs.rep_start_file(%addr(filename), (i4)%size(filename), handle)
endfunction

function rep_stop_file, i4
    in handle, i4
proc
    freturn HookPInvokeSigs.rep_stop_file(handle)
endfunction

function rep_start_txn, i4
    out handle, int
proc
    freturn HookPInvokeSigs.rep_start_txn(handle)
endfunction

function rep_stop_txn, i4
    in handle, i4
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
    
    freturn HookPInvokeSigs.rep_stop_txn(handle)
endfunction

function rep_write_op, i4
    in fileHandle, i4
    in opType, I4
    in keyData, A
    in recordData, A
    optional in originalData, A
    optional in txn, i4
    record
        originalDataPtr, D_ADDR
        originalDataLength, i4
        cleanTxn, i4
proc
    if(^passed(originalData)) then
    begin
        originalDataPtr = %addr(originalData)
        originalDataLength = %size(originalData)
    end
    else
    begin
        originalDataPtr = 0
        originalDataLength = 0
    end

    if(^passed(txn)) then
        cleanTxn = txn
    else
        cleanTxn = 0

    freturn HookPInvokeSigs.rep_write_op(fileHandle, opType, %addr(keyData), (i4)%size(keyData), 
    &   %addr(recordData), (i4)%size(recordData), originalDataPtr, originalDataLength, cleanTxn)
endfunction

.endc