;;*****************************************************************************
;;
;; File:        KafkaAPI.dbl
;;
;; Description: DBL wrappers for the C API to Kafka for use on Windows and Linux
;;              (On OpenVMS the C functions are called directly from IoHooksKAFKA)
;;
;; Author:      Jeff Greene, Synergex
;;
;;*****************************************************************************
;;
;; Copyright (c) 2024, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import ReplicationLibrary

namespace ReplicationLibrary

    public class HookDllState
        public static DLLHandle, D_ADDR, 0 
    endclass

endnamespace

.ifndef OS_VMS

;;-----------------------------------------------------------------------------
;;; <summary>
;;; Connect
;;; </summary>
;;; <param name="brokers">String containing list of broker URL's (for compatibility with VMS/ZMQ)</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_startup_zmq, i4
    in brokers, a
proc
    if(HookDllState.DLLHandle == 0)
    begin
        data systemType, i4
        xcall envrn(systemType)
        if(systemType == 8) then
            HookDllState.DLLHandle = %dll_open("libdbl_replicator_hooks.so")
        else
            HookDllState.DLLHandle = %dll_open("dbl_replicator_hooks.dll")
    end
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_startup")
endfunction

;;-----------------------------------------------------------------------------
;;; <summary>
;;; Disconnect
;;; </summary>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_shutdown_zmq, i4
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1

    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_shutdown")
endfunction

;;-----------------------------------------------------------------------------
;;; <summary>
;;; Indicates that a file is being opened
;;; </summary>
;;; <param name="filename">Name of table associated with the file being opened</param>
;;; <param name="handle">Returned file handle</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_start_file, i4
    in filename, a
    out handle, i4
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
     
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_start_file", %addr(filename), (i4)%size(filename), %addr(handle))
endfunction

;;-----------------------------------------------------------------------------
;;; <summary>
;;; Indicates that a file is being closed
;;; </summary>
;;; <param name="handle">File handle obtained from rep_start_file</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_stop_file, i4
    in handle, i4
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
     
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_stop_file", handle)
endfunction

;;-----------------------------------------------------------------------------
;;; <summary>
;;; Write a instruction
;;; </summary>
;;; <param name="fileHandle">File handle obtained from rep_start_file</param>
;;; <param name="opType"></param>
;;; <param name="keyData"></param>
;;; <param name="recordData"></param>
;;; <param name="originalData"></param>
;;; <param name="txn"></param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_write_op, i4
    in fileHandle, i4
    in opType, i4
    in keyData, a
    in recordData, a
    optional in originalData, a
    optional in txn, i4
    stack record
        originalDataPtr, D_ADDR
        originalDataLength, i4
        cleanTxn, i4
    endrecord
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
    
    if(^passed(originalData)) then
    begin
        originalDataPtr = %addr(originalData)
        originalDataLength = %size(originalData)
    end
    else
    begin
        originalDataPtr = 0
        originalDataLength = 0
    end

    if(^passed(txn)) then
        cleanTxn = txn
    else
        cleanTxn = 0

    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_write_op", fileHandle, opType, %addr(keyData), (i4)%size(keyData), 
    &   %addr(recordData), (i4)%size(recordData), originalDataPtr, originalDataLength, cleanTxn)

endfunction

;;-----------------------------------------------------------------------------
;;; <summary>
;;; Start a transaction
;;; </summary>
;;; <param name="handle">Returned transaction handle</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_start_txn, i4
    out handle, i4
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
    
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_start_txn", %addr(handle))
endfunction

;;-----------------------------------------------------------------------------
;;; <summary>
;;; End a transaction
;;; </summary>
;;; <param name="handle">Transaction handle obtained from rep_start_txn</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_stop_txn, i4
    in handle, i4
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
    
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_stop_txn", handle)
endfunction

;;-----------------------------------------------------------------------------
;;; <summary>
;;; Get the error text associated wiht the most recent failure
;;; </summary>
;;; <param name="error">Status code returned by previous failing routine</param>
;;; <param name="text">Associated error message</param>
;;; <returns>Returns 0 on success, otherwise an error number</returns>

function rep_get_error, i4
    in error, i4
    out text, a
proc
    if(HookDllState.DLLHandle == 0)
        freturn -1
     
    freturn %dll_call(HookDllState.DLLHandle, DLL_TYPE_C, "rep_get_error", error, %addr(text), (i4)%size(text))
endfunction

.endc
