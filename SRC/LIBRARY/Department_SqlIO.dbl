;*****************************************************************************
;
; File:        Department_SqlIO.dbl
;
; Description: Various functions that performs SQL I/O for DEPARTMENT
;
;*****************************************************************************
; WARNING: THIS CODE WAS CODE GENERATED AND WILL BE OVERWRITTEN IF CODE
;          GENERATION IS RE-EXECUTED FOR THIS PROJECT.
;*****************************************************************************

.ifndef DBLNET
 ;This code was generated from the SqlClientIO template and can only be used
 ;in .NET. For traditional DBL environments use the SqlIO template
.else

import ReplicationLibrary
import Synergex.SynergyDE.Select
import System.Data.SqlClient

.ifndef strDepartment
.include "DEPARTMENT" repository, structure="strDepartment", end
.endc

.define writelog(x) if Settings.LogFileChannel && %chopen(Settings.LogFileChannel) writes(Settings.LogFileChannel,%string(^d(now(1:14)),"XXXX-XX-XX XX:XX:XX ") + x)
.define writett(x)  if Settings.TerminalChannel writes(Settings.TerminalChannel,"   - " + %string(^d(now(9:8)),"XX:XX:XX.XX ") + x)

;*****************************************************************************
;;; <summary>
;;; Determines if the Department table exists in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns 1 if the table exists, otherwise a number indicating the type of error.</returns>

function Department_Exists, ^val
    required out aErrorMessage, a

    stack record
        error, int
        errorMessage, string
    endrecord
proc
    error = 0
    errorMessage = String.Empty

    try
    begin
        disposable data command = new SqlCommand("SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='Department'",Settings.DatabaseConnection) { 
        &   CommandTimeout = Settings.DatabaseTimeout
        & }
        disposable data reader = command.ExecuteReader()
        if (reader.Read()) then
        begin
            ;Table exists
            error = 1
        end
        else
        begin
            errorMessage = "Table not found"
            error = 0
        end
    end
    catch (ex, @SqlException)
    begin
        errorMessage = ex.Message
        error = -1
        xcall ThrowOnSqlClientError(errorMessage,ex)
    end
    endtry

    ;Return any error message to the calling routine
    aErrorMessage = error == 1 ? String.Empty : errorMessage

    freturn error

endfunction

;*****************************************************************************
;;; <summary>
;;; Creates the Department table in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department_Create, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
    endrecord
    static record
        createTableCommand, string
    endrecord
proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Define the CREATE TABLE statement

    if (ok && createTableCommand == ^null)
    begin
        createTableCommand = 'CREATE TABLE "Department" ('
        & + '"DeptId" VARCHAR(15) NOT NULL,'
        & + '"DeptName" VARCHAR(50) NOT NULL,'
        & + '"DeptManager" DECIMAL(6) NOT NULL,'
        & + 'CONSTRAINT PK_Department PRIMARY KEY CLUSTERED("DeptId" ASC)'
        & + ')'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            createTableCommand = createTableCommand + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            createTableCommand = createTableCommand + " WITH(DATA_COMPRESSION=ROW)"
        endusing
    end

    ;Create the database table and primary key constraint

    try
    begin
        disposable data command = new SqlCommand(createTableCommand,Settings.DatabaseConnection) { 
        &   CommandTimeout = Settings.DatabaseTimeout
        & }
        command.ExecuteNonQuery()
    end
    catch (ex, @SqlException)
    begin
        ok = false
        errorMessage = "Failed to create table. Error was: " + ex.Message
    end
    endtry 

    ;Grant access permissions

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('GRANT ALL ON "Department" TO PUBLIC',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to grant table permissions. Error was: " + ex.Message
        end
        endtry
    end

    ;Commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Add alternate key indexes to the Department table if they do not exist.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department_Index, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
        now, a20
    endrecord

proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Create index 1 (Department manager)

    if (ok && !%Index_Exists("IX_Department_DeptManager"))
    begin
        data sql = 'CREATE  INDEX IX_Department_DeptManager ON "Department"("DeptManager" ASC)'

        using Settings.DataCompressionMode select
        (DatabaseDataCompression.Page),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        (DatabaseDataCompression.Row),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        endusing

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.BulkLoadTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to create index IX_Department_DeptManager. Error was: " + ex.Message
        end
        endtry 

        now = %datetime

        if (ok) then
        begin
            writelog(" - Added index IX_Department_DeptManager")
        end
        else
        begin
            writelog(" - ERROR: " + errorMessage)
            ok = true
        end
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Removes alternate key indexes from the Department table in the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department_UnIndex, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
    endrecord

proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Drop index 1 (Department manager)

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('DROP INDEX IF EXISTS IX_Department_DeptManager ON "Department"',Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            errorMessage = "Failed to drop index IX_Department_DeptManager. Error was: " + ex.Message
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Insert a row into the Department table.
;;; </summary>
;;; <param name="a_data">Record to be inserted.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns 1 if the row was inserted, 2 to indicate the row already exists, or 0 if an error occurred.</returns>

function Department_Insert, ^val
    required in  a_data,   a
    required out aErrorMessage, a

    .align
    stack record local_data
        ok          ,boolean    ;OK to continue
        sts         ,int        ;Return status
        transaction ,boolean    ;Transaction in progress
        errorMessage,string     ;Error message text
    endrecord

    literal
        sql, string, "INSERT INTO Department ("
        & + '"DeptId",'
        & + '"DeptName",'
        & + '"DeptManager"'
        & + ") VALUES(@1,@2,@3)"
    endliteral

    static record
        department, strDepartment
    endrecord

proc
    init local_data
    ok = true
    sts = 1

    if (ok)
    begin
        ;Load the data into the bound record

        department = a_data

        ;Clean up any alpha fields

        department.dept_name = %atrim(department.dept_name)+%char(0)

        ;Clean up any decimal fields

        if ((!department.dept_manager)||(!%IsDecimalNoNegatives(department.dept_manager)))
            clear department.dept_manager

        ;Clean up any date fields


        ;Clean up any time fields


        ;Assign data to any temporary time or user-defined timestamp fields


        ;Assign values to temp fields for any fields with custom data types

    end

    ;If we're in manual commit mode, start a transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &   CommandTimeout = Settings.DatabaseTimeout
            & }

            command.Parameters.AddWithValue("@1",department.dept_id)
            command.Parameters.AddWithValue("@2",department.dept_name)
            command.Parameters.AddWithValue("@3",department.dept_manager)

            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            ok = false
            sts = 0
            using ex.ErrorCode Select
            (-2627),    ;TODO: * * * MAY NOT BE THE CORRECT ERROR NUMBER FOR DUPLICATE KEY
            begin
                ;Duplicate key
                errorMessage = "Duplicate key detected in database!"
                sts = 2
            end
            (),
            begin
                errorMessage = "Failed to insert row into Department. Error was: " + ex.Message
            end
            endusing
            xcall ThrowOnSqlClientError(errorMessage,ex)
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn sts

endfunction

;*****************************************************************************
;;; <summary>
;;; Inserts multiple rows into the Department table.
;;; </summary>
;;; <param name="a_data">Memory handle containing one or more rows to insert.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <param name="a_exception">Memory handle to load exception data records into.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department_InsertRows, ^val
    required in  a_data, i
    required out aErrorMessage, a
    optional out a_exception, i

    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok,             boolean     ;Return status
        rows,           int         ;Number of rows to insert
        transaction,    boolean     ;Transaction in progress
        length,         int         ;Length of a string
        ex_ms,          int         ;Size of exception array
        ex_mc,          int         ;Items in exception array
        continue,       int         ;Continue after an error
        errorMessage,   string      ;Error message text
    endrecord

    literal
        sql, string, "INSERT INTO Department ("
        & + '"DeptId",'
        & + '"DeptName",'
        & + '"DeptManager"'
        & + ") VALUES(@1,@2,@3)"
    endliteral

    .include "DEPARTMENT" repository, structure="inpbuf", nofields, end
    .include "DEPARTMENT" repository, static record="department", end

    static record
        , a1                        ;In case there are no user timestamp, date or JJJJJJ date fields
    endrecord
proc
    init local_data
    ok = true
    errorMessage = String.Empty

    if (^passed(a_exception) && a_exception)
        clear a_exception

    ;Figure out how many rows to insert

    rows = (%mem_proc(DM_GETSIZE,a_data) / ^size(inpbuf))

    ;If enabled, disable auto-commit

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Automatic)
    begin
        try
        begin
            disposable data command = new SqlCommand("SET IMPLICIT_TRANSACTIONS ON",Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to disable auto-commit. Error was: " + ex.Message
            ok = false
        end
        endtry
    end

    ;Start a database transaction

    if (ok)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Insert the rows into the database

    if (ok)
    begin
        data cnt, int
        for cnt from 1 thru rows
        begin
            ;Load data into bound record

            department = ^m(inpbuf[cnt],a_data)

            ;Clean up any alpha variables

            department.dept_name = %atrim(department.dept_name)+%char(0)

            ;Clean up any decimal variables

            if ((!department.dept_manager)||(!%IsDecimalNoNegatives(department.dept_manager)))
                clear department.dept_manager

            ;Clean up any date variables


            ;Clean up any time variables


            ;Assign any time or user-defined timestamp fields


            ;Assign values to temp fields for any fields with custom data types


            try
            begin
                disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
                &    CommandTimeout = Settings.DatabaseTimeout
                &    }

                ;Bind the host variables for data to be inserted

                command.Parameters.AddWithValue("@1",department.dept_id)
                command.Parameters.AddWithValue("@2",department.dept_name)
                command.Parameters.AddWithValue("@3",department.dept_manager)

                command.ExecuteNonQuery()
                errorMessage = ""
            end
            catch (ex, @SqlException)
            begin
                errorMessage = "Failed to insert row. Error was: " + ex.Message
                xcall ThrowOnSqlClientError(errorMessage,ex)

                clear continue

                ;Are we logging errors?
                if (Settings.TerminalChannel)
                begin
                    writes(Settings.TerminalChannel,errorMessage)
                    continue=1
                end

                ;Are we processing exceptions?
                if (^passed(a_exception))
                begin
                    if (ex_mc==ex_ms)
                    begin
                        if (!a_exception) then
                            a_exception = %mem_proc(DM_ALLOC|DM_STATIC,^size(inpbuf)*(ex_ms=EXCEPTION_BUFSZ))
                        else
                            a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*(ex_ms+=EXCEPTION_BUFSZ),a_exception)
                    end
                    ^m(inpbuf[ex_mc+=1],a_exception)=department
                    continue=1
                end

                if (continue) then
                    nextloop
                else
                begin
                    ok = false
                    exitloop
                end
            end
            endtry
        end
    end

    ;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;If necessary, re-enable auto-commit

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Automatic)
    begin
        try
        begin
            disposable data command = new SqlCommand("SET IMPLICIT_TRANSACTIONS OFF",Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to re-enable auto-commit. Error was: " + ex.Message
            ok = false
        end
        endtry
    end

    ;If we're returning exceptions then resize the buffer to the correct size

    if (^passed(a_exception) && a_exception)
        a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*ex_mc,a_exception)

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Updates a row in the Department table.
;;; </summary>
;;; <param name="a_data">Record containing data to update.</param>
;;; <param name="a_rows">Returned number of rows affected.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department_Update, ^val
    required in  a_data,   a
    optional out a_rows,   i
    required out aErrorMessage, a

    stack record local_data
        ok,             boolean     ;OK to continue
        transaction,    boolean     ;Transaction in progress
        length,         int         ;Length of a string
        rows,           int         ;Number of rows updated
        errorMessage,   string      ;Error message text
    endrecord

    literal
        sql, string, 'UPDATE Department SET '
        & + '"DeptId"=@1,'
        & + '"DeptName"=@2,'
        & + '"DeptManager"=@3'
        & + ' WHERE "DeptId"=:4  '
    endliteral

    static record
        department, strDepartment
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    if (^passed(a_rows))
        clear a_rows

    ;Load the data into the bound record
    department = a_data

    ;Clean up alpha fields
    department.dept_name = %atrim(department.dept_name)+%char(0)

    ;Clean up decimal fields
    if ((!department.dept_manager)||(!%IsDecimalNoNegatives(department.dept_manager)))
        clear department.dept_manager

    ;Clean up date fields

    ;Clean up time fields

    ;Assign time and user-defined timestamp fields

    ;Assign values to temp fields for any fields with custom data types

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand("ROLLBACK TRANSACTION",Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }

            ;Bind the host variables for data to be updated
            command.Parameters.AddWithValue("@1",department.dept_id)
            command.Parameters.AddWithValue("@2",department.dept_name)
            command.Parameters.AddWithValue("@3",department.dept_manager)

            ;Bind the host variables for the key segments / WHERE clause
            command.Parameters.AddWithValue("@4",department.dept_id)

            rows = command.ExecuteNonQuery()

            if (^passed(a_rows))
                a_rows = rows
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to update row. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes a row from the Department table.
;;; </summary>
;;; <param name="a_key">Unique key of row to be deleted.</param>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department_Delete, ^val
    required in  a_key,    a
    required out aErrorMessage, a

    .include "DEPARTMENT" repository, stack record="department"

    external function
        DepartmentKeyToRecord, a
    endexternal

    .align
    stack record local_data
        ok,             boolean     ;Return status
        cursor,         int         ;Database cursor
        transaction,    boolean     ;Transaction in progress
        errorMessage,   string      ;Error message
        sql,            string      ;SQL statement
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    ;Put the unique key value into the record
    department = %DepartmentKeyToRecord(a_key)

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;;Delete the row
    if (ok)
    begin
        sql = 'DELETE FROM "Department" WHERE'
        & + ' "DeptId"=' + "'" + %atrim(department.dept_id) + "' "

        try
        begin
            disposable data command = new SqlCommand(sql,Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to delete row. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes all rows from the Department table.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department_Clear, ^val
    required out aErrorMessage, a

    .align
    stack record local_data
        ok,             boolean ;Return status
        transaction,    boolean ;Transaction in process
        errorMessage,   string  ;Returned error message text
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;;Truncate the table
    if (ok)
    begin
        try
        begin
            disposable data command = new SqlCommand('TRUNCATE TABLE "Department"',Settings.DatabaseConnection) { 
            &    CommandTimeout = Settings.DatabaseTimeout
            &    }
            command.ExecuteNonQuery()
        end
        catch (ex, @SqlException)
        begin
            errorMessage = "Failed to truncate table. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endtry
    end

    ;If we're in manual commit mode, commit or rollback the transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes the Department table from the database.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department_Drop, ^val
    required out aErrorMessage, a

    .align
    stack record
        ok, boolean
        transaction, boolean
        errorMessage, string
    endrecord

proc
    ok = true
    transaction = false
    errorMessage = String.Empty

    ;If we're in manual commit mode, start a transaction
    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual)
    begin
        ok = %StartTransactionSqlClient(transaction,errorMessage)
    end

    ;Drop the database table and primary key constraint
    try
    begin
        disposable data command = new SqlCommand("DROP TABLE Department",Settings.DatabaseConnection) { 
        &   CommandTimeout = Settings.DatabaseTimeout
        & }
        command.ExecuteNonQuery()
    end
    catch (ex, @SqlException)
    begin
        using ex.Number select
        (3701), ;Cannot drop the table 'Department', because it does not exist or you do not have permission.
            nop
        (),
        begin
            errorMessage = "Failed to drop table. Error was: " + ex.Message
            xcall ThrowOnSqlClientError(errorMessage,ex)
            ok = false
        end
        endusing
    end
    endtry 

    ;Commit or rollback the transaction

    if (Settings.DatabaseCommitMode == DatabaseCommitMode.Manual && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            ok = %CommitTransactionSqlClient(errorMessage)
        end
        else
        begin
            ;There was an error, rollback the transaction
            ok = %RollbackTransactionSqlClient(errorMessage)
        end
    end

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Load all data from REPLICATOR_DATA:DEPARTMENT.ISM into the Department table.
;;; </summary>
;;; <param name="aErrorMessage">Returned error text.</param>
;;; <param name="a_added">Total number of successful inserts.</param>
;;; <param name="a_failed">Total number of failed inserts.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department_Load, ^val
    required in  a_maxrows, n
    required out a_added, n
    required out a_failed, n
    required out aErrorMessage, a

    .include "DEPARTMENT" repository, structure="inpbuf", end
    .include "DEPARTMENT" repository, stack record="tmprec", end

    .define BUFFER_ROWS     1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok,             boolean     ;Return status
        firstRecord,    boolean     ;Is this the first record?
        filechn,        int         ;Data file channel
        mh,             D_HANDLE    ;Memory handle containing data to insert
        ms,             int         ;Size of memory buffer in rows
        mc,             int         ;Memory buffer rows currently used
        ex_mh,          D_HANDLE    ;Memory buffer for exception records
        ex_mc,          int         ;Number of records in returned exception array
        ex_ch,          int         ;Exception log file channel
        attempted,      int         ;Rows being attempted
        done_records,   int         ;Records loaded
        max_records,    int         ;Maximum records to load
        ttl_added,      int         ;Total rows added
        ttl_failed,     int         ;Total failed inserts
        errnum,         int         ;Error number
        tmperrmsg,      a512        ;Temporary error message
        errorMessage,   string      ;Error message text
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty

    ;If we are logging exceptions, delete any existing exceptions file.
    if (Settings.LogBulkLoadExceptions)
    begin
        xcall delet("REPLICATOR_LOGDIR:department_data_exceptions.log")
    end

    ;Open the data file associated with the structure
    if (!(filechn = %DepartmentOpenInput))
    begin
        ok = false
        errorMessage = "Failed to open data file!"
    end

    if (ok)
    begin
        ;Were we passed a max # records to load
        max_records = a_maxrows > 0 ? a_maxrows : 0
        done_records = 0

        ;Allocate memory buffer for the database rows
        mh = %mem_proc(DM_ALLOC,^size(inpbuf)*(ms=BUFFER_ROWS))

        ;Read records from the input file
        firstRecord = true
        repeat
        begin
            ;Get the next record from the input file
            try
            begin
                if (firstRecord) then
                begin
                    read(filechn,tmprec,^FIRST)
                    firstRecord = false
                end
                else
                begin
                    reads(filechn,tmprec)
                end
            end
            catch (ex, @EndOfFileException)
            begin
                exitloop
            end
            catch (ex, @Exception)
            begin
                ok = false
                errorMessage = "Unexpected error while reading data file: " + ex.Message
                exitloop
            end
            endtry

            ;Got one, load it into or buffer
            ^m(inpbuf[mc+=1],mh) = tmprec

            incr done_records

            ;If the buffer is full, write it to the database
            if (mc==ms)
            begin
                call insert_data
            end

            if (max_records && (done_records == max_records))
            begin
                exitloop
            end
        end

        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(inpbuf)*mc,mh)
            call insert_data
        end

        ;;Deallocate memory buffer
        mh = %mem_proc(DM_FREE,mh)
    end

    ;Close the file
    if (filechn && %chopen(filechn))
        close filechn

    ;Close the exceptions log file
    if (ex_ch && %chopen(ex_ch))
        close ex_ch

    ;Return totals
    a_added = ttl_added
    a_failed = ttl_failed

    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

insert_data,

    attempted = (%mem_proc(DM_GETSIZE,mh)/^size(inpbuf))

    if (!%Department_InsertRows(mh,tmperrmsg,ex_mh)) then
    begin
        errorMessage = %atrimtostring(tmperrmsg)
    end
    else
    begin
        ;;Any exceptions?
        if (ex_mh) then
        begin
            ;How many exceptions to log?
            ex_mc = %mem_proc(DM_GETSIZE,ex_mh) / ^size(inpbuf)

            ;Update totals
            ttl_failed += ex_mc
            ttl_added += (attempted-ex_mc)

            ;Are we logging exceptions?
            if (Settings.LogBulkLoadExceptions) then
            begin
                data cnt, int

                ;Open the log file
                if (!ex_ch)
                begin
                    open(ex_ch=0,o:s,"REPLICATOR_LOGDIR:department_data_exceptions.log")
                end

                ;Log the exceptions
                for cnt from 1 thru ex_mc
                begin
                    writes(ex_ch,^m(inpbuf[cnt],ex_mh))
                end

                ;And maybe show them on the terminal
                if (Settings.TerminalChannel)
                begin
                    writes(Settings.TerminalChannel,"Exceptions were logged to REPLICATOR_LOGDIR:department_data_exceptions.log")
                end
            end
            else
            begin
                ;No, report and error
                ok = false
            end

            ;Release the exception buffer
            ex_mh = %mem_proc(DM_FREE,ex_mh)
        end
        else
        begin
            ;No exceptions
            ttl_added += attempted
            if (Settings.TerminalChannel && Settings.LogLoadProgress)
            begin
                writes(Settings.TerminalChannel," - " + %string(ttl_added) + " rows inserted")
            end
        end
    end

    clear mc

    return

endfunction

;*****************************************************************************
;;; <summary>
;;; Bulk load data from REPLICATOR_DATA:DEPARTMENT.ISM into the Department table via a CSV file.
;;; </summary>
;;; <param name="a_connection">Established database connection.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_localpath">Path to local export directory</param>
;;; <param name="a_remotepath">Remote export directory or URL</param>
;;; <param name="a_db_timeout">Database timeout in seconds.</param>
;;; <param name="a_bl_timeout">Bulk load timeout in seconds.</param>
;;; <param name="a_bl_batchsz">Bulk load batch size in rows.</param>
;;; <param name="a_logchannel">Log file channel to log messages on.</param>
;;; <param name="a_records">Total number of records processed</param>
;;; <param name="a_exceptions">Total number of exception records detected</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department_BulkLoad, ^val
    required in  a_connection, @SqlConnection
    required in  a_commit_mode,i
    required in  a_localpath,  a
    required in  a_server,     a
    required in  a_port,       i
    required in  a_db_timeout, n
    required in  a_bl_timeout, n
    required in  a_bl_batchsz, n
    optional in  a_logchannel, n
    optional in  a_ttchannel,  n
    optional out a_records,    n
    optional out a_exceptions, n
    optional out a_errtxt,     a

    .align
    stack record local_data
        ok, boolean
    endrecord

proc
    init local_data
    ok = false

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Close cursors associated with the Department table.
;;; </summary>
;;; <param name="a_connection">Established database connection.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>

subroutine Department_Close
    required in a_connection, @SqlConnection
proc

    xreturn

endsubroutine

;*****************************************************************************
;;; <summary>
;;; Exports REPLICATOR_DATA:DEPARTMENT.ISM to a CSV file.
;;; </summary>
;;; <param name="fileSpec">File to create</param>
;;; <param name="recordCount">Passed number of records to export, returned number of records exported.</param>
;;; <param name="errorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department_Csv, boolean
    required in    fileSpec, a
    optional inout recordCount, n
    required out   aErrorMessage, a

    .include "DEPARTMENT" repository, record="department", end

    .align
    stack record local_data
        ok,             boolean     ;Return status
        errorMessage,   string
    endrecord

proc
    init local_data
    ok = true
    errorMessage = String.Empty




    ;Return any error message to the calling routine
    aErrorMessage = ok ? String.Empty : errorMessage

    freturn ok

endfunction

.endc
