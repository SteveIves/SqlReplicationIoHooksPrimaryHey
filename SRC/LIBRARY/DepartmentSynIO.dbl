;*****************************************************************************
;
; File:        DepartmentSynIO.dbl
;
; Description: Various functions that performs SDMS I/O for DEPARTMENT
;              to replicated SDMS data files.
;
;*****************************************************************************
;
; The following functions are identical to and therefor use the code from the
; SQL Connection replication code in DepartmentSqlIO.dbl
;
;   %DepartmentKeyVal
;   %DepartmentKeyNum
;   %DepartmentLength
;   %DepartmentType
;   %DepartmentCols
;   %DepartmentRecs
;
; In addition, there is no concept of load vs bulk load for SDMS replication,
; so the replicator calls %Department$Load for both operations.
;
;*****************************************************************************
; WARNING: THIS CODE WAS CODE GENERATED AND WILL BE OVERWRITTEN IF CODE
;          GENERATION IS RE-EXECUTED FOR THIS PROJECT.
;*****************************************************************************

.ifndef DBLNET
 ;This code was generated from the SqlClientIO template and can only be used
 ;in .NET. For traditional DBL environments use the SqlIO template
.else

import ReplicationLibrary
import Synergex.SynergyDE.Select
.ifdef DBLNET
import System.IO
.endc
import System.Text

.ifndef strDepartment
.include "DEPARTMENT" repository, structure="strDepartment", end
.endc

.define writelog(x) if Settings.LogFileChannel && %chopen(Settings.LogFileChannel) writes(Settings.LogFileChannel,%string(^d(now(1:14)),"XXXX-XX-XX XX:XX:XX") + " " + x)
.define writett(x)  if Settings.TerminalChannel writes(Settings.TerminalChannel,"   - " + %string(^d(now(9:8)),"XX:XX:XX.XX") + " " + x)

;*****************************************************************************
;;; <summary>
;;; Determines if REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM exists in the replicated data set.
;;; </summary>
;;; <param name="useTempFile">Use temporary file (not currently implemented).</param>
;;; <param name="errorMessage">Returned error message.</param>
;;; <returns>Returns 1 if the file exists and 0 if it does not.</returns>

function Department$Exists, ^val
    required in useTempFile, n ;Not currently implemented
    required out errorMessage, a

    stack record
        ok, boolean
    endrecord
proc
    ok = true
    errorMessage = ""

    if (!ReplicationLibrary.File.Exists("REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM"))
    begin
        ok = false
        errorMessage = "File REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM does not exist!"
    end

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Creates REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM in the replicated data set.
;;; </summary>
;;; <param name="useTempFile">Use temporary file (not currently implemented).</param>
;;; <param name="errorMessage">Returned error message.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department$Create, ^val
    required in useTempFile, n ;Not currently implemented
    required out errorMessage, a

.align
    stack record localData
        ok,     boolean     ;Return status
    endrecord

proc
    init localData
    ok = true
    errorMessage = ""

    try
    begin
        xcall isamc("REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM,FIXED,COMPRESS,DENSITY=50,PAGE=1024",100,2,
        &    "START=1,LENGTH=15,NAME=DEPT_ID,ASCEND,DENSITY=50,DUPS,NOATEND,NOMODIFY",
        &    "START=66,LENGTH=8,NAME=DEPT_MANAGER,TYPE=DECIMAL,ORDER=A,DENSITY=50,NODUPS,MODIFY"
        &    )
    end
    catch (ex, @Exception)
    begin
        ok = false
        errorMessage = "Failed to create REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM. Error was " + ex.Message
    end
    endtry

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Not used in the SDMS replication use case.
;;; </summary>
;;; <param name="errorMessage">Returned error message.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department$Index, ^val
    required out errorMessage, a
proc
    errorMessage = ""
    freturn true
endfunction

;*****************************************************************************
;;; <summary>
;;; Not used in the SDMS replication use case.
;;; </summary>
;;; <param name="errorMessage">Returned error message.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department$UnIndex, ^val
    required out errorMessage, a
proc
    errorMessage = ""
    freturn true
endfunction

;*****************************************************************************
;;; <summary>
;;; Insert a record into REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM.
;;; </summary>
;;; <param name="recordData">Record to be inserted.</param>
;;; <param name="errorMessage">Returned error message.</param>
;;; <returns>Returns 1 if the row was inserted, 2 to indicate the row already exists, or 0 if an error occurred.</returns>

function Department$Insert, ^val
    required in  recordData,   a
    required out errorMessage, a

    .align
    stack record localData
        status, int
    endrecord

    global common
        chDepartment, int
    endcommon

proc
    ;Make sure the channel is open

    if (!chDepartment)
    begin
        chDepartment = DepartmentOpenUpdate(errorMessage)
        if (!chDepartment)
        begin
            errorMessage = "Failed to open REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM. Error was: " + %atrim(errorMessage)
            freturn 0
        end
    end

    init localData
    status = 1
    errorMessage = ""

    try
    begin
        store(chDepartment,recordData)
    end
    catch (ex, @DuplicateException)
    begin
        status = 2
        errorMessage = "Record already exists!"
    end
    catch (ex, @Exception)
    begin
        status = 0
        errorMessage = "Failed to insert record. Error was " + ex.Message
    end
    endtry

    freturn status

endfunction

;*****************************************************************************
;;; <summary>
;;; Inserts multiple records into REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM.
;;; </summary>
;;; <param name="recordsHandle">Memory handle containing one or more rows to insert.</param>
;;; <param name="errorMessage">Returned error text.</param>
;;; <param name="exceptionRecordsHandle">Memory handle to load exception data records into.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department$InsertRows, ^val
    required in  recordsHandle, D_HANDLE
    required out errorMessage, a
    required out exceptionRecordsHandle, D_HANDLE

    .define EXCEPTION_BUFSZ 100

    stack record localData
        ok          ,boolean    ;Return status
        rows        ,int        ;Number of rows to insert
        ex_ms       ,int        ;Size of exception array
        ex_mc       ,int        ;Items in exception array
    endrecord

    .include "DEPARTMENT" repository, structure="inpbuf", nofields, end
    .include "DEPARTMENT" repository, static record="department", end

    external common
        chDepartment, int
    endcommon

proc
    ;Make sure the channel is open

    if (!chDepartment)
    begin
        chDepartment = DepartmentOpenUpdate(errorMessage)
        if (!chDepartment)
        begin
            errorMessage = "Failed to open REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM. Error was: " + %atrim(errorMessage)
            freturn 0
        end
    end

    init localData
    ok = true

    ;Figure out how many records to insert

    rows = (%mem_proc(DM_GETSIZE,recordsHandle)/^size(inpbuf))

    ;Insert the records into the database

    if (ok)
    begin
        data cnt, int
        for cnt from 1 thru rows
        begin
            ;Load data into bound record

            department = ^m(inpbuf[cnt],recordsHandle)

            ;Insert the record into the file
            try
            begin
                store(chDepartment,department)
            end
            catch (ex, @Exception)
            begin
                ;If the insert failed, record the exception in the exceptions buffer
                ex_mc += 1
                if (ex_mc == 0) then
                begin
                    exceptionRecordsHandle = %mem_proc(DM_ALLOC,^size(inpbuf)*EXCEPTION_BUFSZ)
                end
                else if (ex_mc >= ex_ms)
                begin
                    exceptionRecordsHandle = %mem_proc(DM_RESIZ,^size(inpbuf)*(ex_ms+=EXCEPTION_BUFSZ),exceptionRecordsHandle)
                end
                ^m(inpbuf[ex_mc],exceptionRecordsHandle) = department
            end
            endtry
        end
    end

    ;Resize the returned exceptions buffer to the correct size

    if (ex_mc)
    begin
        exceptionRecordsHandle = %mem_proc(DM_RESIZ,^size(inpbuf)*ex_mc,exceptionRecordsHandle)
        errorMessage = "Failed to insert " + %string(ex_mc) + " records"
    end

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Updates a record in REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM.
;;; </summary>
;;; <param name="dataRecord">Record containing data to update.</param>
;;; <param name="recordsUpdated">Returned number of rows affected.</param>
;;; <param name="errorMessage">Returned error message.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department$Update, ^val
    required in  dataRecord, a
    required out recordsUpdated, i
    required out errorMessage, a

    stack record localData
        ok, boolean
        keyValue, a255
        keyLength, i4
    endrecord

    static record
        department, strDepartment
    endrecord

    external function
        DepartmentKeyVal, ^val
        DepartmentKeyNum, ^val
    endexternal

    external common
        chDepartment, int
    endcommon

proc
    ;Make sure the channel is open

    if (!chDepartment)
    begin
        chDepartment = DepartmentOpenUpdate(errorMessage)
        if (!chDepartment)
        begin
            errorMessage = "Failed to open REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM. Error was: " + %atrim(errorMessage)
            freturn 0
        end
    end

    init localData
    recordsUpdated = 0
    ok = false

    ;Extract the key value from the RECORD

    xcall DepartmentKeyVal(dataRecord,keyValue,keyLength)

    ;Read the record to lock it

    try
    begin
        read(chDepartment,department,keyValue(1:keyLength),KEYNUM:%DepartmentKeyNum)
    end
    catch (ex, @Exception)
    begin
        errorMessage = "Failed to update record. Error was " + ex.Message
    end
    endtry

    ;Update the record in the file

    if (ok)
    begin
        department = dataRecord
        try
        begin
            write(chDepartment,department)
            recordsUpdated = 1
            ok = true
        end
        catch (ex, @Exception)
        begin
            unlock chDepartment
            errorMessage = "Failed to update record. Error was " + ex.Message
        end
        endtry
    end

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes a record from REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM
;;; </summary>
;;; <param name="keyValue">Unique key of record to be deleted.</param>
;;; <param name="errorMessage">Returned error message.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department$Delete, ^val
    required in  keyValue, a
    required out errorMessage, a
    .include "DEPARTMENT" repository, stack record="department", nofields
    external function
        DepartmentKeyNum, ^val
    endexternal
    external common
        chDepartment, int
    endcommon
proc
    ;Make sure the channel is open

    if (!chDepartment)
    begin
        chDepartment = DepartmentOpenUpdate(errorMessage)
        if (!chDepartment)
        begin
            errorMessage = "Failed to open REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM. Error was: " + %atrim(errorMessage)
            freturn 0
        end
    end

    ;TODO: Needs to support relative files on OpenVMS
    try
    begin
        read(chDepartment,department,keyValue,KEYNUM:%DepartmentKeyNum)
        try
        begin
            delete(chDepartment)
            errorMessage = ""
            freturn true
        end
        catch (ex, @Exception)
        begin
            unlock chDepartment
            errorMessage = "Failed to delete record. Error was " + ex.Message
        end
        endtry
    end
    catch (ex, @Exception)
    begin
        errorMessage = "Failed to read and lock record for delete. Error was " + ex.Message
    end
    endtry

    freturn false

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes all rows from the Department table.
;;; </summary>
;;; <param name="useTempFile">Use temporary file (not currently implemented).</param>
;;; <param name="errorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department$Clear, ^val
    required in useTempFile, n ;Not currently implemented
    required out errorMessage, a
    external common
        chDepartment, int
    endcommon
proc
    errorMessage = ""

    ;If the file is open, close it

    if (chDepartment)
    begin
        close chDepartment
        chDepartment = 0
    end

    ;Clear the file

    try
    begin
        data ignored, i4
        xcall isclr("REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM",ignored)
        freturn true
    end
    catch (ex, @Exception)
    begin
        errorMessage = "Failed to clear file REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM. Error was " + ex.Message
    end
    endtry

    freturn false

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes the Department table from the database.
;;; </summary>
;;; <param name="useTempFile">Use temporary file (not currently implemented).</param>
;;; <param name="errorMessage">Returned error message.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department$Drop, ^val
    required in useTempFile, n ;Not currently implemented
    required out errorMessage, a
    external common
        chDepartment, int
    endcommon
proc
    errorMessage = ""

    ;If the file is open, close it

    if (chDepartment)
    begin
        xcall Department$Close
        if (chDepartment)
        begin
            errorMessage = "Failed to close REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM prior to delete!"
            freturn 0
        end
    end

    try
    begin
        xcall delet("REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM")
        freturn true
    end
    catch (ex, @Exception)
    begin
        errorMessage = "Failed to delete REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM. Error was " + ex.Message
    end
    endtry

    freturn false

endfunction

;*****************************************************************************
;;; <summary>
;;; Bulk load data from REPLICATOR_SAMPLE_DATA:DEPARTMENT.ISM into the Department table via a CSV file.
;;; </summary>
;;; <param name="recordsToLoad">Number of records to load (0=all)</param>
;;; <param name="useTempFile">Use temporary file (not currently implemented).</param>
;;; <param name="recordsLoaded">Records loaded</param>
;;; <param name="exceptionCount">Records failes</param>
;;; <param name="errorMessage">Error message (if return value is false)</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function Department$BulkLoad, ^val
    required in recordsToLoad, n
    required in useTempFile, n ;Not currently implemented
    required out recordsLoaded, n
    required out exceptionCount, n
    required out errorMessage, a

.align
     stack record local_data
        timer,                  @Timer
        ok,                     boolean
        now,                    a20
    endrecord

proc
    init local_data
    ok = true

    timer = new Timer()
    timer.Start()

;TODO: Bulk upload needs implementing
ok = false
errorMessage = "Bulk load is not implemented yet"

    ;Send an UNLOAD message to the unload requests topic



    ;Wait for an UNLOAD response on the unload responses topic



    ;Download the File from S3 storage



    ;Unzip the file



    ;Load the data into the file



    ;Commit the unload response message



    timer.Stop()
    now = %datetime

    if (ok) then
    begin
        writelog("Bulk load finished in " + timer.ElapsedTimeString)
        writett("Bulk load finished in " + timer.ElapsedTimeString)
    end
    else
    begin
        writelog("Bulk load failed after " + timer.ElapsedTimeString)
        writett("Bulk load failed after " + timer.ElapsedTimeString)
    end

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Close cursors associated with the Department table.
;;; </summary>

subroutine Department$Close
    external common
        chDepartment, int
    endcommon
proc
    ;If the file is open, close it

    if (chDepartment)
    begin
        close chDepartment
        chDepartment = 0
    end

    xreturn

endsubroutine

.endc
