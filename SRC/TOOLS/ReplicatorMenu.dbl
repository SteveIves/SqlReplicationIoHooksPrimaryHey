;;*****************************************************************************
;;
;; File:        ReplicatorMenu.dbl
;;
;; Type:        Application
;;
;; Description: Controls the replicator process.
;;
;;*****************************************************************************
;;
;; Copyright (c) 2008, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import System.Collections
import ReplicationLibrary

.ifdef DBLNET
import Confluent.Kafka
import System.Diagnostics
.include "REPLICATION_TRANSFORM" repository, enum, end
.endc

main ReplicatorMenu

    .include "WND:windows.def"

    record
        tt,                 i4
        mainwnd,            i4
        system,             d4
        runtime,            d4
        windows,            boolean
        unix,               boolean
        instanceOk,         boolean
        kafkaMode,          boolean
        pid,                int
        option,             a2
        validTables,        @ArrayList
        validInstances,     @ArrayList
        tableName,          a30
        tmpName,            string
        instanceName,       string
        queueFileName,      string
        tmpInstanceName,    a15
        status,             i4
    endrecord

.ifdef D_VMS
    .include "REPLICATION_VMS" repository, record="instruction", end
.else
    .include "REPLICATION" repository, record="instruction", end
.endc

    record outbuf
        operation,  a20
        ,           a2
        table,      a30
        ,           a2
        keyval,     a24
    endrecord

.ifdef DBLNET
    stack record
        kafkaProducer,  @IProducer<string,string>
        kafkaTopic,     string
    endrecord
.endc

proc
.ifdef DBLNET
    kafkaMode = true
.else
    kafkaMode = false
.endc

    xcall envrn(system,runtime)
    windows = ((runtime==101)||(runtime==104))
    unix = (system==8)

    xcall flags(7004000,1)
    open(tt=0,i,"tt:")

    xcall w_init(0,tt,5)
    xcall w_proc(WP_CREATE,mainwnd,"MAINWND",24,80)
    xcall w_proc(WP_PLACE,mainwnd,1,1)

.ifdef D_GUI
    xcall w_caption(WC_SET,"SQL Replicator")
.endc

.ifndef DBLNET
    try
    begin
.ifdef D_VMS
        xcall openelb("REPLICATOR_SH")
.else
        xcall openelb("REPLICATOR_EXE:library.elb")
.endc
    end
    catch (ex, @Exception)
    begin
.ifdef D_VMS
        xcall w_disp(mainwnd,WD_WRITES,"ERROR: Failed to activate shared image REPLICATOR_SH")
.else
        xcall w_disp(mainwnd,WD_WRITES,"ERROR: Failed to activate ELB REPLICATOR_EXE:library.elb")
.endc
        stop
    end
    endtry
.endc
    ;;Clear screen and display title and instance name

    xcall w_disp(mainwnd,WD_POS,1,1,WD_CLR,WDC_WND,"Replicator Menu")

    ;;Get valid instance names

    xcall GetInstanceNames(validInstances)

    ;;Get the instance name, default to "DEFAULT"
    xcall getlog("REPLICATOR_INSTANCE",tmpInstanceName,status)

    if (tmpInstanceName) then
    begin
        upcase tmpInstanceName
        instanceName = %atrimtostring(tmpInstanceName)
    end
    else
    begin
        instanceName = "DEFAULT"
    end

    ;;Validate the instance name

    instanceOk = false
    foreach tmpName in validInstances
    begin
        if (instanceName .eqs. tmpName)
        begin
            instanceOk = true
            exitloop
        end
    end

    if (instanceOk) then
    begin
.ifdef D_GUI
        xcall w_caption(WC_SET,"SQL Replicator: Instance " + instanceName)
.endc
    end
    else
    begin
        xcall w_disp(mainwnd,WD_POS,3,1,"Invalid instance name: ",instanceName)
        xcall w_updt
        sleep 1
        stop
    end

    ;;Get a collection of the valid table names

    xcall GetReplicatedTables(instanceName,validTables)

    if (kafkaMode)
    begin
.ifdef DBLNET
        data conf = new ProducerConfig()
        conf.BootstrapServers = "localhost:19092,localhost:29092,localhost:39092"
        kafkaProducer = new ProducerBuilder<string,string>(conf).Build()
        kafkaTopic = "REPLICATION_" + instanceName
.endc
    end

    ;;Set the queue file name for the instance
    queueFileName = "REPLICATOR_DATA:REPLICATION_" + instanceName + ".ISM"

    repeat
    begin
        xcall w_disp(mainwnd,WD_CLR,WDC_WND,WD_POS,1,1,"SQL Replicator Menu",WD_POS,1,25,"Instance: "+instanceName,WD_POS,1,50,"Table: " + tableName)

.ifdef DBLNET
        xcall w_disp(mainwnd,WD_POS,3,2,"SR. Start Replicator (Normal)")
        xcall w_disp(mainwnd,WD_POS,4,2,"SD. Start Replicator (Detached/CRASH!)")
.else
        if (windows) then
        begin
            xcall w_disp(mainwnd,WD_POS,3,2,"SR. Start Replicator (Normal)")
            xcall w_disp(mainwnd,WD_POS,4,2,"SD. Start Replicator (Debug)")
        end
        else if (unix)
        begin
            xcall w_disp(mainwnd,WD_POS,3,2,"SR. Start Replicator (Detached)")
            xcall w_disp(mainwnd,WD_POS,4,2,"RS. Replicator Status")
        end
.endc
        xcall w_disp(mainwnd,WD_POS,5,2, "SQ. Stop Replicator  (Queued)")

        if (!kafkaMode)
        begin
            xcall w_disp(mainwnd,WD_POS,6,2, "SN. Stop Replicator  (Now)")

            xcall w_disp(mainwnd,WD_POS,8,2, "V.  View instructions")
            xcall w_disp(mainwnd,WD_POS,9,2, "P.  Purge instructions")
            xcall w_disp(mainwnd,WD_POS,10,2,"PF. Purge first instruction")
            xcall w_disp(mainwnd,WD_POS,11,2,"EI. Export instructions")
.ifndef D_VMS
            xcall w_disp(mainwnd,WD_POS,12,2,"Q.  Queue length")
.endc
.ifdef D_GUI
            xcall w_disp(mainwnd,WD_POS,12,2,"QM. Start Queue Monitor")
.endc
        end
        xcall w_disp(mainwnd,WD_POS,13,2,"S.  Change sleep interval")
        xcall w_disp(mainwnd,WD_POS,14,2,"R.  Restart log file")

        xcall w_disp(mainwnd,WD_POS,16,2,"IN. Instance Names")
        xcall w_disp(mainwnd,WD_POS,17,2,"I.  Select Instance")
        xcall w_disp(mainwnd,WD_POS,18,2,"TN. Table names")
        xcall w_disp(mainwnd,WD_POS,19,2,"T.  Select table")

        xcall w_disp(mainwnd,WD_POS,21,2,"E.  Exit")

        if (tableName)
        begin
            xcall w_disp(mainwnd,WD_POS, 3,40,"C.  Create table")
            xcall w_disp(mainwnd,WD_POS, 4,40,"L.  Load table")
            xcall w_disp(mainwnd,WD_POS, 5,40,"CL. Create and load table")
            xcall w_disp(mainwnd,WD_POS, 6,40,"BL. Bulk load table")
            xcall w_disp(mainwnd,WD_POS, 7,40,"BR. Bulk load first 1000")
            xcall w_disp(mainwnd,WD_POS, 8,40,"BC. Bulk copy table")
            xcall w_disp(mainwnd,WD_POS, 9,40,"AI. Add indexes")
            xcall w_disp(mainwnd,WD_POS,10,40,"DI. Delete indexes")
            xcall w_disp(mainwnd,WD_POS,11,40,"TR. Truncate table")
            xcall w_disp(mainwnd,WD_POS,12,40,"D.  Delete table")
            xcall w_disp(mainwnd,WD_POS,13,40,"X.  Export to CSV")
.ifdef DBLNET
            xcall w_disp(mainwnd,WD_POS,16,40,"TT. Transform TEST")
.endc
            if (windows && (tableName=="Employee" || tableName=="Department"))
                xcall w_disp(mainwnd,WD_POS,13,40,"M.  Maintainance")
        end

        xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOW,"Select an option: ")
        xcall w_disp(mainwnd,WD_READS,option)

        using option select

        ("M "),
        begin
            if (windows)
            begin
                using tableName select
                ("Department"),
                begin
                    xcall spawn("dbr REPLICATOR_EXE:DepartmentMaintenance.dbr",D_NOWINDOW|D_NOWAIT)
                end
                ("Employee"),
                begin
                    xcall spawn("dbr REPLICATOR_EXE:EmployeeMaintenance.dbr",D_NOWINDOW|D_NOWAIT)
                end
                endusing
            end
        end

        ("SR"),
        begin
.ifdef DBLNET
            ;TODO: Need to improve this before .NET release!!!
            data startInfo = new ProcessStartInfo() {
            &    FileName = "C:\DEV_SYNERGEX\SqlReplication\EXE\net6.0\NetReplicator.exe",
            &    UseShellExecute = true,
            &    WindowStyle = ProcessWindowStyle.Normal
            &    }
            System.Diagnostics.Process.Start(startInfo)
.else
            if (windows) then
                xcall spawn("dbr REPLICATOR_EXE:replicator.dbr",D_NOWINDOW|D_NOWAIT)
            else if (unix)
            begin
                xcall spawn("nohup dbr REPLICATOR_EXE:replicator.dbr $REPLICATOR_INSTANCE </dev/null >/dev/null 2>&1 &")
            end
.endc
        end

        ("RS"),
        begin
            if (windows) then
                nop
            else if (unix)
            begin
                data pipechn, int, 0
                data instanceCount, int, 0
                data buffer, a256
                open(pipechn,i,'|ps -ef | grep "dbr REPLICATOR_EXE:replicator.dbr" | grep -v grep')

                xcall w_disp(mainwnd,WD_CLR,WDC_WND,"Replicator status ...",WD_POS,3,1)

                repeat
                begin
                    reads(pipechn,buffer,EndOfPipe)
                    xcall w_disp(mainwnd,WD_WRITES,%atrim(buffer))
                    instanceCount+=1
                end
            EndOfPipe,
                close pipechn

                if (!instanceCount)
                    xcall w_disp(mainwnd,"No replicator instances found!")

                xcall w_disp(mainwnd,WD_POS,23,2,"Press a key to continue: ")
                begin
                    data tmpvar, a1
                    xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
.ifdef DBLNET
                    while (%w_info(WIF_TTSTS))
.else
                    while (%ttsts)
.endc
                    xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
                end

            end
        end

        ("SD"),
        begin
.ifdef DBLNET
            data startInfo = new ProcessStartInfo() {
            &    FileName = "C:\DEV_UNFI\UBSSQLReplication\EXE\net6.0\NetReplicator.exe",
            &    UseShellExecute = false,
            &    CreateNoWindow = true
            &    }
            System.Diagnostics.Process.Start(startInfo)
.else
            if (windows)
            begin
                xcall spawn("dbr -d REPLICATOR_EXE:replicator.dbr",D_NOWINDOW|D_NOWAIT)
            end
.endc
        end

        ("SN"),
        begin
            if (kafkaMode) then
            begin
.ifdef DBLNET
                data kafkaMessage = new Message<string,string>() { Key="SHUTDOWN", Value="" }
                data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
            end
            else
            begin
                ;;Stop now. To do this we need to flip the action field of the first record to a negative value.
                ;;If there is no first record then queue a shutdown
                data chn, i4
                open(chn=0,"U:I",queueFileName)
            again,
                sleep 0.01
                read(chn,instruction,^FIRST) [$ERR_LOCKED=again,$ERR_EOF=norec]
                ;;The queue is not empty, schedule a shutdown via the first item in the queue
                instruction.action = -instruction.action
                write(chn,instruction)
                close chn
                exit
                ;;The queue is empty, schedule a shutdown via a specific instruction
            norec,
                close chn
                xcall Replicate(instanceName,REPLICATION_INSTRUCTION.SHUTDOWN)
            end
            xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
        end

        ("SQ"),
        begin
            if (kafkaMode) then
            begin
.ifdef DBLNET
                data kafkaMessage = new Message<string,string>() { Key="SHUTDOWN", Value="" }
                data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
            end
            else
            begin
                xcall Replicate(instanceName,REPLICATION_INSTRUCTION.SHUTDOWN)
            end
            xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
        end

        ("V "),
        begin
            if (kafkaMode) then
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            else
            begin
                data chn, i4
                data row, i4
                data tmpvar, a1, " "
                data stopping, boolean
                open(chn=0,"I:I",queueFileName)

                xcall w_disp(mainwnd,WD_POS,3,1,WD_CLR,WDC_EOW,
                &    WD_POS,3,1,"Instruction           Table                           Affected Record",
                &    WD_POS,4,1,"--------------------  ------------------------------  ------------------------")

                find(chn,,^FIRST) [EOF=eof]

                repeat
                begin
                    for row from 5 thru 22
                    begin
                        reads(chn,instruction,eof)
                        clear outbuf

                        stopping = instruction.action < 0

                        if (stopping)
                            instruction.action = -instruction.action

                        using instruction.action select
                        (REPLICATION_INSTRUCTION.CREATE_ROW),
                            outbuf.operation = "Create row"
                        (REPLICATION_INSTRUCTION.UPDATE_ROW),
                            outbuf.operation = "Update row"
                        (REPLICATION_INSTRUCTION.UPDATE_RELATIVE),
                            outbuf.operation = "Update row (rel)"
                        (REPLICATION_INSTRUCTION.DELETE_ROW),
                            outbuf.operation = "Delete row"
                        (REPLICATION_INSTRUCTION.CREATE_TABLE),
                            outbuf.operation = "Create table"
                        (REPLICATION_INSTRUCTION.LOAD_TABLE),
                            outbuf.operation = "Load table"
                        (REPLICATION_INSTRUCTION.BULK_LOAD_TABLE),
                            outbuf.operation = "Bulk load table"
                        (REPLICATION_INSTRUCTION.BULK_COPY_TABLE),
                            outbuf.operation = "Bulk copy table"
                        (REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE),
                            outbuf.operation = "Create & load table"
                        (REPLICATION_INSTRUCTION.DELETE_ALL_ROWS),
                            outbuf.operation = "Truncate table"
                        (REPLICATION_INSTRUCTION.DELETE_TABLE),
                            outbuf.operation = "Delete table"
                        (REPLICATION_INSTRUCTION.SHUTDOWN),
                            outbuf.operation = "Shutdown"
                        (REPLICATION_INSTRUCTION.DELETE_ALL_INSTRUCTIONS),
                            outbuf.operation = "Purge instructions"
                        (REPLICATION_INSTRUCTION.CREATE_CSV),
                            outbuf.operation = "Export to CSV"
                        (REPLICATION_INSTRUCTION.CLOSE_FILE),
                            outbuf.operation = "Close file"
                        (REPLICATION_INSTRUCTION.CYCLE_LOG),
                            outbuf.operation = "Restart log"
                        (REPLICATION_INSTRUCTION.ADD_INDEXES),
                            outbuf.operation = "Add indexes"
                        (REPLICATION_INSTRUCTION.DELETE_INDEXES),
                            outbuf.operation = "Delete indexes"
                        (REPLICATION_INSTRUCTION.CHANGE_INTERVAL),
                            outbuf.operation = "Change interval"
                        (REPLICATION_INSTRUCTION.TRANSFORM_COLUMN),
                            outbuf.operation = "Transform column"
                        endusing

                        if (stopping)
                            outbuf.operation = %atrim(outbuf.operation) + "*"

                        outbuf.table = instruction.structure_name
                        outbuf.keyval = instruction.record

                        xcall w_disp(mainwnd,WD_POS,row,1,outbuf)
                    end

                    xcall w_disp(mainwnd,WD_POS,23,1,"Press ENTER for more or M for menu: ")

                    begin
                        xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
.ifdef DBLNET
                        while (%w_info(WIF_TTSTS))
.else
                        while (%ttsts)
.endc
                        xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
                    end

                    if (tmpvar=="M") then
                    begin
                        exitloop
                    end
                    else
                    begin
                        xcall w_disp(mainwnd,WD_POS,3,1,WD_CLR,WDC_EOW)
                        nextloop
                    end
                end

            eof,
                close chn

                if (tmpvar!="M")
                begin
                    xcall w_disp(mainwnd,WD_POS,23,1,WD_CLR,WDC_EOW,"No more instructions. Press a key: ")
                    begin
                        xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
.ifdef DBLNET
                        while (%w_info(WIF_TTSTS))
.else
                        while (%ttsts)
.endc
                        xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
                    end
                end
                nextloop
            end
        end

        ("P "),
        begin
            if (kafkaMode) then
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            else
            begin
                xcall Replicate(instanceName,REPLICATION_INSTRUCTION.DELETE_ALL_INSTRUCTIONS)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command executed")
            end
        end

        ("PF"),
        begin
            if (kafkaMode) then
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            else
            begin
                xcall Replicate(instanceName,REPLICATION_INSTRUCTION.DELETE_FIRST_INSTRUCTION)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command executed")
            end
        end

        ("EI"), ;Export instructions
        begin
            if (kafkaMode) then
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            else
            begin
                data inch = 0
                data outch = 0
                data exportFile = queueFileName.Replace(".ISM",".TXT")

                if (File.Exists(exportFile))
                begin
                    File.Delete(exportFile)
                end

                try
                begin
                    open(inch,i:i,queueFileName,SHARE:Q_EXCL_RW)
                    open(outch,o:s,exportFile)
                    repeat
                    begin
                        reads(inch,instruction)
                        writes(outch,%atrim(instruction(^size(instruction.transaction_id)+1,^size(instruction))))
                    end
                end
                catch (e, @EndOfFileException)
                begin
                    nop
                end
                catch (e, @Exception)
                begin
                    xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Failed to export instructions!")
                end
                finally
                begin
                    if (inch && %chopen(inch))
                        close inch
                    if (outch && %chopen(outch))
                        close outch
                end
                endtry
            end
        end

.ifndef D_VMS
        ("Q "),
        begin
            if (kafkaMode) then
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            else
            begin
                data tmpvar, a1
                data chn, i4
                open(chn=0,"I:I",queueFileName)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Queue length: " + %string(%isinfo(chn,"NUMRECS")))
                close chn
                xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
.ifdef DBLNET
                while (%w_info(WIF_TTSTS))
.else
                while (%ttsts)
.endc
                xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
                nextloop
            end
        end
.endc

.ifdef D_GUI
        ("QM"),
        begin
            if (kafkaMode) then
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            else
            begin
                xcall spawn("dbr REPLICATOR_EXE:QueueMonitor.dbr",D_NOWINDOW|D_NOWAIT)
            end
        end
.endc

        ("S "),
        begin
            data interval, a5
            xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOW,"Sleep interval (seconds): ")
            xcall w_disp(mainwnd,WD_READS,interval)

            if (interval) then
            begin
                if (%IsDecimalNoNegatives(^d(interval))) then
                begin
                    if (kafkaMode) then
                    begin
.ifdef DBLNET
                        data kafkaMessage = new Message<string,string>() { Key="CHANGE_INTERVAL", Value=%atrimtostring(interval) }
                        data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                    end
                    else
                    begin
                        xcall Replicate(instanceName,REPLICATION_INSTRUCTION.CHANGE_INTERVAL,,%atrim(interval))
                    end
                    xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
                end
                else
                begin
                    xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid interval!")
                end
            end
            else
            begin
                nextloop
            end
        end

        ("IN"),
        begin
            data row, i4, 4
            data col, i4, 2
            data name, string

            xcall w_disp(mainwnd,WD_POS,3,1,WD_CLR,WDC_EOW,"Instance Names")

            foreach name in validInstances
            begin
                xcall w_disp(mainwnd,WD_POS,row+=1,col,name)
                if (row==21)
                begin
                    row=4
                    col+=18
                end
            end

            xcall w_disp(mainwnd,WD_POS,23,1,"Press a key: ")
            begin
                data tmpvar, a1
                xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
.ifdef DBLNET
                while (%w_info(WIF_TTSTS))
.else
                while (%ttsts)
.endc
                xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
            end
        end

        ("TN"),
        begin
            data row, i4, 4
            data col, i4, 2
            data name, string

            xcall w_disp(mainwnd,WD_POS,3,1,WD_CLR,WDC_EOW,"Table Names")

            foreach name in validTables
            begin
                xcall w_disp(mainwnd,WD_POS,row+=1,col,name)
                if (row==21)
                begin
                    row=4
                    col+=18
                end
            end

            xcall w_disp(mainwnd,WD_POS,23,1,"Press a key: ")
            begin
                data tmpvar, a1
                xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
.ifdef DBLNET
                while (%w_info(WIF_TTSTS))
.else
                while (%ttsts)
.endc
                xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
            end
        end

        ("T "),
        begin
            xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOW,"Table name: ")
            xcall w_disp(mainwnd,WD_READS,tableName)

            if (tableName) then
            begin
                ;;Make sure it's a valid table
                data found = false
                data name, string

                ;;Look for it in the collection of valid tables
                foreach name in validTables
                begin
                    if ((a)(name.ToUpper()).eqs.tableName)
                    begin
                        tableName = (a)(name.ToUpper())
                        xcall w_disp(mainwnd,WD_POS,1,57,WD_CLR,WDC_EOL,%atrim(tableName))
                        found = true
                        exitloop
                    end
                end

                ;;Report if not found
                if (!found)
                begin
                    xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Table not found!")
                    xcall w_disp(mainwnd,WD_POS,1,57,WD_CLR,WDC_EOL,"<none>")
                    clear tableName
                end
            end
            else
            begin
                xcall w_disp(mainwnd,WD_POS,1,57,WD_CLR,WDC_EOL,"<none>")
                nextloop
            end
        end

        ("I "),
        begin
            ;;Record the current instance name
            data oldInstanceName, string, instanceName

            ;;Gte a new instance name
            clear tmpInstanceName
            xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOW,"Instance name: ")
            xcall w_disp(mainwnd,WD_READS,tmpInstanceName)
            upcase tmpInstanceName

            ;;Did it change?
            if (tmpInstanceName != oldInstanceName)
            begin
                if (tmpInstanceName) then
                begin
                    instanceName = %atrimtostring(tmpInstanceName)
                end
                else
                begin
                    instanceName = "DEFAULT"
                end

                ;;Validate the instance name

                instanceOk = false
                foreach tmpName in validInstances
                begin
                    if (instanceName .eqs. tmpName)
                    begin
                        instanceOk = true
                        exitloop
                    end
                end

                if (instanceOk) then
                begin
                    xcall setlog("REPLICATOR_INSTANCE",instanceName,status)

                    ;;Get a collection of the valid table names

                    xcall GetReplicatedTables(instanceName,validTables)

                    clear tmpInstanceName
                    xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOW,WD_POS,1,35,tmpInstanceName,WD_POS,1,35,instanceName)

                    ;;Set the queue file name for the instance
                    queueFileName = "REPLICATOR_DATA:REPLICATION_" + instanceName + ".ISM"
.ifdef D_GUI
                    xcall w_caption(WC_SET,"SQL Replicator: Instance " + instanceName)
.endc
                end
                else
                begin
                    instanceName = oldInstanceName
                    xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid instance name!")
                end
            end
        end

        ("R "),
        begin
            if (kafkaMode) then
            begin
.ifdef DBLNET
                data kafkaMessage = new Message<string,string>() { Key="CYCLE_LOG", Value=%atrimtostring(tableName) }
                data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
            end
            else
            begin
                xcall Replicate(instanceName,REPLICATION_INSTRUCTION.CYCLE_LOG)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command executed")
            end
        end

        ("C "),
        begin
            if (tableName) then
            begin
                if (kafkaMode) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="CREATE_TABLE", Value=%atrimtostring(tableName) }
                    data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(instanceName,REPLICATION_INSTRUCTION.CREATE_TABLE,tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command executed")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("L "),
        begin
            if (tableName) then
            begin
                if (kafkaMode) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="LOAD_TABLE", Value=%atrimtostring(tableName) }
                    data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(instanceName,REPLICATION_INSTRUCTION.LOAD_TABLE,tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("CL"),
        begin
            if (tableName) then
            begin
                if (kafkaMode) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="CREATE_AND_LOAD_TABLE", Value=%atrimtostring(tableName) }
                    data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(instanceName,REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE,tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("BL"),
        begin
            if (tableName) then
            begin
                if (kafkaMode) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="BULK_LOAD_TABLE", Value=%atrimtostring(tableName) }
                    data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(instanceName,REPLICATION_INSTRUCTION.BULK_LOAD_TABLE,tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("BR"),
        begin
            if (tableName) then
            begin
                if (kafkaMode) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="BULK_LOAD_FIRST_1000", Value=%atrimtostring(tableName) }
                    data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(instanceName,REPLICATION_INSTRUCTION.BULK_LOAD_FIRST_1000,tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("BC"),
        begin
            if (tableName) then
            begin
                if (kafkaMode) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="BULK_COPY_TABLE", Value=%atrimtostring(tableName) }
                    data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(instanceName,REPLICATION_INSTRUCTION.BULK_COPY_TABLE,tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("AI"),
        begin
            if (tableName) then
            begin
                if (kafkaMode) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="ADD_INDEXES", Value=%atrimtostring(tableName) }
                    data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(instanceName,REPLICATION_INSTRUCTION.ADD_INDEXES,tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("DI"),
        begin
            if (tableName) then
            begin
                if (kafkaMode) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="DELETE_INDEXES", Value=%atrimtostring(tableName) }
                    data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(instanceName,REPLICATION_INSTRUCTION.DELETE_INDEXES,tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("TR"),
        begin
            if (tableName) then
            begin
                if (kafkaMode) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="DELETE_ALL_ROWS", Value=%atrimtostring(tableName) }
                    data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(instanceName,REPLICATION_INSTRUCTION.DELETE_ALL_ROWS,tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

.ifdef DBLNET
        ("TT"),
        begin
            ;Transform TEST
            using tableName select
            ("DEPARTMENT"),
            begin
                data transformData, string, %string(REPLICATION_TRANSFORM.EXTEND_ALPHA) + "|DeptName|60"
                xcall Replicate(instanceName,REPLICATION_INSTRUCTION.TRANSFORM_COLUMN,tableName,transformData)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            ("EMPLOYEE"),
            begin
                data transformData, string, %string(REPLICATION_TRANSFORM.EXTEND_ALPHA) + "|EmpFirstName|25"
                xcall Replicate(instanceName,REPLICATION_INSTRUCTION.TRANSFORM_COLUMN,tableName,transformData)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            (),
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            endusing
        end
.endc
        ("D "),
        begin
            if (tableName) then
            begin
                if (kafkaMode) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="DELETE_TABLE", Value=%atrimtostring(tableName) }
                    data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(instanceName,REPLICATION_INSTRUCTION.DELETE_TABLE,tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("X "),
        begin
            if (tableName) then
            begin
                if (kafkaMode) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="CREATE_CSV", Value=%atrimtostring(tableName) }
                    data deliveryResult = kafkaProducer.ProduceAsync(kafkaTopic,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(instanceName,REPLICATION_INSTRUCTION.CREATE_CSV,tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("E "),
            exitloop

        (),
            xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")

        endusing

        sleep 0.5
    end

    xcall w_disp(mainwnd,WD_POS,1,1,WD_CLR,WDC_WND)
    xcall w_exit
    close tt

.ifdef DBLNET
    if (kafkaMode)
    begin
        kafkaProducer.Dispose()
        kafkaProducer = ^null
    end
.endc

    stop

endmain

