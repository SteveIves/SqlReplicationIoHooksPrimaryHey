;*****************************************************************************
;
; File:         ReplicatorMenu.dbl
;
; Type:         Application
;
; Description:  Controls the replicator process.
;
;*****************************************************************************
;
; Copyright (c) 2008, Synergex International, Inc.
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;
; * Redistributions of source code must retain the above copyright notice,
;   this list of conditions and the following disclaimer.
;
; * Redistributions in binary form must reproduce the above copyright notice,
;   this list of conditions and the following disclaimer in the documentation
;   and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;
;*****************************************************************************

import System.Collections
import ReplicationLibrary

.ifdef DBLNET
import Confluent.Kafka
import System.Diagnostics
import System.IO
import System.Reflection
.include "REPLICATION_TRANSFORM" repository, enum, end
.endc

main ReplicatorMenu

    .include "WND:windows.def"
.ifdef D_VMS
    .include "REPLICATION_VMS" repository, record="instruction", end
.else
    .include "REPLICATION" repository, record="instruction", end
.endc

    record
        mainwnd,    i4
        system,     d4
        runtime,    d4
        windows,    boolean
        unix,       boolean
        option,     a2
        tableName,  string
.ifdef DBLNET
        producer,   @IProducer<string,string>
.endc
    endrecord

    record outbuf
        operation,  a20
        ,           a2
        table,      a30
        ,           a2
        keyval,     a24
    endrecord

proc
    xcall flags(7004000,1)

    ;Check that we have the basic environment that we need
    begin
        data errorMessage, string
        if (!%ValidateBasicEnvironment(errorMessage))
        begin
            Console.WriteLine("ERROR: Basic environment not established. Error was: " + errorMessage)
            Console.Write("Press ENTER: ")
            Console.ReadLine()
            stop
        end
    end

    ;Load the replication environment settings
    begin
        data errorMessage, string
        if (!Settings.Load(errorMessage))
        begin
            Console.WriteLine("ERROR: Failed to load replication environment settings. Error was: " + errorMessage)
            Console.Write("Press ENTER: ")
            Console.ReadLine()
            stop
        end
    end

    xcall envrn(system,runtime)
    windows = ((runtime==101)||(runtime==104))
    unix = (system==8)

    xcall w_init(0,Settings.TerminalChannel,5)
    xcall w_proc(WP_CREATE,mainwnd,"MAINWND",24,80)
    xcall w_proc(WP_PLACE,mainwnd,1,1)

.ifdef D_GUI
    xcall w_caption(WC_SET,"SQL Replicator")
.endc

.ifndef DBLNET
    try
    begin
.ifdef D_VMS
        xcall openelb("REPLICATOR_SH")
.else
        xcall openelb("REPLICATOR_EXE:library.elb")
.endc
    end
    catch (ex, @Exception)
    begin
.ifdef D_VMS
        xcall w_disp(mainwnd,WD_WRITES,"ERROR: Failed to activate shared image REPLICATOR_SH")
.else
        xcall w_disp(mainwnd,WD_WRITES,"ERROR: Failed to activate ELB REPLICATOR_EXE:library.elb")
.endc
        stop
    end
    endtry
.endc

.ifdef DBLNET
    ;In Kafka mode, connect to the Kafka server
    if (Settings.QueueType == MessageQueueType.Kafka)
    begin
        ;Connect to the Kafka server
        data conf = new ProducerConfig()
        conf.BootstrapServers = Settings.KafkaServers
        conf.EnableIdempotence = true ;ensure delivery of messages in the order specified
        producer = new ProducerBuilder<string,string>(conf).Build()



    end
.endc

    repeat
    begin
        xcall w_disp(mainwnd,WD_CLR,WDC_WND,
        &    WD_POS,1,1,"SQL Replicator",
        &    WD_POS,1,17,"Queue: ", Settings.QueueType==MessageQueueType.IsamFile ? "ISAM" : "KAFKA",
        &    WD_POS,1,30,"Instance: ", Settings.InstanceName,
        &    WD_POS,1,54,"Table: ", String.IsNullOrWhiteSpace(tableName) ? "<none>" : tableName )

.ifdef DBLNET
        xcall w_disp(mainwnd,WD_POS,3,2,"SR. Start Replicator (Normal)")
        xcall w_disp(mainwnd,WD_POS,4,2,"SD. Start Replicator (Detached/CRASH!)")
.else
        if (windows) then
        begin
            xcall w_disp(mainwnd,WD_POS,3,2,"SR. Start Replicator (Normal)")
            xcall w_disp(mainwnd,WD_POS,4,2,"SD. Start Replicator (Debug)")
        end
        else if (unix)
        begin
            xcall w_disp(mainwnd,WD_POS,3,2,"SR. Start Replicator (Detached)")
            xcall w_disp(mainwnd,WD_POS,4,2,"RS. Replicator Status")
        end
.endc
        xcall w_disp(mainwnd,WD_POS,5,2, "SQ. Stop Replicator  (Queued)")

        if (Settings.QueueType==MessageQueueType.IsamFile)
        begin
            xcall w_disp(mainwnd,WD_POS,6,2, "SN. Stop Replicator  (Now)")

            xcall w_disp(mainwnd,WD_POS,8,2, "V.  View queue")
            xcall w_disp(mainwnd,WD_POS,9,2, "P.  Purge queue")
            xcall w_disp(mainwnd,WD_POS,10,2,"PF. Purge first instruction")
            xcall w_disp(mainwnd,WD_POS,11,2,"EQ. Export queue")
.ifndef D_VMS
            xcall w_disp(mainwnd,WD_POS,12,2,"Q.  Queue length")
.endc
        end
        xcall w_disp(mainwnd,WD_POS,13,2,"S.  Change processing interval")
        xcall w_disp(mainwnd,WD_POS,14,2,"R.  Restart log file")

        xcall w_disp(mainwnd,WD_POS,16,2,"I.  Change Instance")
        xcall w_disp(mainwnd,WD_POS,17,2,"T.  Change Table")

        if (!String.IsNullOrWhiteSpace(tableName))
        begin
            xcall w_disp(mainwnd,WD_POS, 3,50,"C.  Create table")
            xcall w_disp(mainwnd,WD_POS, 4,50,"L.  Load table")
            xcall w_disp(mainwnd,WD_POS, 5,50,"CL. Create and load table")
            xcall w_disp(mainwnd,WD_POS, 6,50,"BL. Bulk load table")
            xcall w_disp(mainwnd,WD_POS, 7,50,"BR. Bulk load first 1000")
            xcall w_disp(mainwnd,WD_POS, 8,50,"BC. Bulk copy table")
            xcall w_disp(mainwnd,WD_POS, 9,50,"AI. Add indexes")
            xcall w_disp(mainwnd,WD_POS,10,50,"DI. Delete indexes")
            xcall w_disp(mainwnd,WD_POS,11,50,"TR. Truncate table")
            xcall w_disp(mainwnd,WD_POS,12,50,"D.  Delete table")
            xcall w_disp(mainwnd,WD_POS,13,50,"X.  Export to CSV")

            if (windows && (tableName=="EMPLOYEE" || tableName=="DEPARTMENT"))
                xcall w_disp(mainwnd,WD_POS,15,50,"M.  Maintainance")
.ifdef DBLNET
            if (tableName=="EMPLOYEE" || tableName=="DEPARTMENT")
            begin
                xcall w_disp(mainwnd,WD_POS,16,50,"TT. Transform TEST")
            end
            if (tableName=="EMPLOYEE")
            begin
                xcall w_disp(mainwnd,WD_POS,17,50,"LT. Load Test")
            end
.endc
        end

        xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOW,"Select an option (or E to exit): ")
        xcall w_disp(mainwnd,WD_READS,option)

        using option select

        ("M "),
        begin
            if (windows)
            begin
                using tableName select
                ("DEPARTMENT"),
                begin
                    xcall spawn("dbr REPLICATOR_EXE:DepartmentMaintenance.dbr",D_NOWINDOW|D_NOWAIT)
                end
                ("EMPLOYEE"),
                begin
                    xcall spawn("dbr REPLICATOR_EXE:EmployeeMaintenance.dbr",D_NOWINDOW|D_NOWAIT)
                end
                endusing
            end
        end

        ("SR"),
        begin
.ifdef DBLNET
            data assemblyToLaunch = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location),"NetReplicator.exe")

            data startInfo = new ProcessStartInfo() {
            &    FileName = assemblyToLaunch,
            &    UseShellExecute = true,
            &    WindowStyle = ProcessWindowStyle.Normal
            &    }
            System.Diagnostics.Process.Start(startInfo)
.else
            if (windows) then
                xcall spawn("dbr REPLICATOR_EXE:replicator.dbr",D_NOWINDOW|D_NOWAIT)
            else if (unix)
            begin
                xcall spawn("nohup dbr REPLICATOR_EXE:replicator.dbr $REPLICATOR_INSTANCE </dev/null >/dev/null 2>&1 &")
            end
.endc
        end

        ("RS"),
        begin
            if (windows) then
                nop
            else if (unix)
            begin
                data pipechn, int, 0
                data instanceCount, int, 0
                data buffer, a256
                open(pipechn,i,'|ps -ef | grep "dbr REPLICATOR_EXE:replicator.dbr" | grep -v grep')

                xcall w_disp(mainwnd,WD_CLR,WDC_WND,"Replicator status ...",WD_POS,3,1)

                repeat
                begin
                    reads(pipechn,buffer,EndOfPipe)
                    xcall w_disp(mainwnd,WD_WRITES,%atrim(buffer))
                    instanceCount+=1
                end
            EndOfPipe,
                close pipechn

                if (!instanceCount)
                    xcall w_disp(mainwnd,"No replicator instances found!")

                xcall w_disp(mainwnd,WD_POS,23,2,"Press a key to continue: ")
                begin
                    data tmpvar, a1
                    xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
.ifdef DBLNET
                    while (%w_info(WIF_TTSTS))
.else
                    while (%ttsts)
.endc
                    xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
                end

            end
        end

        ("SD"),
        begin
.ifdef DBLNET
            data startInfo = new ProcessStartInfo() {
            &    FileName = "C:\DEV_UNFI\UBSSQLReplication\EXE\net6.0\NetReplicator.exe",
            &    UseShellExecute = false,
            &    CreateNoWindow = true
            &    }
            System.Diagnostics.Process.Start(startInfo)
.else
            if (windows)
            begin
                xcall spawn("dbr -d REPLICATOR_EXE:replicator.dbr",D_NOWINDOW|D_NOWAIT)
            end
.endc
        end

        ("SN"),
        begin
            if (Settings.QueueType==MessageQueueType.Kafka) then
            begin
.ifdef DBLNET
                data kafkaMessage = new Message<string,string>() { Key="SHUTDOWN", Value="" }
                data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
            end
            else
            begin
                ;Stop now. To do this we need to flip the action field of the first record to a negative value.
                ;If there is no first record then queue a shutdown
                data chn, i4
                open(chn=0,"U:I",Settings.QueueFileName)
            again,
                sleep 0.01
                read(chn,instruction,^FIRST) [$ERR_LOCKED=again,$ERR_EOF=norec]
                ;The queue is not empty, schedule a shutdown via the first item in the queue
                instruction.action = -instruction.action
                write(chn,instruction)
                close chn
                exit
                ;The queue is empty, schedule a shutdown via a specific instruction
            norec,
                close chn
                xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.SHUTDOWN)
            end
            xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
        end

        ("SQ"),
        begin
            if (Settings.QueueType==MessageQueueType.Kafka) then
            begin
.ifdef DBLNET
                data kafkaMessage = new Message<string,string>() { Key="SHUTDOWN", Value="" }
                data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
            end
            else
            begin
                xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.SHUTDOWN)
            end
            xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
        end

        ("V "),
        begin
            if (Settings.QueueType==MessageQueueType.Kafka) then
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            else
            begin
                data chn, i4
                data row, i4
                data tmpvar, a1, " "
                data stopping, boolean
                open(chn=0,"I:I",Settings.QueueFileName)

                xcall w_disp(mainwnd,WD_POS,3,1,WD_CLR,WDC_EOW,
                &    WD_POS,3,1,"Instruction           Table                           Affected Record",
                &    WD_POS,4,1,"--------------------  ------------------------------  ------------------------")

                find(chn,,^FIRST) [EOF=eof]

                repeat
                begin
                    for row from 5 thru 22
                    begin
                        reads(chn,instruction,eof)
                        clear outbuf

                        stopping = instruction.action < 0

                        if (stopping)
                            instruction.action = -instruction.action

                        using instruction.action select
                        (REPLICATION_INSTRUCTION.CREATE_ROW),
                            outbuf.operation = "Create row"
                        (REPLICATION_INSTRUCTION.UPDATE_ROW),
                            outbuf.operation = "Update row"
                        (REPLICATION_INSTRUCTION.UPDATE_RELATIVE),
                            outbuf.operation = "Update row (rel)"
                        (REPLICATION_INSTRUCTION.DELETE_ROW),
                            outbuf.operation = "Delete row"
                        (REPLICATION_INSTRUCTION.CREATE_TABLE),
                            outbuf.operation = "Create table"
                        (REPLICATION_INSTRUCTION.LOAD_TABLE),
                            outbuf.operation = "Load table"
                        (REPLICATION_INSTRUCTION.BULK_LOAD_TABLE),
                            outbuf.operation = "Bulk load table"
                        (REPLICATION_INSTRUCTION.BULK_COPY_TABLE),
                            outbuf.operation = "Bulk copy table"
                        (REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE),
                            outbuf.operation = "Create & load table"
                        (REPLICATION_INSTRUCTION.DELETE_ALL_ROWS),
                            outbuf.operation = "Truncate table"
                        (REPLICATION_INSTRUCTION.DELETE_TABLE),
                            outbuf.operation = "Delete table"
                        (REPLICATION_INSTRUCTION.SHUTDOWN),
                            outbuf.operation = "Shutdown"
                        (REPLICATION_INSTRUCTION.DELETE_ALL_INSTRUCTIONS),
                            outbuf.operation = "Purge instructions"
                        (REPLICATION_INSTRUCTION.CREATE_CSV),
                            outbuf.operation = "Export to CSV"
                        (REPLICATION_INSTRUCTION.CLOSE_FILE),
                            outbuf.operation = "Close file"
                        (REPLICATION_INSTRUCTION.CYCLE_LOG),
                            outbuf.operation = "Restart log"
                        (REPLICATION_INSTRUCTION.ADD_INDEXES),
                            outbuf.operation = "Add indexes"
                        (REPLICATION_INSTRUCTION.DELETE_INDEXES),
                            outbuf.operation = "Delete indexes"
                        (REPLICATION_INSTRUCTION.CHANGE_INTERVAL),
                            outbuf.operation = "Change interval"
                        (REPLICATION_INSTRUCTION.TRANSFORM_COLUMN),
                            outbuf.operation = "Transform column"
                        endusing

                        if (stopping)
                            outbuf.operation = %atrim(outbuf.operation) + "*"

                        outbuf.table = instruction.structure_name
                        outbuf.keyval = instruction.record

                        xcall w_disp(mainwnd,WD_POS,row,1,outbuf)
                    end

                    xcall w_disp(mainwnd,WD_POS,23,1,"Press ENTER for more or M for menu: ")

                    begin
                        xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
.ifdef DBLNET
                        while (%w_info(WIF_TTSTS))
.else
                        while (%ttsts)
.endc
                        xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
                    end

                    if (tmpvar=="M") then
                    begin
                        exitloop
                    end
                    else
                    begin
                        xcall w_disp(mainwnd,WD_POS,3,1,WD_CLR,WDC_EOW)
                        nextloop
                    end
                end

            eof,
                close chn

                if (tmpvar!="M")
                begin
                    xcall w_disp(mainwnd,WD_POS,23,1,WD_CLR,WDC_EOW,"No more instructions. Press a key: ")
                    begin
                        xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
.ifdef DBLNET
                        while (%w_info(WIF_TTSTS))
.else
                        while (%ttsts)
.endc
                        xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
                    end
                end
                nextloop
            end
        end

        ("P "),
        begin
            if (Settings.QueueType==MessageQueueType.Kafka) then
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            else
            begin
                xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.DELETE_ALL_INSTRUCTIONS)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command executed")
            end
        end

        ("PF"),
        begin
            if (Settings.QueueType==MessageQueueType.Kafka) then
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            else
            begin
                xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.DELETE_FIRST_INSTRUCTION)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command executed")
            end
        end

        ("EQ"), ;Export queue
        begin
            if (Settings.QueueType==MessageQueueType.Kafka) then
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            else
            begin
                data inch = 0
                data outch = 0
                data exportFile = Settings.QueueFileName.Replace(".ISM",".TXT")

                if (ReplicationLibrary.File.Exists(exportFile))
                begin
                    ReplicationLibrary.File.Delete(exportFile)
                end

                try
                begin
                    open(inch,i:i,Settings.QueueFileName,SHARE:Q_EXCL_RW)
                    open(outch,o:s,exportFile)
                    repeat
                    begin
                        reads(inch,instruction)
                        writes(outch,%atrim(instruction(^size(instruction.transaction_id)+1,^size(instruction))))
                    end
                end
                catch (e, @EndOfFileException)
                begin
                    nop
                end
                catch (e, @Exception)
                begin
                    xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Failed to export instructions!")
                end
                finally
                begin
                    if (inch)
                        close inch
                    if (outch)
                        close outch
                end
                endtry
            end
        end

.ifndef D_VMS
        ("Q "),
        begin
            if (Settings.QueueType==MessageQueueType.Kafka) then
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            else
            begin
                data tmpvar, a1
                data chn, i4
                open(chn=0,"I:I",Settings.QueueFileName)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Queue length: " + %string(%isinfo(chn,"NUMRECS")))
                close chn
                xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
.ifdef DBLNET
                while (%w_info(WIF_TTSTS))
.else
                while (%ttsts)
.endc
                xcall w_disp(mainwnd,WD_ACCEPT,tmpvar)
                nextloop
            end
        end
.endc

        ("S "),
        begin
            data interval, a5
            xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOW,"Sleep interval (seconds): ")
            xcall w_disp(mainwnd,WD_READS,interval)

            if (interval) then
            begin
                if (%IsDecimalNoNegatives(^d(interval))) then
                begin
                    if (Settings.QueueType==MessageQueueType.Kafka) then
                    begin
.ifdef DBLNET
                        data kafkaMessage = new Message<string,string>() { Key="CHANGE_INTERVAL", Value=%atrimtostring(interval) }
                        data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                    end
                    else
                    begin
                        xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.CHANGE_INTERVAL,,%atrim(interval))
                    end
                    xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
                end
                else
                begin
                    xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid interval!")
                end
            end
            else
            begin
                nextloop
            end
        end

        ("I "),
        begin
            data ix = 0
            data row, i4, 4
            data col, i4, 2
            data name, string

            xcall w_disp(mainwnd,WD_POS,3,1,WD_CLR,WDC_EOW,"Instance Names")

            for ix from 1 thru Settings.ValidInstanceNames.Length
            begin
                xcall w_disp(mainwnd,WD_POS,row+=1,col,%string(ix,"ZX")," ",Settings.ValidInstanceNames[ix])
                if (row==21)
                begin
                    row=4
                    col+=20
                end
            end

            repeat
            begin
                data tmpvar, a2
                data newIndex, d2
                data status, i4
                data errorMessage, string

                xcall w_disp(mainwnd,WD_POS,23,1,WD_CLR,WDC_EOL,"Instance number (enter=no change): ",WD_READS,tmpvar)

                ;Blank means do nothing
                if (!tmpvar)
                    exitloop

                ;Make sure it's a number
                try
                begin
                    newIndex = tmpvar
                end
                catch (e, @BadDigitException)
                begin
                    nextloop
                end
                endtry

                ;Make sure it's in range
                if (newIndex < 1 || newIndex > Settings.ValidInstanceNames.Length)
                    nextloop

                ;Make sure it's not the current instance
                if (Settings.ValidInstanceNames[newIndex] .eqs. Settings.InstanceName)
                    exitloop

.ifdef DBLNET
                if (Settings.QueueType==MessageQueueType.Kafka)
                begin
                    ;Disconnect from the Kafka server
                    producer.Dispose()
                    producer = ^null
                end
.endc
                ;Change the instance
                Settings.InstanceName = Settings.ValidInstanceNames[newIndex]
                xcall setlog("REPLICATOR_INSTANCE",Settings.InstanceName,status)

                ;Load the new instances settings
                if (!Settings.Load(errorMessage))
                begin
                    Console.WriteLine("ERROR: Failed to load replication environment settings. Error was: " + errorMessage)
                    Console.Write("Press ENTER: ")
                    Console.ReadLine()
                    stop
                end
.ifdef DBLNET
                if (Settings.QueueType==MessageQueueType.Kafka)
                begin
                    ;Connect to the Kafka server
                    data conf = new ProducerConfig()
                    conf.BootstrapServers = Settings.KafkaServers
                    producer = new ProducerBuilder<string,string>(conf).Build()
                end
.endc
.ifdef D_GUI
                xcall w_caption(WC_SET,"SQL Replicator: Instance " + Settings.InstanceName)
.endc
                exitloop
            end
        end

        ("T "),
        begin
            data ix = 0
            data row, i4, 4
            data col, i4, 2
            data name, string

            xcall w_disp(mainwnd,WD_POS,3,1,WD_CLR,WDC_EOW,"Table Names")

            for ix from 1 thru Settings.ValidTableNames.Length
            begin
                xcall w_disp(mainwnd,WD_POS,row+=1,col,%string(ix,"ZX")," ",Settings.ValidTableNames[ix])
                if (row==21)
                begin
                    row=4
                    col+=20
                end
            end

            repeat
            begin
                data tmpvar, a2
                data newIndex, d2
                data status, i4
                data errorMessage, string

                xcall w_disp(mainwnd,WD_POS,23,1,WD_CLR,WDC_EOL,"Table number (enter=none): ",WD_READS,tmpvar)

                ;Blank no table selected
                if (!tmpvar)
                begin
                    tableName = ""
                    exitloop
                end

                ;Make sure it's a number
                try
                begin
                    newIndex = tmpvar
                end
                catch (e, @BadDigitException)
                begin
                    nextloop
                end
                endtry

                ;Make sure it's in range
                if (newIndex < 1 || newIndex > Settings.ValidTableNames.Length)
                    nextloop

                ;Make sure it's not the current table
                if (Settings.ValidTableNames[newIndex] == tableName)
                    exitloop

                ;Change the instance
                tableName = Settings.ValidTableNames[newIndex]

                exitloop
            end
        end

        ("R "),
        begin
            if (Settings.QueueType==MessageQueueType.Kafka) then
            begin
.ifdef DBLNET
                data kafkaMessage = new Message<string,string>() { Key="CYCLE_LOG", Value=tableName }
                data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
            end
            else
            begin
                xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.CYCLE_LOG)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command executed")
            end
        end

        ("C "),
        begin
            if (!String.IsNullOrWhiteSpace(tableName)) then
            begin
                if (Settings.QueueType==MessageQueueType.Kafka) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="CREATE_TABLE", Value=tableName }
                    data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.CREATE_TABLE,(a)tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command executed")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("L "),
        begin
            if (!String.IsNullOrWhiteSpace(tableName)) then
            begin
                if (Settings.QueueType==MessageQueueType.Kafka) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="LOAD_TABLE", Value=tableName }
                    data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.LOAD_TABLE,(a)tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("CL"),
        begin
            if (!String.IsNullOrWhiteSpace(tableName)) then
            begin
                if (Settings.QueueType==MessageQueueType.Kafka) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="CREATE_AND_LOAD_TABLE", Value=tableName }
                    data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE,(a)tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("BL"),
        begin
            if (!String.IsNullOrWhiteSpace(tableName)) then
            begin
                if (Settings.QueueType==MessageQueueType.Kafka) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="BULK_LOAD_TABLE", Value=tableName }
                    data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.BULK_LOAD_TABLE,(a)tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("BR"),
        begin
            if (!String.IsNullOrWhiteSpace(tableName)) then
            begin
                if (Settings.QueueType==MessageQueueType.Kafka) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="BULK_LOAD_FIRST_1000", Value=tableName }
                    data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.BULK_LOAD_FIRST_1000,(a)tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("BC"),
        begin
            if (!String.IsNullOrWhiteSpace(tableName)) then
            begin
                if (Settings.QueueType==MessageQueueType.Kafka) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="BULK_COPY_TABLE", Value=tableName }
                    data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.BULK_COPY_TABLE,(a)tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("AI"),
        begin
            if (!String.IsNullOrWhiteSpace(tableName)) then
            begin
                if (Settings.QueueType==MessageQueueType.Kafka) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="ADD_INDEXES", Value=tableName }
                    data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.ADD_INDEXES,(a)tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("DI"),
        begin
            if (!String.IsNullOrWhiteSpace(tableName)) then
            begin
                if (Settings.QueueType==MessageQueueType.Kafka) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="DELETE_INDEXES", Value=tableName }
                    data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.DELETE_INDEXES,(a)tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("TR"),
        begin
            if (!String.IsNullOrWhiteSpace(tableName)) then
            begin
                if (Settings.QueueType==MessageQueueType.Kafka) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="DELETE_ALL_ROWS", Value=tableName }
                    data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.DELETE_ALL_ROWS,(a)tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

.ifdef DBLNET
        ("TT"),
        begin
            ;Transform TEST
            using tableName select
            ("DEPARTMENT"),
            begin
                data transformData, string, %string(REPLICATION_TRANSFORM.EXTEND_ALPHA) + "|DeptName|60"
                xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.TRANSFORM_COLUMN,(a)tableName,transformData)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            ("EMPLOYEE"),
            begin
                data transformData, string, %string(REPLICATION_TRANSFORM.EXTEND_ALPHA) + "|EmpFirstName|25"
                xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.TRANSFORM_COLUMN,(a)tableName,transformData)
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            (),
            begin
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
            end
            endusing
        end
.endc
.ifdef DBLNET
        ("LT"),
        begin
            ;Load test
            data threadsPerWorker = 1 ;Do not set this to higher than 1 right now because code in xcall replicate,
            data secondsToRun = 10
            data testManager = new LoadTestManager(tableName,Settings.QueueType,threadsPerWorker,secondsToRun)
            testManager.RunTests().Wait()
        end
.endc
        ("D "),
        begin
            if (!String.IsNullOrWhiteSpace(tableName)) then
            begin
                if (Settings.QueueType==MessageQueueType.Kafka) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="DELETE_TABLE", Value=tableName }
                    data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.DELETE_TABLE,(a)tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("X "),
        begin
            if (!String.IsNullOrWhiteSpace(tableName)) then
            begin
                if (Settings.QueueType==MessageQueueType.Kafka) then
                begin
.ifdef DBLNET
                    data kafkaMessage = new Message<string,string>() { Key="CREATE_CSV", Value=tableName }
                    data deliveryResult = producer.ProduceAsync(Settings.KafkaTopicName,kafkaMessage).Result
.endc
                end
                else
                begin
                    xcall Replicate(Settings.InstanceName,REPLICATION_INSTRUCTION.CREATE_CSV,(a)tableName)
                end
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Command queued")
            end
            else
                xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")
        end

        ("E "),
            exitloop

        (),
            xcall w_disp(mainwnd,WD_POS,23,2,WD_CLR,WDC_EOL,"Invalid option!")

        endusing

        sleep 0.5
    end

.ifdef DBLNET
    if (Settings.QueueType==MessageQueueType.Kafka)
    begin
        producer.Dispose()
        producer = ^null
    end
.endc

    ;Shutdown Synergy Windows
    xcall w_disp(mainwnd,WD_POS,1,1,WD_CLR,WDC_WND)
    xcall w_exit

    ;Close the terminal
    close Settings.TerminalChannel

    stop

endmain

