;*****************************************************************************
;
; File:         replicator.dbl
;
; Type:         Application (SQL Replicator)
;
; Description:  Replicates Synergy data file changes that have been recorded
;               in the replucation log file to a SQL Server database.
;
;*****************************************************************************
;
; Copyright (c) 2008, Synergex International, Inc.
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;
; * Redistributions of source code must retain the above copyright notice,
;   this list of conditions and the following disclaimer.
;
; * Redistributions in binary form must reproduce the above copyright notice,
;   this list of conditions and the following disclaimer in the documentation
;   and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
; POSSIBILITY OF SUCH DAMAGE.
;
;*****************************************************************************

.ifdef DBLNET
import Confluent.Kafka
.endc
import ReplicationLibrary
import System.Collections
.ifdef DBLNET
import Microsoft.Data.SqlClient
.include "REPLICATION_TRANSFORM" repository, enum, end
.endc

main replicator

    .include "CONNECTDIR:ssql.def"
    .include "REPLICATOR_INCLUDE:SmtpMail.def"
.ifdef D_VMS
    .include "REPLICATION_VMS" repository, record="instruction", end
.else
    .include "REPLICATION" repository, record="instruction",end
.endc

.align
    record
        ok,                         boolean             ;Main status
        noMoreInstructions,         boolean             ;End of instruction file
        switchMode,                 boolean             ;Switched from INSERT to UPDATE or vice versa
        switchDone,                 boolean             ;Have we tried to switch modes before?
        bulkLoad,                   boolean             ;Use bulk load?
        bulkCopy,                   boolean             ;Use bulk copy?
        doCheckCommit,              boolean             ;Do we need to check if it's time to commit?
        doForceCommit,              boolean             ;Do we need to force a commit?
        shutdownRequested,          boolean             ;A shutdown instruction was received and processed
        doReturn,                   boolean             ;Need to return from the current internal subroutine
        nsptr,                      i4                  ;Namespace pointer
        status,                     i4                  ;General working status return
        rows,                       i4                  ;Number of rows affected
        oldSleepTime,               i4                  ;Previous sleep time value
        maxRowsToLoad,              i4                  ;Maximum rows to load
        recordCount,                i4                  ;Number of records in a file
        functionName,               string              ;External function to call
        keyValue,                   a256                ;Key value of the current ISAM record
        keyLength,                  i4                  ;Key length of the current ISAM record
        recordNumber,               d28                 ;Record number of the current relative record
        dberrtxt,                   a1024               ;Error text from a failed database call
        structure_data,             strStructureData    ;Data stored for each structure
        uncommittedInstructions,    @ArrayList          ;RFA's of any operation instructions pending commit
        unboxedRfa,                 a6                  ;RFA of instruction record
        boxedRfa,                   @a                  ;A boxed RFA value
.ifdef DBLNET
        kafkaMessage,               @ConsumeResult<string,string>
.endc
    endrecord

    external function
        xsubr,  ^val
    endexternal

proc
    ;Check that we have the basic environment that we need
    begin
        data errorMessage, string
        if (!(ok = %ValidateBasicEnvironment(errorMessage)))
        begin
            Console.WriteLine("Basic environment not established. " + errorMessage)
        end
    end

    ;If we get here then logging is active, and the following settings are already in place:
    ;   Settings.InstanceName
    ;   Settings.QueueFileName
    ;   Settings.LogFileName
    ;   Settings.KafkaTopicName
    ;   Default values for all other settings

    if (ok && (ok = %ConfigureEnvironment))
    begin
        ;Register a shutdown handler that will be called when the process exits.
        ;This code does NOT need to be called if the shutdown has been requested by an instruction and processed below.
        ;This is only really to cover the case of a "service" being shut down by the service control manager.
        if (ok && !Settings.RunningOnTerminal)
        begin
.ifdef DBLNET
            lambda shutdownHandler(sender, e)
            begin
                xcall ReplicatorShutdown
            end
            AppDomain.CurrentDomain.ProcessExit += shutdownHandler
.else
            xcall syn_atexit(%xaddr("ReplicatorShutdown"))
.endc
        end

        ;If we're in batch commit mode then initialize a collection to store the RFA's of pending operations
        if (Settings.DatabaseCommitMode == DatabaseCommitMode.Batch)
        begin
            uncommittedInstructions = new ArrayList()
        end

        ;Main processing loop
        repeat
        begin
            ;Get the next instruction from the queue
            repeat
            begin
                using Settings.QueueType select
                ;-------------------------------------------------------------------------------
                (MessageQueueType.IsamFile),
                begin
                    ;Next ISAM message
                    try
                    begin
                        reads(Settings.InstructionChannel,instruction,,LOCK:Q_AUTO_LOCK,GETRFA:unboxedRfa)
                        noMoreInstructions = false

                        ;In batch commit mode, add the instructions RFA to the list of records to be deleted on commit
                        if (Settings.DatabaseCommitMode == DatabaseCommitMode.Batch)
                        begin
                            uncommittedInstructions.Add((@a)unboxedRfa)
                        end

                        exitloop
                    end
                    catch (ex, @EndOfFileException)
                    begin
                        noMoreInstructions = true
                        exitloop
                    end
                    catch (ex, @RecordLockedException)
                    begin
                        sleep Settings.ErrorSleepTime
                        nextloop
                    end
                    catch (ex, @NetworkException); $ERR_NETPROB (320)
                    begin
                        if (%ReOpenQueueFile) nextloop
                    end
                    catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                    begin
                        if (%ReOpenQueueFile) nextloop
                    end
                    endtry
                end
.ifdef DBLNET
                ;-------------------------------------------------------------------------------
                (MessageQueueType.Kafka),
                begin
                    ;Next Kafka message
                    try
                    begin
                        kafkaMessage = Settings.KafkaConsumer.Consume(TimeSpan.FromSeconds(Settings.SleepTime))

                        ;Did our sleep timer fire?
                        if (kafkaMessage == ^null)
                        begin
                            noMoreInstructions = true
                            exitloop
                        end

                        ;We received a message. Populate the instruction record

                        using kafkaMessage.Key select
                        ("CREATE_ROW"),
                        begin
                            ;TODO: Needs implementing
                            instruction.action = (i)REPLICATION_INSTRUCTION.CREATE_ROW
                            instruction.structure_name = ""
                            instruction.record = ""
                        end
                        ("UPDATE_ROW"),
                        begin
                            ;TODO: Needs implementing
                            instruction.action = (i)REPLICATION_INSTRUCTION.UPDATE_ROW
                            instruction.structure_name = ""
                            instruction.record = ""
                        end
                        ("DELETE_ROW"),
                        begin
                            ;TODO: Needs implementing
                            instruction.action = (i)REPLICATION_INSTRUCTION.DELETE_ROW
                            instruction.structure_name = ""
                            instruction.record = ""
                        end
                        ("CREATE_TABLE"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.CREATE_TABLE
                            instruction.structure_name = kafkaMessage.Value
                            instruction.record = ""
                        end
                        ("LOAD_TABLE"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.LOAD_TABLE
                            instruction.structure_name = kafkaMessage.Value
                            instruction.record = ""
                        end
                        ("CREATE_AND_LOAD_TABLE"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE
                            instruction.structure_name = kafkaMessage.Value
                            instruction.record = ""
                        end
                        ("DELETE_ALL_ROWS"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.DELETE_ALL_ROWS
                            instruction.structure_name = kafkaMessage.Value
                            instruction.record = ""
                        end
                        ("DELETE_TABLE"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.DELETE_TABLE
                            instruction.structure_name = kafkaMessage.Value
                            instruction.record = ""
                        end
                        ("SHUTDOWN"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.SHUTDOWN
                            instruction.structure_name = ""
                            instruction.record = ""
                        end
                        ("INSERT_RELATIVE"),
                        begin
                            ;TODO: Needs implementing
                            instruction.action = (i)REPLICATION_INSTRUCTION.INSERT_RELATIVE
                            instruction.structure_name = ""
                            instruction.record = ""
                        end
                        ("UPDATE_RELATIVE"),
                        begin
                            ;TODO: Needs implementing
                            instruction.action = (i)REPLICATION_INSTRUCTION.UPDATE_RELATIVE
                            instruction.structure_name = ""
                            instruction.record = ""
                        end
                        ("ADD_INDEXES"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.ADD_INDEXES
                            instruction.structure_name = kafkaMessage.Value
                            instruction.record = ""
                        end
                        ("DELETE_INDEXES"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.DELETE_INDEXES
                            instruction.structure_name = kafkaMessage.Value
                            instruction.record = ""
                        end
                        ("BULK_LOAD_TABLE"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.BULK_LOAD_TABLE
                            instruction.structure_name = kafkaMessage.Value
                            instruction.record = ""
                        end
                        ("BULK_LOAD_FIRST_1000"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.BULK_LOAD_FIRST_1000
                            instruction.structure_name = kafkaMessage.Value
                            instruction.record = ""
                        end
                        ("BULK_COPY_TABLE"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.BULK_COPY_TABLE
                            instruction.structure_name = kafkaMessage.Value
                            instruction.record = ""
                        end
;TODO: Not supported in Kafka mode. Need to commit the message to prevent getting it again then nextloop!
;                        ("DELETE_ALL_INSTRUCTIONS"),
;                        begin
;                            instruction.action = (i)REPLICATION_INSTRUCTION.DELETE_ALL_INSTRUCTIONS
;                            instruction.structure_name = ""
;                            instruction.record = ""
;                        end
;TODO: Not supported in Kafka mode. Need to commit the message to prevent getting it again then nextloop!
;                        ("CLOSE_FILE"),
;                        begin
;                            instruction.action = (i)REPLICATION_INSTRUCTION.CLOSE_FILE
;                            instruction.structure_name = ""
;                            instruction.record = ""
;                        end
                        ("CHANGE_INTERVAL"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.CHANGE_INTERVAL
                            instruction.structure_name = ""
                            instruction.record = kafkaMessage.Value
                        end
                        ("CREATE_CSV"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.CREATE_CSV
                            instruction.structure_name = kafkaMessage.Value
                            instruction.record = ""
                        end
                        ("CYCLE_LOG"),
                        begin
                            instruction.action = (i)REPLICATION_INSTRUCTION.CYCLE_LOG
                            instruction.structure_name = ""
                            instruction.record = ""
                        end
;TODO: Not supported in Kafka mode. Need to commit the message to prevent getting it again then nextloop!
;                        ("OPEN_FILE"),
;                        begin
;                            instruction.action = (i)REPLICATION_INSTRUCTION.OPEN_FILE
;                            instruction.structure_name = ""
;                            instruction.record = ""
;                        end
;TODO: Not supported in Kafka mode. Need to commit the message to prevent getting it again then nextloop!
;                        ("DELETE_FIRST_INSTRUCTION"),
;                        begin
;                            instruction.action = (i)REPLICATION_INSTRUCTION.DELETE_FIRST_INSTRUCTION
;                            instruction.structure_name = ""
;                            instruction.record = ""
;                        end
                        ("TRANSFORM_COLUMN"),
                        begin
                            ;TODO: Needs implementing
                            instruction.action = (i)REPLICATION_INSTRUCTION.TRANSFORM_COLUMN
                            instruction.structure_name = ""
                            instruction.record = ""
                        end
                        endusing

                        noMoreInstructions = false

                        ;TODO: Figure out what this looks like in Kafka
                        ;In batch commit mode, add the instructions RFA to the list of records to be deleted on commit
                        ;if (Settings.DatabaseCommitMode == DatabaseCommitMode.Batch)
                        ;begin
                        ;    uncommittedInstructions.Add((@a)unboxedRfa)
                        ;end

                        exitloop
                    end
                    catch (ex, @ConsumeException)
                    begin
                        ;TODO: Figure out what to do here. Close and re-open the connection to the Kafka server?

                        sleep 0.05


                    end
                    endtry
                end
.endc
                endusing
                ;-------------------------------------------------------------------------------
            end ;of inner repeat (get next instruction)

            if (noMoreInstructions) then
            begin
                ;The queue is currently empty. If we're in batch commit mode then commit any outstanding changes
                if ((Settings.DatabaseCommitMode == DatabaseCommitMode.Batch) && (Counters.BatchCounter > 0))
                begin
                    call CommitTransaction
                end

                using Settings.QueueType select
                (MessageQueueType.IsamFile),
                begin
                    ;And sleep for a while before trying again
                    sleep Settings.SleepTime

                    ;Reset to beginning of file
                    repeat
                    begin
                        try
                        begin
                            find(Settings.InstructionChannel,,^FIRST,LOCK:Q_NO_LOCK)
                            exitloop
                        end
                        catch (ex, @EndOfFileException); Instruction queue is empty
                        begin
                            exitloop
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile)
                                nextloop
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile)
                                nextloop
                        end
                        endtry
                    end
                end
.ifdef DBLNET
                (MessageQueueType.Kafka),
                begin
                    ;Nothing more to do here because the sleep delay is built in to the "Consume" operation above
                    nop
                end
.endc
                endusing
            end
            else
            begin
                ;We received an instruction

                ;Any action with a negative value has been co-opted to signify a shutdown request.
                if (instruction.action < 0)
                begin
                    ;Restore the recorded action to it's original (positive) value
                    instruction.action = -instruction.action

                    repeat
                    begin
                        try
                        begin
                            write(Settings.InstructionChannel,instruction)
                            exitloop
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        endtry
                    end

                    ;And shutdown
                    Logger.Log("Shutdown requested")
                    xcall ReplicatorShutdown
                end

                ;We have an instruction to process

                doCheckCommit = false
                doForceCommit = false
                switchDone = false

                ;If this is a routine request (create/update/delete) then do
                ;file and table checks to ensure we have the file open and the
                ;database table exists
                if    ((instruction.action==(i)REPLICATION_INSTRUCTION.CREATE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.DELETE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.INSERT_RELATIVE)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_RELATIVE)
                &    )
                begin
                    ;Check if we already have the file open
                    call CheckFileTable

                    ;If we failed to check the table for the file then we probably have a configuration problem
                    if (!status)
                    begin
                        Logger.ErrorLog("Abnormal replicator shutdown!")
                        exitloop
                    end
                end

                ;Execute the instruction

                using (instruction.action) select

                ;"Routine" processing requests

                (REPLICATION_INSTRUCTION.CREATE_ROW),
                begin
                    Logger.VerboseLog("Insert row in table " + %atrim(instruction.structure_name))
                    call DoInsert
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.UPDATE_ROW),
                begin
                    Logger.VerboseLog("Update row in table " + %atrim(instruction.structure_name))
                    call DoUpdate
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_ROW),
                begin
                    Logger.VerboseLog("Delete row from table " + %atrim(instruction.structure_name))
                    call DoDelete
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.INSERT_RELATIVE),
                begin
                    Logger.VerboseLog("Insert row in table " + %atrim(instruction.structure_name))
                    call DoInsertRelative
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.UPDATE_RELATIVE),
                begin
                    Logger.VerboseLog("Update row in table " + %atrim(instruction.structure_name))
                    call DoUpdateRelative
                    doCheckCommit = true
                end

                ;"Special" processing requests

                (REPLICATION_INSTRUCTION.ADD_INDEXES),
                begin
                    Logger.Log("Add indexes to table " + %atrim(instruction.structure_name))
                    call DoAddIndexes
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CREATE_TABLE),
                begin
                    Logger.Log("Create table " + %atrim(instruction.structure_name))
                    call DoCreateTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.LOAD_TABLE),
                begin
                    Logger.Log("Load table " + %atrim(instruction.structure_name))
                    bulkLoad = false
                    bulkCopy = false
                    maxRowsToLoad = 0
                    call DoLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.BULK_LOAD_TABLE),
                begin
                    bulkCopy = false
                    if (bulkLoad = Settings.CanBulkLoad()) then
                        Logger.Log("Bulk load table " + %atrim(instruction.structure_name))
                    else
                    begin
                        Logger.Log("Bulk load requested but unavailable!")
                        Logger.Log("Load table " + %atrim(instruction.structure_name))
                    end
                    maxRowsToLoad = 0
                    call DoLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.BULK_LOAD_FIRST_1000),
                begin
                    bulkCopy = false
                    if (bulkLoad = Settings.CanBulkLoad()) then
                    begin
                        Logger.Log("Bulk load 1000 records to table " + %atrim(instruction.structure_name))
                    end
                    else
                    begin
                        Logger.Log("Bulk load 1000 records requested but unavailable!")
                        Logger.Log("Load 1000 records to table " + %atrim(instruction.structure_name))
                    end
                    maxRowsToLoad = 1000
                    call DoLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.BULK_COPY_TABLE),
                begin
                    bulkLoad = false
                    if (bulkCopy = Settings.CanBulkCopy()) then
                        Logger.Log("Bulk copy table " + %atrim(instruction.structure_name))
                    else
                    begin
                        Logger.Log("Bulk copy requested but unavailable!")
                        Logger.Log("Load table " + %atrim(instruction.structure_name))
                    end
                    maxRowsToLoad = 0
                    call DoLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE),
                begin
                    Logger.Log("Create and load table " + %atrim(instruction.structure_name))
                    call DoCreateAndLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CREATE_CSV),
                begin
                    Logger.Log("Export table " + %atrim(instruction.structure_name) + " to delimited file")
                    call DoCreateCsv
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_ALL_ROWS),
                begin
                    Logger.Log("Truncate table " + %atrim(instruction.structure_name))
                    call DoDeleteAllRows
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_INDEXES),
                begin
                    Logger.Log("Remove indexes from table " + %atrim(instruction.structure_name))
                    call DoDeleteIndexes
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_TABLE),
                begin
                    Logger.Log("Delete table " + %atrim(instruction.structure_name))
                    call DoDeleteTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CHANGE_INTERVAL),
                begin
                    Logger.Log("Change processing interval")
                    oldSleepTime = Settings.SleepTime
                    try
                    begin
                        Settings.SleepTime = %integer(%atrim(instruction.record))
                        if (Settings.SleepTime >= 1) then
                        begin
                            Logger.Log(" - Interval changed from " + %string(oldSleepTime) + " to " + %string(Settings.SleepTime) + " seconds")
                        end
                        else
                        begin
                            Logger.ErrorLog(" - Invalid interval of " + %string(Settings.SleepTime) + " seconds requested")
                            Settings.SleepTime = oldSleepTime
                        end
                    end
                    catch (ex)
                    begin
                        Logger.ErrorLog(" - Invalid interval " + %atrim(instruction.record) + " requested")
                        Settings.SleepTime = oldSleepTime
                    end
                    endtry
                end

                (REPLICATION_INSTRUCTION.CYCLE_LOG),
                begin
                    Logger.Log("Cycle log file")
                    Logger.CycleLog()
                end

                (REPLICATION_INSTRUCTION.TRANSFORM_COLUMN),
                begin
                    ;transFormData will be in the format <instruction#>|<columnName>|<optionalOtherData>
                    data tableName = %atrimtostring(instruction.structure_name)
                    data transformDataPartsString = %atrimtostring(instruction.record)
                    data transformDataParts = transformDataPartsString.Split("|")
                    data transformType = (REPLICATION_TRANSFORM)%integer(transformDataParts[1])
                    data columnName = transformDataParts[2]
                    data transformData = transformDataParts.Length == 3 ? transformDataParts[3] : ""
                    data errorMessage, string
                    data transformSuccess = false

                    Logger.Log("Transform column " + tableName + "." + columnName)

                    using Settings.DatabaseConnectMode select
                    (DatabaseConnectionMode.SqlConnection),
                    begin
                        transformSuccess = %DatabaseTransformSqlConnection(transformType,tableName,columnName,transformData,errorMessage)
                    end
.ifdef DBLNET
                    (DatabaseConnectionMode.SqlClient),
                    begin
                        transformSuccess = %DatabaseTransformSqlClient(transformType,tableName,columnName,transformData,errorMessage)
                    end
.endc
                    endusing

                    if (transformSuccess) then
                    begin
                        doForceCommit = true
                    end
                    else
                    begin
                        Logger.ErrorLog("Failed to transform column! Error was " + %atrimtostring(errorMessage))
                    end
                end

                (REPLICATION_INSTRUCTION.SHUTDOWN),
                begin
                    Logger.Log("Shutdown requested")

                    ;Delete the "Shutdown" instruction from the queue

                    using Settings.QueueType select
                    ;-------------------------------------------------------------------------------
                    (MessageQueueType.IsamFile),
                    begin
                        repeat
                        begin
                            try
                            begin
                                delete(Settings.InstructionChannel)
                                exitloop
                            end
                            catch (ex, @NetworkException); $ERR_NETPROB (320)
                            begin
                                if (%ReOpenQueueFile)
                                begin
                                    ;Re-read and lock the instruction record. What if THIS fails????
                                    read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                    nextloop
                                end
                            end
                            catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                            begin
                                if (%ReOpenQueueFile)
                                begin
                                    ;Re-read and lock the instruction record. What if THIS fails????
                                    read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                    nextloop
                                end
                            end
                            endtry
                        end
                    end
.ifdef DBLNET
                    ;-------------------------------------------------------------------------------
                    (MessageQueueType.Kafka),
                    begin
                        try
                        begin
                            Settings.KafkaConsumer.Commit(kafkaMessage)
                        end
                        catch (ex, @KafkaException)
                        begin
                            ;Thrown if the request failed
                            ;TODO: Now what?


                        end
                        catch (ex, @TopicPartitionOffsetException)
                        begin
                            ;Thrown if the result is in error
                            ;TODO: Now what?


                        end
                        endtry
                    end
.endc
                    endusing
                    ;-------------------------------------------------------------------------------

                    xcall ReplicatorShutdown
                end

                endusing

                ;If we're in batch commit mode, do we need to commit?
                if (Settings.DatabaseCommitMode == DatabaseCommitMode.Batch) then
                begin
                    using Settings.QueueType select
                    ;-------------------------------------------------------------------------------
                    (MessageQueueType.IsamFile),
                    begin
                        ;In batch commit mode we don't delete instructions until the batch has been committed
                        try
                        begin
                            unlock Settings.InstructionChannel
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile) nop
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile) nop
                        end
                        endtry
                    end
.ifdef DBLNET
                    ;-------------------------------------------------------------------------------
                    (MessageQueueType.Kafka),
                    begin
                        ;TODO: Figure out how to commit all the kafka messages associated with the current batch



                    end
.endc
                    endusing
                    ;-------------------------------------------------------------------------------

                    ;This logic may look a little "hokey", but there is a reason for it!
                    if ((doForceCommit && (Counters.BatchCounter+=1)) || (doCheckCommit && ((Counters.BatchCounter += 1) == Settings.CommitBatchSize)))
                    begin
                        call CommitTransaction
                    end
                end
                else
                begin
                    ;Delete the instruction

                    using Settings.QueueType select
                    ;-------------------------------------------------------------------------------
                    (MessageQueueType.IsamFile),
                    begin
                        try
                        begin
                            delete(Settings.InstructionChannel)
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        endtry
                    end
.ifdef DBLNET
                    ;-------------------------------------------------------------------------------
                    (MessageQueueType.Kafka),
                    begin
                        try
                        begin
                            Settings.KafkaConsumer.Commit(kafkaMessage)
                        end
                        catch (ex, @KafkaException)
                        begin
                            ;Thrown if the request failed
                            ;TODO: Now what?


                        end
                        catch (ex, @TopicPartitionOffsetException)
                        begin
                            ;Thrown if the result is in error
                            ;TODO: Now what?


                        end
                        endtry
                    end
.endc
                    endusing
                    ;-------------------------------------------------------------------------------
                end
            end
        end
    end

    ;Close the database
    xcall DatabaseDisconnect

    ;Release the namespace
    if (Settings.ChannelInfo)
    begin
        xcall nspc_close(Settings.ChannelInfo)
    end

    ;Close the instruction queue

    using Settings.QueueType select
    ;-------------------------------------------------------------------------------
    (MessageQueueType.IsamFile),
    begin
        if (Settings.InstructionChannel)
        begin
            close Settings.InstructionChannel
            Settings.InstructionChannel = 0
        end
    end
.ifdef DBLNET
    ;-------------------------------------------------------------------------------
    (MessageQueueType.Kafka),
    begin
        Settings.KafkaConsumer.Close()
        Settings.KafkaConsumer.Dispose()
        Settings.KafkaConsumer = ^null
    end
.endc
    endusing
    ;-------------------------------------------------------------------------------

    ;All done
    stop

    ;-----------------------------------------------------------------------------
    ; Commit the current transaction and start a new one (only used in batch transaction mode)
    ;
CommitTransaction,

    Logger.VerboseLog(" - Committing transaction batch with " + %string(Counters.BatchCounter) + " change(s)")

    using Settings.DatabaseConnectMode select

    (DatabaseConnectionMode.SqlConnection),
    begin
        data tmpmsg, a128
        if (%CommitTransactionSqlConnection(Settings.DatabaseChannel,tmpmsg)) then
        begin
            ;TODO: This code is duplicated below but can't be turned into an internal subroutine because of "label"

            ;Delete all of the associated instructions from the queue file.
            foreach boxedRfa in uncommittedInstructions
            begin
                unboxedRfa = (a)boxedRfa
                try
                begin
                    read(Settings.InstructionChannel,instruction,,LOCK:Q_AUTO_LOCK,RFA:unboxedRfa)
                    delete(Settings.InstructionChannel)
                end
                catch (ex, @NetworkException); $ERR_NETPROB (320)
                begin
                    if (%ReOpenQueueFile) nextloop
                end
                catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                begin
                    if (%ReOpenQueueFile) nextloop
                end
                catch (e, @Exception)
                begin
                    ;This can happen from time to time, because some "special"
                    ;instructions like "change interval" and "cycle log" are deleted
                    ;from the queue immediately even though the rfa has already been
                    ;recorded. Just ignore it.
                    nop
                end
                endtry
            end

            uncommittedInstructions.Clear()

            Counters.BatchCommits += 1
            Counters.BatchCounter = 0
        end
        else
        begin
            ;TODO: ENHANCEMENT: Commit failed - now what?
            Logger.ErrorLog("Failed to commit batch!")
        end
    end
.ifdef DBLNET
    (DatabaseConnectionMode.SqlClient),
    begin
        ;Commit the current transaction
        Settings.CurrentTransaction.Commit()
        Settings.CurrentTransaction.Dispose()

        ;Delete all of the associated instructions from the queue file.
        foreach boxedRfa in uncommittedInstructions
        begin
            unboxedRfa = (a)boxedRfa
            try
            begin
                read(Settings.InstructionChannel,instruction,,LOCK:Q_AUTO_LOCK,RFA:unboxedRfa)
                delete(Settings.InstructionChannel)
            end
            catch (ex, @NetworkException); $ERR_NETPROB (320)
            begin
                if (%ReOpenQueueFile)
                    nextloop
            end
            catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
            begin
                if (%ReOpenQueueFile)
                    nextloop
            end
            catch (e, @Exception)
            begin
                ;This can happen from time to time, because some "special"
                ;instructions like "change interval" and "cycle log" are deleted
                ;from the queue immediately even though the rfa has already been
                ;recorded. Just ignore it.
                nop
            end
            endtry
        end

        uncommittedInstructions.Clear()

        ;Start a new transaction

        Settings.CurrentTransaction = Settings.DatabaseConnection.BeginTransaction()

        Counters.BatchCommits += 1
        Counters.BatchCounter = 0
    end
.endc
    endusing

    return

    ;-----------------------------------------------------------------------------
    ; Check if we have already opened this file in this process
    ;
CheckFileTable,

    ;If there is an entry for the file in our namespace then we're good to go

    if (nsptr = %nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data))
    begin
        status = true
        return
    end

    Logger.VerboseLog("First instruction checks for table " + %atrim(instruction.structure_name))

    ;Make sure the table exists in the database

    call CheckTable

    ;If we failed verify the table then we have a serious problem!

    if (!status)
    begin
        Logger.ErrorLog("Failed to verify table status for structure " + %atrim(instruction.structure_name))
        return
    end

    ;Get the record size of the file
    functionName = %atrim(instruction.structure_name) + "Length"
    structure_data.structure_size = %xsubr(functionName)

    ;Get the type of the file
    functionName = %atrim(instruction.structure_name) + "Type"
    xcall xsubr(functionName,structure_data.structure_type)

    using structure_data.structure_type select

    ("DBL ISAM"),
    begin
        ;Get the key number of the first unique key. There should always be one, because without
        ;one the constructor in the I/O hooks class would not activate replication for the file.
        functionName = %atrim(instruction.structure_name) + "KeyNum"
        structure_data.structure_keynum = %xsubr(functionName)

        ;Report the key that will be used
        Logger.VerboseLog(" - Key " + %string(structure_data.structure_keynum) + " will be used to synchronize data")

        ;And save the structure name
        structure_data.structure_name = instruction.structure_name

        ;Record the table in the namespace
        nsptr = %nspc_add(Settings.ChannelInfo,instruction.structure_name,structure_data)
    end

    ("RELATIVE"),
    begin
        ;Report that record numbers will be used
        Logger.VerboseLog(" - Record numbers will be used to synchronize data")

        ;Set the key number to -1 to prevent it being used accidentally
        structure_data.structure_keynum = -1

        ;And save the structure name
        structure_data.structure_name = instruction.structure_name

        ;Record the table in the namespace
        nsptr = %nspc_add(Settings.ChannelInfo,instruction.structure_name,structure_data)
    end

    endusing

    return

    ;-----------------------------------------------------------------------------
    ; Find out if a table exists in the SQL database. If not create and load it.
    ;
CheckTable,

    Logger.VerboseLog(" - Checking if table exists")

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Exists"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Exists"
    endusing

    repeat
    begin
        data doReturn, boolean, false
        try
        begin
            status = %xsubr(functionName,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            doReturn = true ;Can't return out of a try in .NET
        end
        endtry

        if (doReturn)
            return
    end

    using status select
    (1),
    begin
        Logger.VerboseLog(" - Table exists")
    end
    (0),
    begin
        Logger.VerboseLog(" - Table not found!")
        call CreateTable
    end
    (<0),
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end
    endusing

    return

    ;-----------------------------------------------------------------------------
    ; Create and load a new table in the SQL database
    ; This code is only used when doing an initial check for a table because of
    ; a first replication instruction. Explicit CREATE_TABLE instructions are
    ; handled by DoCreateTable.
    ;
CreateTable,

    Logger.Log(" - Creating table")

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Create"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Create"
    endusing

    repeat
    begin
        data doReturn, boolean, false
        try
        begin
            status = %xsubr(functionName,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    if (status) then
    begin
        ;Now do an initial load of the data
        if (Settings.CanBulkCopy()) then
        begin
            bulkCopy = true
            bulkLoad = false
            call BulkLoadTable
        end
        else if (Settings.CanBulkLoad()) then
        begin
            bulkCopy = false
            bulkLoad = true
            call BulkLoadTable
        end
        else
        begin
            call LoadTable
        end
    end
    else
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end

    return

    ;-----------------------------------------------------------------------------
    ; Perform an initial load of a new table in the SQL database
    ;
LoadTable,

    try
    begin
        doReturn = false
        functionName = %atrim(instruction.structure_name) + "Recs"
        status = %xsubr(functionName,recordCount,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
        doReturn = true
    end
    endtry

    if (doReturn)
        return

    Logger.Log(" - Load starting at " + %TimeNow + " with " + %string(recordCount) + " rows")

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Load"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Load"
    endusing

    if (EmailSettings.CanSendEmail())
    begin
        data subject, string, "SQL replicator " + Settings.InstanceName + " is loading table " + %atrim(instruction.structure_name) + " with " + %string(recordCount) + " rows"
        xcall SendEmail(subject,^null,false)
    end

    repeat
    begin
        clear status

        try
        begin
            data successCount,  int
            data failCount,     int,0

            status = %xsubr(functionName,maxRowsToLoad,successCount,failCount,dberrtxt)

            if (status) then
            begin
                Logger.Log(" - " + %string(successCount) + " rows inserted, " + %string(failCount) + " failed.")

                Counters.Inserts += successCount
                Counters.Errors  += failCount

                if (EmailSettings.CanSendEmail())
                begin
                    data subject, string, "SQL replicator " + Settings.InstanceName + " has finished loading table " + %atrim(instruction.structure_name)
                    data body = new string[2]
                    body[1] = "Rows inserted: " + %string(successCount - failCount)
                    body[2] = "Rows failed:   " + %string(failCount)
                    xcall SendEmail(subject,body,false)
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)

                if (EmailSettings.CanSendEmail())
                begin
                    data subject, string, "ERROR: SQL replicator " + Settings.InstanceName + " failed to complete load of table " + %atrim(instruction.structure_name)
                    data body = new string[1]
                    body[1] = "Error was: " + %atrimtostring(dberrtxt)
                    xcall SendEmail(subject,body,false)
                end
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    ;Now add alternate key indexes
    if (ok && status)
    begin
        call DoAddIndexes
    end

    return

    ;-----------------------------------------------------------------------------
    ; Perform a bulk load of a table from a delimited text file.
    ;
BulkLoadTable,

    try
    begin
        doReturn = false
        functionName = %atrim(instruction.structure_name) + "Recs"
        status = %xsubr(functionName,recordCount,dberrtxt)
    end
    catch (ex, @SynException)
    begin
        ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
        doReturn = true
    end
    endtry

    if (doReturn)
        return

    if (bulkCopy) then
        Logger.Log(" - Bulk copy starting at " + %TimeNow + " with " + %string(recordCount) + " rows")
    else if (bulkLoad)
        Logger.Log(" - Bulk load starting at " + %TimeNow + " with " + %string(recordCount) + " rows")

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
    begin
        functionName = %atrim(instruction.structure_name) + "BulkLoad"
    end
    (DatabaseConnectionMode.SqlClient),
    begin
        if (bulkCopy) then
            functionName = %atrim(instruction.structure_name) + "_BulkCopy"
        else if (bulkLoad)
            functionName = %atrim(instruction.structure_name) + "_BulkLoad"
    end
    endusing

    if (EmailSettings.CanSendEmail())
    begin
        data subject, string, "SQL replicator " + Settings.InstanceName + " is loading table " + %atrim(instruction.structure_name) + " with " + %string(recordCount) + " rows"
        xcall SendEmail(subject,^null,false)
    end

    repeat
    begin
        clear status

        try
        begin
            data totalRows, int, 0
            data failRows,  int, 0

            status = %xsubr(functionName,maxRowsToLoad,totalRows,failRows,dberrtxt)

            if (status) then
            begin
                Logger.Log("   - " + %string(totalRows) + " rows inserted, " + %string(failRows) + " failed.")

                Counters.Inserts += totalRows - failRows
                Counters.Errors  += failRows

                if (EmailSettings.CanSendEmail())
                begin
                    data subject, string, "SQL replicator " + Settings.InstanceName + " has finished loading table " + %atrim(instruction.structure_name)
                    data body = new string[2]
                    body[1] = "Rows inserted: " + %string(totalRows - failRows)
                    body[2] = "Rows failed:   " + %string(failRows)
                    xcall SendEmail(subject,body,false)
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)

                if (EmailSettings.CanSendEmail())
                begin
                    data subject, string, "ERROR: SQL replicator " + Settings.InstanceName + " failed to load table " + %atrim(instruction.structure_name)
                    data body = new string[1]
                    body[1] = "Error was: " + %atrimtostring(dberrtxt)
                    xcall SendEmail(subject,body,false)
                end
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    ;Now add alternate key indexes
    if (ok && status)
    begin
        call DoAddIndexes
    end

    return

    ;-----------------------------------------------------------------------------
    ; Add a new row (ISAM)
    ;
DoInsert,

    if (switchMode) then
    begin
        Logger.VerboseLog(" - Insert row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeyValues)
        begin
            functionName = %atrim(instruction.structure_name) + "KeyVal"
            status = %xsubr(functionName,instruction.record,keyValue,keyLength)
            Logger.VerboseLog(" - Key: " + keyValue(1:keyLength))
        end
    end

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Insert"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Insert"
    endusing

    repeat
    begin
        data doReturn, boolean, false

        try
        begin
            status = %xsubr(functionName,instruction.record(1,structure_data.structure_size),dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    using status select
    (0),
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end
    (1),
    begin
        Logger.VerboseLog(" - Row inserted")
        Counters.Inserts += 1
    end
    (2),
    begin
        Logger.VerboseLog(" - Row exists, switching to UPDATE")
        status = 1
        if (switchDone) then
        begin
            Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
        end
        else
        begin
            switchMode = true
            call DoUpdate
        end
    end
    endusing

    return

    ;-----------------------------------------------------------------------------
    ; Add a new row (RELATIVE)
    ;
DoInsertRelative,

    if (switchMode) then
    begin
        Logger.VerboseLog(" - Insert row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeyValues)
        begin
            data pos,   i4, %instr(1,instruction.record,":")
            recordNumber = instruction.record(1:pos-1)
            instruction.record = instruction.record(pos+1:structure_data.structure_size)
            Logger.VerboseLog(" - Record #: " + %string(recordNumber))
        end
    end

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Insert"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Insert"
    endusing

    repeat
    begin
        data doReturn, boolean, false

        try
        begin
            status = %xsubr(functionName,recordNumber,instruction.record(1,structure_data.structure_size),dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    using status select
    (0),
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end
    (1),
    begin
        Logger.VerboseLog(" - Row inserted")
        Counters.Inserts += 1
    end
    (2),
    begin
        Logger.VerboseLog(" - Row exists, switching to UPDATE")
        status = 1
        if (switchDone) then
        begin
            Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
        end
        else
        begin
            switchMode = true
            call DoUpdateRelative
        end
    end
    endusing

    return

    ;-----------------------------------------------------------------------------
    ; Update an existing row (ISAM)
    ;
DoUpdate,
    
    if (switchMode) then
    begin
        Logger.VerboseLog(" - Update row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeyValues)
        begin
            functionName = %atrim(instruction.structure_name) + "KeyVal"
            status = %xsubr(functionName,instruction.record,keyValue,keyLength)
            Logger.VerboseLog(" - Key: " + keyValue(1:keyLength))
        end
    end

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Update"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Update"
    endusing

    repeat
    begin
        data doReturn, boolean, false

        try
        begin
            status = %xsubr(functionName,instruction.record(1,structure_data.structure_size),rows,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    if (status) then
    begin
        if (rows) then
        begin
            Logger.VerboseLog(" - Row updated")
            Counters.Updates += 1
        end
        else
        begin
            Logger.VerboseLog(" - Row not found, switching to INSERT")
            status = 1
            if (switchDone) then
            begin
                Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchMode = true
                call DoInsert
            end
        end
    end
    else
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end

    return

    ;-----------------------------------------------------------------------------
    ; Update an existing row (RELATIVE)
    ;
DoUpdateRelative,

    if (switchMode) then
    begin
        Logger.VerboseLog(" - Update row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeyValues)
        begin
            data pos,   i4, %instr(1,instruction.record,":")
            recordNumber = instruction.record(1:pos-1)
            instruction.record = instruction.record(pos+1:structure_data.structure_size)
            Logger.VerboseLog(" - Record #: " + %string(recordNumber))
        end
    end

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Update"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Update"
    endusing

    repeat
    begin
        data doReturn, boolean, false

        try
        begin
            status = %xsubr(functionName,recordNumber,instruction.record(1,structure_data.structure_size),rows,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    if (status) then
    begin
        if (rows) then
        begin
            Logger.VerboseLog(" - Row updated")
            Counters.Updates += 1
        end
        else
        begin
            Logger.VerboseLog(" - Row not found, switching to INSERT")
            status = 1
            if (switchDone) then
            begin
                Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchMode = true
                call DoInsertRelative
            end
        end
    end
    else
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end

    return

    ;-----------------------------------------------------------------------------
    ; Delete a row
    ;
DoDelete,

    functionName = %atrim(instruction.structure_name) + "KeyVal"
    status = %xsubr(functionName,instruction.record,keyValue,keyLength)

    if (Settings.LogKeyValues)
    begin
        Logger.VerboseLog(" - Key: " + keyValue(1:keyLength))
    end

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Delete"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Delete"
    endusing

    repeat
    begin
        try
        begin
            status = %xsubr(functionName,keyValue(1:keyLength),dberrtxt)

            if (status) then
            begin
                Logger.VerboseLog(" - Row deleted")
                Counters.Deletes += 1
            end
            else
            begin
                Logger.VerboseLog(" - " + dberrtxt)
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    return

    ;-----------------------------------------------------------------------------
    ; Create a new table
    ;
DoCreateTable,

    ;Create a new table (only)
    ;If the table already exists, do nothing

    Logger.VerboseLog(" - Checking if table exists")

    repeat
    begin
        using Settings.DatabaseConnectMode select
        (DatabaseConnectionMode.SqlConnection),
            functionName = %atrim(instruction.structure_name) + "Exists"
        (DatabaseConnectionMode.SqlClient),
            functionName = %atrim(instruction.structure_name) + "_Exists"
        endusing

        try
        begin
            status = %xsubr(functionName,dberrtxt)

            using status select
            (1),
            begin
                Logger.VerboseLog(" - Table exists!")
                exitloop
            end
            (0),
            begin
                Logger.VerboseLog(" - Creating table")

                repeat
                begin
                    using Settings.DatabaseConnectMode select
                    (DatabaseConnectionMode.SqlConnection),
                        functionName = %atrim(instruction.structure_name) + "Create"
                    (DatabaseConnectionMode.SqlClient),
                        functionName = %atrim(instruction.structure_name) + "_Create"
                    endusing

                    try
                    begin
                        status = %xsubr(functionName,dberrtxt)

                        if (status) then
                        begin
                            if (EmailSettings.CanSendEmail())
                            begin
                                data subject, string, "SQL replicator " + Settings.InstanceName + " created table " + %atrimtostring(instruction.structure_name)
                                xcall SendEmail(subject,^null,false)
                            end
                        end
                        else
                        begin
                            Logger.LogFunctionError(functionName,status,dberrtxt)
                        end
                    end
                    catch (ex, @DatabaseCommunicationException)
                    begin
                        ;Attempt to disconnect from and re-connect to the database
                        if (%DatabaseReconnect) then
                        begin
                            ;Re-connected, retry the previous operation
                            nextloop
                        end
                        else
                        begin
                            xcall ReplicatorShutdown
                        end
                    end
                    catch (ex, @SynException)
                    begin
                        ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
                    end
                    endtry
                    exitloop
                end
                exitloop
            end
            (<0),
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
                exitloop
            end
            endusing
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    return

    ;-----------------------------------------------------------------------------
    ; Load new data into existing table
    ;
DoLoadTable,

    ;Do a full load of an existing table with new data

    Logger.VerboseLog(" - Checking if table exists")

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Exists"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Exists"
    endusing

    repeat
    begin
        data doReturn, boolean, false
        try
        begin
            status = %xsubr(functionName,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    using status select
    (1),
    begin
        Logger.VerboseLog(" - Table exists")

        ;Delete any and all existing data before loading new data
        call DoDeleteAllRows

        if (bulkLoad || bulkCopy) then
        begin
            call BulkLoadTable
        end
        else
        begin
            call LoadTable
        end
    end
    (0),
    begin
        Logger.VerboseLog(" - Table does not exist!")
    end
    (<0),
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end
    endusing

    return

    ;-----------------------------------------------------------------------------
    ; Create a new table and load new data into it
    ;
DoCreateAndLoadTable,
    
    ;Create a new table, do nothing if the table already exists
    ;We create the table, then do a full load of data
    call CheckTable

    return

    ;-----------------------------------------------------------------------------
    ; Export ISAM file to CSV file
    ;
DoCreateCsv,

    Logger.Log(" - Export starting at " + %TimeNow)

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Csv"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Csv"
    endusing

    try
    begin
        data csvFileSpec, string, Settings.LocalExportPath + %atrim(instruction.structure_name) + ".Csv"
        data recordCount, i4, 0

        status = %xsubr(functionName,(a)csvFileSpec,0,recordCount,dberrtxt)

        if (status) then
        begin
            Logger.VerboseLog(" - Export complete at " + %TimeNow)
        end
        else
        begin
            Logger.LogFunctionError(functionName,status,dberrtxt)
        end
    end
    catch (ex, @SynException)
    begin
        ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

    ;-----------------------------------------------------------------------------
    ; Delete all rows from an existing table
    ;
DoDeleteAllRows,

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Clear"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Clear"
    endusing

    repeat
    begin
        try
        begin
            status = %xsubr(functionName,dberrtxt)

            if (status) then
            begin
                Logger.VerboseLog(" - Table truncated")

                if (EmailSettings.CanSendEmail())
                begin
                    data subject, string, "SQL replicator " + Settings.InstanceName + " truncated table " + %atrim(instruction.structure_name)
                    xcall SendEmail(subject,^null,false)
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    return

    ;-----------------------------------------------------------------------------
    ; Delete an existing table
    ;
DoDeleteTable,

    ;Is the table recorded in the list of open tables?
    if (nsptr=%nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data))
    begin
        ;Yes, remove it
        xcall nspc_delete(Settings.ChannelInfo,nsptr)
    end

    Logger.VerboseLog(" - Checking if table exists")

    repeat
    begin
        using Settings.DatabaseConnectMode select
        (DatabaseConnectionMode.SqlConnection),
            functionName = %atrim(instruction.structure_name) + "Exists"
        (DatabaseConnectionMode.SqlClient),
            functionName = %atrim(instruction.structure_name) + "_Exists"
        endusing

        try
        begin
            status = %xsubr(functionName,dberrtxt)

            using status select
            (0),
            begin
                Logger.VerboseLog(" - Table does not exist!")
                exitloop
            end
            (1),
            begin
                Logger.VerboseLog(" - Deleting table")

                repeat
                begin
                    using Settings.DatabaseConnectMode select
                    (DatabaseConnectionMode.SqlConnection),
                        functionName = %atrim(instruction.structure_name) + "Drop"
                    (DatabaseConnectionMode.SqlClient),
                        functionName = %atrim(instruction.structure_name) + "_Drop"
                    endusing

                    try
                    begin
                        status = %xsubr(functionName,dberrtxt)

                        if (status) then
                        begin
                            Logger.VerboseLog(" - Table deleted")

                            if (EmailSettings.CanSendEmail())
                            begin
                                data subject, string, "SQL replicator " + Settings.InstanceName + " deleted table " + %atrim(instruction.structure_name)
                                xcall SendEmail(subject,^null,false)
                            end
                        end
                        else
                        begin
                            Logger.LogFunctionError(functionName,status,dberrtxt)
                        end
                    end
                    catch (ex, @DatabaseCommunicationException)
                    begin
                        ;Attempt to disconnect from and re-connect to the database
                        if (%DatabaseReconnect) then
                        begin
                            ;Re-connected, retry the previous operation
                            nextloop
                        end
                        else
                        begin
                            xcall ReplicatorShutdown
                        end
                    end
                    catch (ex, @SynException)
                    begin
                        ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
                    end
                    endtry
                    exitloop
                end
                exitloop
            end
            (<0),
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
                exitloop
            end
            endusing
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    return

    ;-----------------------------------------------------------------------------
    ; Add alternate key indexes to a table (if they don't already exist)
    ;
DoAddIndexes,

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "Index"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_Index"
    endusing

    repeat
    begin
        try
        begin
            status = %xsubr(functionName,dberrtxt)

            if (status) then
            begin
                Logger.VerboseLog(" - Indexes added")

                if (EmailSettings.CanSendEmail())
                begin
                    data subject, string, "SQL replicator " + Settings.InstanceName + " added indexes to table " + %atrim(instruction.structure_name)
                    xcall SendEmail(subject,^null,false)
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @RoutineNotFound)
        begin
            Logger.VerboseLog(" - Addining indexes is not enabled for this table.")
            exitloop
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    return

    ;-----------------------------------------------------------------------------
    ; Delete alternate key indexes from a table
    ;
DoDeleteIndexes,

    using Settings.DatabaseConnectMode select
    (DatabaseConnectionMode.SqlConnection),
        functionName = %atrim(instruction.structure_name) + "UnIndex"
    (DatabaseConnectionMode.SqlClient),
        functionName = %atrim(instruction.structure_name) + "_UnIndex"
    endusing

    repeat
    begin
        try
        begin
            status = %xsubr(functionName,dberrtxt)

            if (status) then
            begin
                Logger.VerboseLog(" - Indexes removed")

                if (EmailSettings.CanSendEmail())
                begin
                    data subject, string, "SQL replicator " + Settings.InstanceName + " removed indexes from table " + %atrim(instruction.structure_name)
                    xcall SendEmail(subject,^null,false)
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @RoutineNotFound)
        begin
            Logger.VerboseLog(" - Removing indexes is not enabled for this table.")
            exitloop
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    return

endmain
